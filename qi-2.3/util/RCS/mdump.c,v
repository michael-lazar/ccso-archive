head	1.20;
access;
symbols;
locks; strict;
comment	@ * @;


1.20
date	94.03.13.20.11.57;	author paul;	state Exp;
branches;
next	1.19;

1.19
date	94.03.12.03.54.09;	author paul;	state Exp;
branches;
next	1.18;

1.18
date	94.03.12.00.59.25;	author paul;	state Exp;
branches;
next	1.17;

1.17
date	94.03.09.17.14.27;	author paul;	state Exp;
branches;
next	1.16;

1.16
date	94.01.07.18.05.42;	author paul;	state Exp;
branches;
next	1.15;

1.15
date	93.10.11.16.11.01;	author paul;	state Exp;
branches;
next	1.14;

1.14
date	93.05.06.04.07.25;	author paul;	state Exp;
branches;
next	1.13;

1.13
date	93.04.16.02.11.11;	author paul;	state Exp;
branches;
next	1.12;

1.12
date	93.04.02.16.14.43;	author paul;	state Exp;
branches;
next	1.11;

1.11
date	93.04.01.16.27.58;	author paul;	state Exp;
branches;
next	1.10;

1.10
date	93.02.14.19.56.35;	author paul;	state Exp;
branches;
next	1.9;

1.9
date	93.01.23.19.59.39;	author paul;	state Exp;
branches;
next	1.8;

1.8
date	92.12.12.19.11.39;	author paul;	state Exp;
branches;
next	1.7;

1.7
date	92.08.17.13.41.41;	author paul;	state Exp;
branches;
next	1.6;

1.6
date	92.07.29.04.15.49;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	92.07.28.16.15.23;	author paul;	state Exp;
branches;
next	1.4;

1.4
date	92.07.28.05.04.09;	author paul;	state Exp;
branches;
next	1.3;

1.3
date	92.07.27.22.20.02;	author paul;	state Exp;
branches;
next	1.2;

1.2
date	92.07.27.19.49.46;	author paul;	state Exp;
branches;
next	1.1;

1.1
date	92.07.27.19.49.27;	author paul;	state Exp;
branches;
next	;


desc
@@


1.20
log
@*** empty log message ***
@
text
@/*
 * Copyright (c) 1985 Corporation for Research and Educational Networking
 * Copyright (c) 1988 University of Illinois Board of Trustees, Steven
 *		Dorner, and Paul Pomes
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Corporation for
 *	Research and Educational Networking (CREN), the University of
 *	Illinois at Urbana, and their contributors.
 * 4. Neither the name of CREN, the University nor the names of their
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE TRUSTEES AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE TRUSTEES OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
static char  RcsId[] = "@@(#)$Id: mdump.c,v 1.19 1994/03/12 03:54:09 paul Exp paul $";
#endif

#include "protos.h"

#include <sys/types.h>
#include <sys/file.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pwd.h>

int	Progress = 0;
static char *Me;		/* the name of this program */
extern int Quiet;		/* qi/qi.c */

#define LENGTH	80

struct dumptype
{
	char	*name;
	int	(*select) ();
	int	(*dump) ();
};

char	Kdomain[50];

struct dumptype * FindDump __P((char *));
char * escapeChars __P((char *));

int     sel_students(), sel_other(), sel_rejects(), sel_pubpeople(),
	sel_units(), dump_extra(), dump_all(), dump_4merge(), sel_people(),
	sel_countpw(), dump_nothing(), sel_email(), sel_all(), sel_weather(),
	sel_outsider(), dump_kerb(), sel_kerb(),
	dump_email(), dump_aiss(), dump_size(), dump_ruchi(), dump_emdir(),
	dump_food(), sel_food(), sel_time(), sel_maggie(), dump_maggie(),
	sel_proxy(), dump_proxy(), dump_randy(), sel_files(), dump_files(),
	dump_date(), dump_generics();

struct dumptype Dumps[] =
{
	"people", sel_people, dump_4merge,
	"other", sel_other, dump_all,
	"outsider", sel_outsider, dump_all,
	"time", sel_time, dump_all,
	"rejects", sel_rejects, dump_all,
	"units", sel_units, dump_all,
	"count_pw", sel_countpw, dump_nothing,
	"count_email", sel_email, dump_nothing,
	"all", sel_all, dump_all,
	"email", sel_email, dump_email,
	"weather", sel_weather, dump_all,
	"generics", sel_email, dump_generics,
	"aiss", sel_email, dump_aiss,
	"ruchi", sel_pubpeople, dump_ruchi,
	"email_dir", sel_email, dump_emdir,
	"entry_sizes", sel_all, dump_size,
	"food", sel_food, dump_food,
	"maggie", sel_maggie, dump_maggie,
	"proxy", sel_proxy, dump_proxy,
	"randy", sel_pubpeople, dump_randy,
	"files", sel_files, dump_files,
	"date", sel_all, dump_date,
	"kerberos", sel_kerb, dump_kerb,
	0, 0, 0
};

main(argc, argv)
	int	argc;
	char   **argv;
{
	long	entry;
	QDIR	dirp;
	int	count;
	int	selected;
	extern struct dirhead DirHead;
	struct dumptype *dt;

	/* when you're strange, no one remembers your name */
	Me = *argv;

	while (--argc > 0 && **(++argv) == '-')
	{
		char *equal, **opt;

		(*argv)++;
		if (**argv == 'p')
			Progress = 1;
		else if (**argv == 'q')
			Quiet = 1;
		else if (equal = (char *)strchr(*argv, '='))
		{
			*equal++ = 0;
			for (opt = Strings; *opt; opt += 2)
				if (!strcmp(opt[0], *argv))
				{
					opt[1] = equal;
					break;
				}
			if (*opt == '\0')
			{
				fprintf(stderr, "%s: %s: unknown string.\n",
					Me, *argv);
				exit(1);
			}
		} else
		{
			fprintf(stderr, "%s: %s: unknown option.\n", Me, *argv);
			exit(1);
		}
	}
	{
		char *cp;

		(void) strcpy(Kdomain, MAILDOMAIN);
		for (cp = Kdomain; *cp; cp++)
			if (islower(*cp))
				*cp = toupper(*cp);
	}

	if ((dt = FindDump(*argv)) == NULL)
	{
		fprintf(stderr, "Usage: mdump [-p] [-q] <dump-type> [<database>]\n");
		fprintf(stderr, "available dump types are:\n");
		for (dt = Dumps; dt -> name; dt++)
			fprintf(stderr, " %s", dt -> name);
		putc('\n', stderr);
		exit(1);
	}
	argc--;
	argv++;
	Database = (argc > 0) ? *argv : DATABASE;
	if (!Quiet)
		fprintf(stderr, "%s: dumping database %s\n", Me, Database);
	DoSysLog(0);
	if (!GetFieldConfig())
		exit(1);
	if (!dbd_init(Database))
		exit(1);
	get_dir_head();
	selected = count = 0;
	for (entry = 1; entry < DirHead.nents; entry++)
	{
		if (Progress && !(entry % 100))
			fprintf(stderr, "%d/%d/%d\r", selected, entry, DirHead.nents);
		if (dnext_ent(entry) && !ent_dead())
		{
			count++;
			(void) getdata(&dirp);
			if ((*dt -> select) (dirp))
			{
				selected++;
				(*dt -> dump) (dirp);
			}
			MdumpFreeDir(&dirp);
		}
#ifdef DEBUG
		if (entry % 500 == 0)
			fprintf(stderr, " %d/%d\r", entry, DirHead.nents);
#endif
	}
	fflush(stdout);
	if (!Quiet)
		fprintf(stderr, "Database %s: %d of %d selected, %d errors.\n",
			Database, selected, count, entry - 1 - count);
	exit(0);
}

/*
 * figure out if a named dump exists
 */
struct dumptype *
FindDump(name)
	char	*name;
{
	struct dumptype *dt;

	for (dt = Dumps; dt -> name; dt++)
		if (!strcmp(dt -> name, name))
			return (dt);
	return (NULL);
}

/*
 * anybody with an id
 */
sel_id(dirp)
	char   **dirp;
{
	return (*FINDVALUE(dirp, F_UNIVID));
}

/*
 * anybody with a proxy
 */
sel_proxy(dirp)
	char   **dirp;
{
	return (*FINDVALUE(dirp, F_PROXY));
}

/*
 *
 */
dump_proxy(dirp)
	char   **dirp;
{
	if (*FINDVALUE(dirp, F_ALIAS))
		printf("change alias=%s make proxy=\"%s\"\n",
		       FINDVALUE(dirp, F_ALIAS), escapeChars(FINDVALUE(dirp, F_PROXY)));
	else
		printf("change %s make proxy=\"%s\"\n",
		       FINDVALUE(dirp, F_NAME), escapeChars(FINDVALUE(dirp, F_PROXY)));
}

/*
 * units (campus unit listing)
 */
sel_units(dirp)
	char   **dirp;
{
	return (strstr(FINDVALUE(dirp, F_TYPE), "unit") != NULL);
}

/*
 * timetable
 */
sel_time(dirp)
	char   **dirp;
{
	return (strstr(FINDVALUE(dirp, F_TYPE), "timetable") != NULL);
}

/*
 * people - anyone with type "person"
 */
sel_people(dirp)
	char   **dirp;
{
	return (strstr(FINDVALUE(dirp, F_TYPE), "person") != NULL);
}

/*
 * outsiders
 */
sel_outsider(dirp)
	char   **dirp;
{
	return (strstr(FINDVALUE(dirp, F_TYPE), "outsider") != NULL);
}

/*
 * Kerberos (people and outsiders)
 */
sel_kerb(dirp)
	char   **dirp;
{
	return (strstr(FINDVALUE(dirp, F_TYPE), "person") != NULL ||
		strstr(FINDVALUE(dirp, F_TYPE), "outsider") != NULL);
}

sel_pubpeople(dirp)
	char   **dirp;
{
	return (sel_people(dirp) && !*FINDVALUE(dirp, F_SUPPRESS));
}

sel_other(dirp)
	char   **dirp;
{
	return (!sel_people(dirp) && !sel_time(dirp));
}

sel_rejects(dirp)
	char   **dirp;
{
	char	*type;

	if (sel_people(dirp))
		return (0);
	if (sel_other(dirp))
		return (0);
	type = FINDVALUE(dirp, F_TYPE);
	if (strstr(type, "food") != NULL)
		return (0);
	if (strstr(type, "timetable") != NULL)
		return (0);
	return (1);
}

/*
 *
 */
sel_email(dirp)
	char   **dirp;
{
	return (*FINDVALUE(dirp, F_EMAIL) && !*FINDVALUE(dirp, F_SUPPRESS));
}

/*
 *
 */
sel_food(dirp)
	char   **dirp;
{
	return (strstr(FINDVALUE(dirp, F_TYPE), "food") != NULL);
}

/*
 *
 */
sel_weather(dirp)
	char   **dirp;
{
	return (strstr(FINDVALUE(dirp, F_TYPE), "weather") != NULL);
}

dump_food(dirp)
	char   **dirp;
{
	printf("delete %s\n", FINDVALUE(dirp, F_NAME));
}

/*
 *
 */
sel_countpw(dirp)
	char   **dirp;
{
	return (*FINDVALUE(dirp, F_PASSWORD));
}

/*
 *
 */
sel_idpw(dirp)
	char   **dirp;
{
	return (*FINDVALUE(dirp, F_UNIVID) || *FINDVALUE(dirp, F_PASSWORD));
}

/*
 *
 */
sel_maggie(dirp)
	char   **dirp;
{
	return (sel_people(dirp) && *FINDVALUE(dirp, F_EMAIL));
}

dump_maggie(dirp)
	char   **dirp;
{
	char	scratch[300];
	char	*space;
	char	*paper = FINDVALUE(dirp, F_PAPER);
	char	*id = FINDVALUE(dirp, F_UNIVID);
	char	**opt;
	static char *maild = NULL;

	/*
	 * if paper field is "no", we omit the user
	 */
	if (!strcmp(paper, "no"))
	{
		printf("%d:%s\t%d:!omit!\n", F_UNIVID, id, F_EMAIL);
		return;
	}
	/*
	 * if paper field is specific, we grab the first specified address
	 * if it's <50 characters long, we print it.  Otherwise, we fall
	 * through and print the alias-based address, since > 50 chars is
	 * unprintable
	 */
	else if (!strcmp(paper, "specific"))
	{
		strcpy(scratch, FINDVALUE(dirp, F_EMAIL));
		if (space = strtok(scratch, " \n\t,"))
		{
			if (strlen(space) <= 50)
			{
				printf("%d:%s\t%d:%s\n", F_UNIVID, id, F_EMAIL, space);
				return;
			}
		}
	}
	/*
	 * print the alias-based address
	 */
	if (maild == NULL)
	{
		for (opt = Strings; *opt; opt += 2)
			if (!strcmp(opt[0], "MAILDOMAIN"))
				maild = opt[1];
		if (maild == NULL)
		{
			fprintf(stderr, "Couldn't determine MAILDOMAIN.\n");
			exit(1);
		}
	}
	printf("%d:%s\t%d:%s@@%s\n", F_UNIVID, id,
	       F_EMAIL, FINDVALUE(dirp, F_ALIAS), maild);
}

/*
 *
 */
/*ARGSUSED*/
dump_nothing(dirp)
	char   **dirp;
{
	return;
}

/*
 *
 */
dump_aiss(dirp)
	char   **dirp;
{
	int	len;
	char	name[51], email[30];

	name[sizeof (name) - 1] = email[sizeof (email) - 1] = '\0';
	strncpy(name, FINDVALUE(dirp, F_NAME), sizeof (name) - 1);
	strncpy(email, FINDVALUE(dirp, F_EMAIL), sizeof (email) - 1);
	printf("%-*s %*s\n", sizeof (name) - 1, name, sizeof (email) - 1, email);
}

/*
 * Generic addresses for use in IDA generics table
 */
dump_generics(dirp)
	char   **dirp;
{
	printf("%s\t%s\n", FINDVALUE(dirp, F_ALIAS),
		FINDVALUE(dirp, F_EMAIL));
}


/*
 *
 */
/*ARGSUSED*/
sel_all(dirp)
	char   **dirp;
{
	return (1);
}

dump_email(dirp)
	char   **dirp;
{
	printf("change alias=%s make email=\"%s\"\n", FINDVALUE(dirp, F_ALIAS),
	       FINDVALUE(dirp, F_EMAIL));
}

/*
 *
 */
dump_ruchi(dirp)
	char   **dirp;
{
#define PUT_OUT(num) printf("$#$%s",escapeChars(FINDVALUE(dirp,num)))
	PUT_OUT(F_UNIVID);
	PUT_OUT(F_NAME);
	PUT_OUT(F_ALIAS);
	PUT_OUT(F_EMAIL);
	PUT_OUT(F_PHONE);
	PUT_OUT(F_ADDRESS);
	PUT_OUT(F_DEPARTMENT);
	PUT_OUT(F_TITLE);
	PUT_OUT(19);		/* office location */
	PUT_OUT(20);		/* home address */
	PUT_OUT(23);		/* nickname */
	PUT_OUT(22);		/* office address */
	PUT_OUT(32);		/* office phone */
	PUT_OUT(33);		/* home phone */
	putchar('\n');
}

/*
 *
 */
dump_randy(dirp)
	char   **dirp;
{
	printf("%s\t", escapeChars(FINDVALUE(dirp, F_ALIAS)));
	printf("%s\t", escapeChars(FINDVALUE(dirp, F_NAME)));
	printf("%s\t", escapeChars(FINDVALUE(dirp, 32)));
	printf("%s\n", escapeChars(FINDVALUE(dirp, F_EMAIL)));
}

/*
 *
 */
dump_emdir(dirp)
	char   **dirp;
{
	if (*FINDVALUE(dirp, F_DEPARTMENT))
		printf("%-25s %s@@%s\n", FINDVALUE(dirp, F_NAME),
			FINDVALUE(dirp, F_ALIAS), MAILDOMAIN);
}

/*
 *
 */
dump_size(dirp)
	char   **dirp;
{
	int	size = 0;
	char   **sp = dirp;

	for (sp = dirp; *sp; sp++)
	{
		size += strlen(*sp);
		size++;
	}
	printf("%d\n", size);
}

/*
 *
 */
dump_all(dirp)
	char   **dirp;
{
	char	*colon;

	printf("%d:%s", F_UNIVID, escapeChars(FINDVALUE(dirp, F_UNIVID)));
	for (; *dirp; dirp++)
		if (atoi(*dirp) != F_UNIVID && (colon = (char *)strchr(*dirp, ':')) && colon[1])
		{
			putchar('\t');
			fputs(escapeChars(*dirp), stdout);
		}
	putchar('\n');
}

/*
 *
 */
dump_4merge(dirp)
	char   **dirp;
{
	char	*colon;
	int	f;
	char	*fdMerge;
	int	no_up = *FINDVALUE(dirp, 31);	/* no_update */
	FDESC	*fd;

	printf("%d:%s", F_UNIVID, escapeChars(FINDVALUE(dirp, F_UNIVID)));
	for (; *dirp; dirp++)
	{
		f = atoi(*dirp);
		if (f != F_UNIVID && (colon = (char *)strchr(*dirp, ':')) && colon[1])
		{
			if (fd = FindFDI(f))
			{
				if (*fd -> fdMerge)
				{
					putchar('\t');
					fputs(escapeChars(*dirp), stdout);
				}
			} else
				fprintf(stderr, "%s unknown field %d\n", FINDVALUE(dirp, F_NAME), f);
		}
	}
	putchar('\n');
}

/*
 * replace tabs and newlines with escaped equivalents
 */
char	*
escapeChars(s)
	char	*s;
{
	register char *cp;
	static char value[8192];
	register char *vp;

	vp = value;
	for (cp = s; *cp; cp++)
		if (*cp == '\t')
		{
			*vp++ = '\\';
			*vp++ = 't';
		} else if (*cp == '\n')
		{
			*vp++ = '\\';
			*vp++ = 'n';
		} else if (*cp == '\\')
		{
			*vp++ = '\\';
			*vp++ = '\\';
		} else
			*vp++ = *cp;
	*vp = '\0';
	return (value);
}

/*
 * Free a dir structure (modified for mdump)
 */
MdumpFreeDir(dir)
	QDIR *dir;
{
	char   **p;

	if (*dir)
	{
		for (p = *dir; *p; p++)
			free(*p);
		/*free(*dir);
		*dir = 0;*/
	}
}

sel_files(dirp)
	char   **dirp;
{
	return (*FINDVALUE(dirp, 104));
}

dump_files(dirp)
	char   **dirp;
{
	char	*token;

	for (token = strtok(FINDVALUE(dirp, 104), " \n\t,"); token; token = strtok(NULL, " \t\n,"))
		puts(token);
}

dump_date(dirp)
	char   **dirp;
{
	printf("%ld %s\n", CurrentDate(), FINDVALUE(dirp, F_ALIAS));
}

dump_kerb(dirp)
	char   **dirp;
{
	char *alias = FINDVALUE(dirp, F_ALIAS);
	char *pass = FINDVALUE(dirp, F_PASSWORD);
	
	if (strlen(alias) > 8 || *pass == '\0')
		return;
	printf("ank %s@@%s\n%.8s\n", alias, Kdomain, pass);
}
@


1.19
log
@Change   return(strstr(a,b)) statements into   return(strstr(a,b) != NULL)
@
text
@d38 1
a38 1
static char  RcsId[] = "@@(#)$Id: mdump.c,v 1.18 1994/03/12 00:59:25 paul Exp paul $";
a686 51
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)strstr.c	5.1 (Berkeley) 5/15/90";
#endif /* LIBC_SCCS and not lint */

#ifdef NO_STRSTR

/*
 * Find the first occurrence of find in s.
 */
char *
strstr(s, find)
	register char *s, *find;
{
	register char c, sc;
	register int len;

	if ((c = *find++) != 0) {
		len = strlen(find);
		do {
			do {
				if ((sc = *s++) == 0)
					return ((char *) 0);
			} while (sc != c);
		} while (strncmp(s, find, len) != 0);
		s--;
	}
	return ((char *)s);
}
#endif
@


1.18
log
@New copyright statement.
@
text
@d38 1
a38 1
static char  RcsId[] = "@@(#)$Id$";
d258 1
a258 1
	return (strstr(FINDVALUE(dirp, F_TYPE), "unit"));
d267 1
a267 1
	return (strstr(FINDVALUE(dirp, F_TYPE), "timetable"));
d276 1
a276 1
	return (strstr(FINDVALUE(dirp, F_TYPE), "person"));
d285 1
a285 1
	return (strstr(FINDVALUE(dirp, F_TYPE), "outsider"));
d294 2
a295 2
	return (strstr(FINDVALUE(dirp, F_TYPE), "person") ||
		strstr(FINDVALUE(dirp, F_TYPE), "outsider"));
d320 1
a320 1
	if (strstr(type, "food"))
d322 1
a322 1
	if (strstr(type, "timetable"))
d342 1
a342 1
	return (strstr(FINDVALUE(dirp, F_TYPE), "food"));
d351 1
a351 1
	return (strstr(FINDVALUE(dirp, F_TYPE), "weather"));
@


1.17
log
@*** empty log message ***
@
text
@a0 1
#include "protos.h"
d2 33
a34 5
 * This software is Copyright (C) 1988-1991 by Steven Dorner and the
 * University of Illinois Board of Trustees.  No warranties of any
 * kind are expressed or implied.  No support will be provided.
 * This software may not be redistributed for commercial purposes.
 * You may direct questions to nameserv@@uiuc.edu
d36 6
@


1.16
log
@Replaced index() with strchr().
@
text
@d654 51
@


1.15
log
@Added code to dump kerberos keys.
@
text
@d94 1
a94 1
		else if (equal = index(*argv, '='))
d535 1
a535 1
		if (atoi(*dirp) != F_UNIVID && (colon = index(*dirp, ':')) && colon[1])
d559 1
a559 1
		if (f != F_UNIVID && (colon = index(*dirp, ':')) && colon[1])
@


1.14
log
@Use strstr() to locate type values.
@
text
@d29 2
d37 1
a37 1
	sel_outsider(),
d67 1
d115 9
d255 10
d642 11
@


1.13
log
@Quiet now a global in qi/qi.c .
@
text
@d35 1
d45 1
d213 1
a213 1
	return (!strcmp(FINDVALUE(dirp, F_TYPE), "unit phone"));
d222 1
a222 1
	return (!strncmp(FINDVALUE(dirp, F_TYPE), "timetable", 8));
d231 1
a231 1
	return (!stricmp(FINDVALUE(dirp, F_TYPE), "person phone"));
d234 9
d265 1
a265 1
	if (!strncmp(type, "food", 4))
d267 1
a267 1
	if (!strncmp(type, "timetable", 8))
d287 1
a287 1
	return (!strcmp(FINDVALUE(dirp, F_TYPE), "food"));
d296 1
a296 1
	return (!strcmp(FINDVALUE(dirp, F_TYPE), "weather"));
@


1.12
log
@Announce which database is being smashed, uhhhh built, and pause 5 seconds.
@
text
@a16 1
int	Quiet = 0;
d18 1
@


1.11
log
@Now can modify Strings[] like qi, e.g. prog -DATABASE=/tmp/foo .
@
text
@d122 2
@


1.10
log
@Add support for printing generic addresses for use by IDA sendmail.
@
text
@d18 1
d77 4
a80 1
	for (argc--, argv++; argc && **argv == '-'; argc--, argv++)
d82 4
a85 1
		if (strcmp(*argv, "-p") == 0)
d87 1
a87 1
		else if (strcmp(*argv, "-q") == 0)
d89 20
a108 2
		else
			break;
d110 1
a110 1
	if (argc != 1 && argc != 2 || !(dt = FindDump(argv[0])))
d119 4
a122 8
#ifdef LOG_DAEMON
# ifndef LOG_QILOG
#  define	LOG_QILOG	LOG_DAEMON
# endif	/* !LOG_QILOG */
	openlog("mdump", LOG_PID, LOG_QILOG);
#else
	openlog("mdump", LOG_PID);
#endif
a123 2
	{
		fprintf(stderr, "Couldn't read prod.cnf.\n");
a124 4
	}
	argc--; argv++;
	if (argc > 0)
		(void) strcpy(Database, *argv);
a125 3
	{
		fprintf(stderr, "%d:Couldn't open database %s.\n",
			LR_INTERNAL, Database);
a126 1
	}
d151 2
a152 2
		fprintf(stderr, "%d of %d selected, %d errors.\n", selected, count,
			entry - 1 - count);
@


1.9
log
@*** empty log message ***
@
text
@d37 1
a37 1
	dump_date();
d51 1
d387 9
@


1.8
log
@Up-cased all #define's.  Made more intelligent about selecting the right
openlog().
@
text
@a92 4
	if (argc > 1)
		(void) strcpy(Database, *argv);
	else
		(void) strcpy(Database, DATABASE);
d106 3
d111 2
a112 1
		fprintf(stderr, "%d:Couldn't open database.", LR_INTERNAL);
@


1.7
log
@Added openlog() to catch error messages.
@
text
@a15 1
extern char *Database;
d93 12
a104 1
	openlog("mdump",  LOG_PID, LOG_QILOG);
a109 2
	if (argc > 1)
		Database = argv[1];
d165 1
a165 1
	return (*FindValue(dirp, F_UNIVID));
d174 1
a174 1
	return (*FindValue(dirp, F_PROXY));
d183 1
a183 1
	if (*FindValue(dirp, F_ALIAS))
d185 1
a185 1
		       FindValue(dirp, F_ALIAS), escapeChars(FindValue(dirp, F_PROXY)));
d188 1
a188 1
		       FindValue(dirp, F_NAME), escapeChars(FindValue(dirp, F_PROXY)));
d197 1
a197 1
	return (!strcmp(FindValue(dirp, F_TYPE), "unit phone"));
d206 1
a206 1
	return (!strncmp(FindValue(dirp, F_TYPE), "timetable", 8));
d215 1
a215 1
	return (!stricmp(FindValue(dirp, F_TYPE), "person phone"));
d221 1
a221 1
	return (sel_people(dirp) && !*FindValue(dirp, F_SUPPRESS));
d239 1
a239 1
	type = FindValue(dirp, F_TYPE);
d253 1
a253 1
	return (*FindValue(dirp, F_EMAIL) && !*FindValue(dirp, F_SUPPRESS));
d262 1
a262 1
	return (!strcmp(FindValue(dirp, F_TYPE), "food"));
d271 1
a271 1
	return (!strcmp(FindValue(dirp, F_TYPE), "weather"));
d277 1
a277 1
	printf("delete %s\n", FindValue(dirp, F_NAME));
d286 1
a286 1
	return (*FindValue(dirp, F_PASSWORD));
d295 1
a295 1
	return (*FindValue(dirp, F_UNIVID) || *FindValue(dirp, F_PASSWORD));
d304 1
a304 1
	return (sel_people(dirp) && *FindValue(dirp, F_EMAIL));
d312 4
a315 2
	char	*paper = FindValue(dirp, F_PAPER);
	char	*id = FindValue(dirp, F_UNIVID);
d333 1
a333 1
		strcpy(scratch, FindValue(dirp, F_EMAIL));
d346 13
a358 2
	printf("%d:%s\t%d:%s@@uiuc.edu\n", F_UNIVID, id,
	       F_EMAIL, FindValue(dirp, F_ALIAS));
d381 2
a382 2
	strncpy(name, FindValue(dirp, F_NAME), sizeof (name) - 1);
	strncpy(email, FindValue(dirp, F_EMAIL), sizeof (email) - 1);
d401 2
a402 2
	printf("change alias=%s make email=\"%s\"\n", FindValue(dirp, F_ALIAS),
	       FindValue(dirp, F_EMAIL));
d411 1
a411 1
#define PUT_OUT(num) printf("$#$%s",escapeChars(FindValue(dirp,num)))
d435 4
a438 4
	printf("%s\t", escapeChars(FindValue(dirp, F_ALIAS)));
	printf("%s\t", escapeChars(FindValue(dirp, F_NAME)));
	printf("%s\t", escapeChars(FindValue(dirp, 32)));
	printf("%s\n", escapeChars(FindValue(dirp, F_EMAIL)));
d447 3
a449 2
	printf("%-25s %s@@uiuc.edu\n", FindValue(dirp, F_NAME),
	       FindValue(dirp, F_ALIAS));
d477 1
a477 1
	printf("%d:%s", F_UNIVID, escapeChars(FindValue(dirp, F_UNIVID)));
d496 1
a496 1
	int	no_up = *FindValue(dirp, 31);	/* no_update */
d499 1
a499 1
	printf("%d:%s", F_UNIVID, escapeChars(FindValue(dirp, F_UNIVID)));
d513 1
a513 1
				fprintf(stderr, "%s unknown field %d\n", FindValue(dirp, F_NAME), f);
d570 1
a570 1
	return (*FindValue(dirp, 104));
d578 1
a578 1
	for (token = strtok(FindValue(dirp, 104), " \n\t,"); token; token = strtok(NULL, " \t\n,"))
d585 1
a585 1
	printf("%ld %s\n", CurrentDate(), FindValue(dirp, F_ALIAS));
@


1.6
log
@Deleted extraneous #include's.
@
text
@d94 1
@


1.5
log
@*** empty log message ***
@
text
@d1 1
a9 1
#include <stdio.h>
a14 6
#include <ctype.h>
#include "protos.h"
#include "qi.h"
#include "field.h"
#include "db.h"
#include "commands.h"
d34 5
a38 4
	sel_countpw(), dump_nothing(), sel_email(), sel_all(), dump_email(),
	dump_aiss(), dump_size(), dump_ruchi(), dump_emdir(), dump_food(),
	sel_food(), sel_time(), sel_maggie(), dump_maggie(), sel_proxy(),
	dump_proxy(), dump_randy(), sel_files(), dump_files(), dump_date();
d51 1
d254 9
@


1.4
log
@Random fixes.
@
text
@d16 1
a20 1
#include "protos.h"
@


1.3
log
@Re-formatted for clarity
@
text
@d35 2
a36 1
int	sel_students(), sel_other(), sel_rejects(), sel_pubpeople();
d38 6
a43 7
sel_units(), dump_extra(), dump_all(), dump_4merge(), sel_people(),
sel_countpw(), dump_nothing(),
sel_email(), sel_all(),
dump_email(), dump_aiss(), dump_size(),
dump_ruchi(), dump_emdir(), dump_food(), sel_food(),
sel_time(), sel_maggie(), dump_maggie(), sel_proxy(),
dump_proxy(), dump_randy(), sel_files(), dump_files(), dump_date();
d74 1
a74 1
	DIR	dirp;
a349 1
	char	*theId;
d469 1
a469 1
	FieldDesc *theFD;
d477 1
a477 1
			if (theFD = FindFDI(f))
d479 1
a479 1
				if (*theFD -> fdMerge)
d526 1
a526 1
	DIR *dir;
@


1.2
log
@Added -q option from John Sellens <jmsellen@@math.waterloo.edu>
@
text
@d1 7
a7 7
/*********************************************************************
* This software is Copyright (C) 1988-1991 by Steven Dorner and the
* University of Illinois Board of Trustees.  No warranties of any
* kind are expressed or implied.  No support will be provided.
* This software may not be redistributed for commercial purposes.
* You may direct questions to dorner@@garcon.cso.uiuc.edu
**********************************************************************/
d23 2
a24 2
int Progress = 0;
int Quiet = 0;
d26 1
a26 1
#define LENGTH  80
a27 4
char   *strtok();
char *escapeChars();
char **getdata();

d30 3
a32 3
  char *name;
  int (*select)();
  int (*dump)();
d35 32
a66 31
int sel_students(), sel_other(), sel_rejects(), sel_pubpeople();
  sel_units(), dump_extra(), dump_all(), dump_4merge(), sel_people(),
  sel_countpw(), dump_nothing(),
  sel_email(), sel_all(),
  dump_email(), dump_aiss(), dump_size(),
  dump_ruchi(), dump_emdir(), dump_food(), sel_food(),
  sel_time(), sel_maggie(), dump_maggie(), sel_proxy(),
  dump_proxy(), dump_randy(), sel_files(),dump_files(), dump_date();

struct dumptype Dumps[] = 
{
  "people", sel_people, dump_4merge,
  "other", sel_other, dump_all,
  "time", sel_time, dump_all,
  "rejects", sel_rejects, dump_all,
  "units", sel_units, dump_all,
  "count_pw", sel_countpw, dump_nothing,
  "count_email", sel_email, dump_nothing,
  "all", sel_all, dump_all,
  "email", sel_email, dump_email,
  "aiss", sel_email, dump_aiss,
  "ruchi", sel_pubpeople, dump_ruchi,
  "email_dir", sel_email, dump_emdir,
  "entry_sizes", sel_all, dump_size,
  "food", sel_food, dump_food,
  "maggie", sel_maggie, dump_maggie,
  "proxy", sel_proxy, dump_proxy,
  "randy", sel_pubpeople, dump_randy,
  "files", sel_files, dump_files,
  "date", sel_all, dump_date,
  0,0,0
d70 2
a71 2
int   argc;
char  **argv;
d73 54
a126 54
  long   theEntry;
  Dir   theDir;
  int   count;
  int   selected;
  extern struct dirhead DirHead;
  struct dumptype *dt, *FindDump();

  for (argc--,argv++;argc && **argv=='-';argc--,argv++) {
    if (strcmp(*argv,"-p") == 0)
      Progress = 1;
    else if (strcmp(*argv,"-q") == 0)
      Quiet = 1;
    else
      break;
  }
  if (argc != 1 && argc != 2 || !(dt=FindDump(argv[0])))
  {
    fprintf(stderr,"Usage: mdump [-p] [-q] <dump-type> [<database>]\n");
    fprintf(stderr,"available dump types are:\n");
    for (dt=Dumps; dt->name; dt++)
      fprintf(stderr," %s",dt->name);
    putc('\n',stderr);
    exit(1);
  }
  
  if (!GetFieldConfig())
  {
    fprintf(stderr,"Couldn't read prod.cnf.\n");
    exit(1);
  }
  if (argc > 1)
    Database = argv[1];
  if (!dbd_init(Database))
  {
    fprintf(stderr, "%d:Couldn't open database.", LR_INTERNAL);
    exit(1);
  }
  get_dir_head();
  selected = count = 0;
  for (theEntry = 1; theEntry < DirHead.nents; theEntry++)
  {
    if (Progress && !(theEntry%100))
      fprintf(stderr,"%d/%d/%d\r",selected,theEntry,DirHead.nents);
    if (dnext_ent(theEntry) && !ent_dead())
    {
      count++;
      (void) getdata(&theDir);
      if ((*dt->select)(theDir))
      {
	selected++;
	(*dt->dump)(theDir);
      }
      MdumpFreeDir(&theDir);
    }
d128 2
a129 2
    if (theEntry % 500 == 0)
      fprintf(stderr, " %d/%d\r", theEntry, DirHead.nents);
d131 6
a136 6
  }
  fflush(stdout);
  if ( ! Quiet )
    fprintf(stderr, "%d of %d selected, %d errors.\n", selected, count,
      theEntry - 1 - count);
  exit(0);
d139 3
a141 3
/***********************************************************************
* figure out if a named dump exists
***********************************************************************/
d144 1
a144 1
char *name;
d146 1
a146 1
  struct dumptype *dt;
d148 4
a151 4
  for (dt=Dumps; dt->name; dt++)
    if (!strcmp(dt->name,name))
      return(dt);
  return(NULL);
d154 1
a154 1
/************************************************************************
d156 3
a158 3
 ************************************************************************/
sel_id(theDir)
char **theDir;
d160 1
a160 1
  return (*FindValue(theDir,F_UNIVID));
d163 1
a163 1
/************************************************************************
d165 3
a167 3
 ************************************************************************/
sel_proxy(theDir)
char **theDir;
d169 1
a169 1
  return (*FindValue(theDir,F_PROXY));
d172 5
a176 5
/************************************************************************
 * 
 ************************************************************************/
dump_proxy(theDir)
char **theDir;
d178 6
a183 6
  if (*FindValue(theDir,F_ALIAS))
    printf("change alias=%s make proxy=\"%s\"\n",
      FindValue(theDir,F_ALIAS),escapeChars(FindValue(theDir,F_PROXY)));
  else
    printf("change %s make proxy=\"%s\"\n",
      FindValue(theDir,F_NAME),escapeChars(FindValue(theDir,F_PROXY)));
d186 5
a190 5
/***********************************************************************
* units (campus unit listing)
***********************************************************************/
sel_units(theDir)
char **theDir;
d192 1
a192 1
  return (!strcmp(FindValue(theDir,F_TYPE),"unit phone"));
d195 5
a199 5
/***********************************************************************
* timetable
***********************************************************************/
sel_time(theDir)
char **theDir;
d201 1
a201 1
  return (!strncmp(FindValue(theDir,F_TYPE),"timetable",8));
d204 1
a204 1
/************************************************************************
d206 3
a208 3
 ************************************************************************/
sel_people(theDir)
char **theDir;
d210 1
a210 1
  return(!stricmp(FindValue(theDir,F_TYPE),"person phone"));
d213 2
a214 2
sel_pubpeople(theDir)
char **theDir;
d216 1
a216 1
  return(sel_people(theDir) && !*FindValue(theDir,F_SUPPRESS));
d219 2
a220 2
sel_other(theDir)
char **theDir;
d222 1
a222 1
  return(!sel_people(theDir) && !sel_time(theDir));
d225 2
a226 2
sel_rejects(theDir)
char **theDir;
d228 12
a239 7
  char *type;
  if (sel_people(theDir)) return(0);
  if (sel_other(theDir)) return(0);
  type=FindValue(theDir,F_TYPE);
  if (!strncmp(type,"food",4)) return(0);
  if (!strncmp(type,"timetable",8)) return(0);
  return(1);
d242 5
a246 5
/************************************************************************
 * 
 ************************************************************************/
sel_email(theDir)
char **theDir;
d248 1
a248 1
  return (*FindValue(theDir,F_EMAIL) && !*FindValue(theDir,F_SUPPRESS));
d251 5
a255 5
/************************************************************************
 * 
 ************************************************************************/
sel_food(theDir)
char **theDir;
d257 1
a257 1
  return (!strcmp(FindValue(theDir,F_TYPE),"food"));
d260 2
a261 2
dump_food(theDir)
char **theDir;
d263 1
a263 1
  printf("delete %s\n",FindValue(theDir,F_NAME));
d266 5
a270 5
/************************************************************************
 * 
 ************************************************************************/
sel_countpw(theDir)
char **theDir;
d272 1
a272 1
  return (*FindValue(theDir,F_PASSWORD));
d275 5
a279 5
/************************************************************************
 * 
 ************************************************************************/
sel_idpw(theDir)
char **theDir;
d281 1
a281 1
  return(*FindValue(theDir,F_UNIVID) || *FindValue(theDir,F_PASSWORD));
d284 5
a288 5
/************************************************************************
 * 
 ************************************************************************/
sel_maggie(theDir)
char **theDir;
d290 1
a290 1
  return(sel_people(theDir) && *FindValue(theDir,F_EMAIL));
d292 3
a294 2
dump_maggie(theDir)
char **theDir;
d296 41
a336 41
  char scratch[300];
  char *space;
  char *paper = FindValue(theDir,F_PAPER);
  char *id = FindValue(theDir,F_UNIVID);
  
  /*
   * if paper field is "no", we omit the user
   */
  if (!strcmp(paper,"no"))
  {
    printf("%d:%s\t%d:!omit!\n",F_UNIVID,id,F_EMAIL);
    return;
  }
  /*
   * if paper field is specific, we grab the first specified address
   * if it's <50 characters long, we print it.  Otherwise, we fall
   * through and print the alias-based address, since > 50 chars is
   * unprintable
   */
  else if (!strcmp(paper,"specific"))		
  {
    strcpy(scratch,FindValue(theDir,F_EMAIL));
    if (space=strtok(scratch," \n\t,"))
    {
      if (strlen(space)<=50)
      {
        printf("%d:%s\t%d:%s\n",F_UNIVID,id,F_EMAIL,space);
	return;
      }
    }
  }
  /*
   * print the alias-based address
   */
  printf("%d:%s\t%d:%s@@uiuc.edu\n",F_UNIVID,id,
         F_EMAIL, FindValue(theDir,F_ALIAS));
}
  
/************************************************************************
 * 
 ************************************************************************/
d338 2
a339 2
dump_nothing(theDir)
char **theDir;
d341 1
a341 1
  return;
d344 5
a348 5
/************************************************************************
 * 
 ************************************************************************/
dump_aiss(theDir)
char **theDir;
d350 8
a357 8
  char *theId;
  int len;
  char name[51], email[30];
  
  name[sizeof(name)-1] = email[sizeof(email)-1] = '\0';
  strncpy(name,FindValue(theDir,F_NAME),sizeof(name)-1);
  strncpy(email,FindValue(theDir,F_EMAIL),sizeof(email)-1);      
  printf("%-*s %*s\n",sizeof(name)-1,name,sizeof(email)-1,email);
d362 3
a364 3
/************************************************************************
 * 
 ************************************************************************/
d366 2
a367 2
sel_all(theDir)
char **theDir;
d369 1
a369 1
  return(1);
d372 58
a429 2
dump_email(theDir)
char **theDir;
d431 43
a473 105
  printf("change alias=%s make email=\"%s\"\n",FindValue(theDir,F_ALIAS),
    FindValue(theDir,F_EMAIL));
}

/************************************************************************
 * 
 ************************************************************************/
dump_ruchi(theDir)
char **theDir;
{
#define PUT_OUT(num) printf("$#$%s",escapeChars(FindValue(theDir,num)))
  PUT_OUT(F_UNIVID);
  PUT_OUT(F_NAME);
  PUT_OUT(F_ALIAS);
  PUT_OUT(F_EMAIL);
  PUT_OUT(F_PHONE);
  PUT_OUT(F_ADDRESS);
  PUT_OUT(F_DEPARTMENT);
  PUT_OUT(F_TITLE);
  PUT_OUT(19);			/* office location */
  PUT_OUT(20);			/* home address */
  PUT_OUT(23);			/* nickname */
  PUT_OUT(22);			/* office address */
  PUT_OUT(32);			/* office phone */
  PUT_OUT(33);			/* home phone */
  putchar('\n');
}

/************************************************************************
 * 
 ************************************************************************/
dump_randy(theDir)
char **theDir;
{
  printf("%s\t",escapeChars(FindValue(theDir,F_ALIAS)));
  printf("%s\t",escapeChars(FindValue(theDir,F_NAME)));
  printf("%s\t",escapeChars(FindValue(theDir,32)));
  printf("%s\n",escapeChars(FindValue(theDir,F_EMAIL)));
}

/************************************************************************
 * 
 ************************************************************************/
dump_emdir(theDir)
char **theDir;
{
  printf("%-25s %s@@uiuc.edu\n",FindValue(theDir,F_NAME), 
  					FindValue(theDir,F_ALIAS));
}

/************************************************************************
 * 
 ************************************************************************/
dump_size(theDir)
char **theDir;
{
  int size=0;
  char **sp = theDir;
  
  for (sp = theDir; *sp; sp++)
  {
    size += strlen(*sp);
    size++;
  }
  printf("%d\n",size);
}

/************************************************************************
 * 
 ************************************************************************/
dump_all(theDir)
char **theDir;
{
  char *colon;
  printf("%d:%s",F_UNIVID,escapeChars(FindValue(theDir,F_UNIVID)));
  for (; *theDir; theDir++)
    if (atoi(*theDir)!=F_UNIVID && (colon=index(*theDir,':')) && colon[1])
    {
      putchar('\t');
      fputs(escapeChars(*theDir),stdout);
    }
  putchar('\n');
}

/************************************************************************
 * 
 ************************************************************************/
dump_4merge(theDir)
char **theDir;
{
  char *colon;
  int f;
  char *fdMerge;
  int no_up = *FindValue(theDir,31);	/* no_update */
  FieldDesc *theFD;
   
  printf("%d:%s",F_UNIVID,escapeChars(FindValue(theDir,F_UNIVID)));
  for (; *theDir; theDir++)
  {
    f = atoi(*theDir);
    if (f!=F_UNIVID && (colon=index(*theDir,':')) && colon[1])
    {
      if (theFD=FindFDI(f))
      {
	if (*theFD->fdMerge)
d475 13
a487 2
	  putchar('\t');
	  fputs(escapeChars(*theDir),stdout);
d489 1
a489 6
      }
      else
        fprintf(stderr,"%s unknown field %d\n",FindValue(theDir,F_NAME),f);
    }
  }
  putchar('\n');
d492 1
a492 1
/***********************************************************************
d494 2
a495 2
 ***********************************************************************/
char *
d497 1
a497 1
char *s;
d499 45
a543 55
  register char *cp;
  static char value[8192];
  register char *vp;

  vp = value;
  for (cp=s; *cp; cp++)
    if (*cp=='\t')
    {
      *vp++ = '\\';
      *vp++ = 't';
    }
    else if (*cp=='\n')
    {
      *vp++ = '\\';
      *vp++ = 'n';
    }
    else if (*cp=='\\')
    {
      *vp++ = '\\';
      *vp++ = '\\';
    }
    else
      *vp++ = *cp;
  *vp = '\0';
  return(value);
}

/***********************************************************************
* Free a dir structure (modified for mdump)
***********************************************************************/
MdumpFreeDir(Dir *dir)
{
  char  **p;

  if (*dir)
  {
    for (p = *dir; *p; p++)
      free(*p);
    /*free(*dir);
    *dir = 0;*/
  }
}

sel_files(theDir)
char **theDir;
{
  return(*FindValue(theDir,104));
}

dump_files(theDir)
char **theDir;
{
  char *token;
  for (token=strtok(FindValue(theDir,104)," \n\t,");token;token=strtok(NULL," \t\n,"))
    puts(token);
d546 2
a547 2
dump_date(theDir)
char **theDir;
d549 4
a552 1
  printf("%ld %s\n",CurrentDate(),FindValue(theDir,F_ALIAS));
d555 5
@


1.1
log
@Initial revision
@
text
@d24 1
d83 8
a90 3
  for (argc--,argv++;argc && **argv=='-';argc--,argv++)
    if (strcmp(*argv,"-p")) break;
    else Progress = 1;
d93 1
a93 1
    fprintf(stderr,"Usage: mdump [-p] <dump-type> [<database>]\n");
d136 2
a137 1
  fprintf(stderr, "%d of %d selected, %d errors.\n", selected, count,
@
