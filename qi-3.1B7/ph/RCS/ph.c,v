head	7.6;
access;
symbols;
locks; strict;
comment	@ * @;


7.6
date	95.06.27.17.36.18;	author p-pomes;	state Exp;
branches;
next	7.5;

7.5
date	95.06.23.12.02.40;	author p-pomes;	state Exp;
branches;
next	7.4;

7.4
date	95.06.23.04.03.48;	author p-pomes;	state Exp;
branches;
next	7.3;

7.3
date	95.06.23.02.52.21;	author p-pomes;	state Exp;
branches;
next	7.2;

7.2
date	95.06.10.03.51.09;	author p-pomes;	state Exp;
branches;
next	7.1;

7.1
date	95.06.09.03.27.04;	author p-pomes;	state Exp;
branches;
next	6.23;

6.23
date	95.06.07.19.14.09;	author p-pomes;	state Exp;
branches;
next	6.22;

6.22
date	95.03.03.01.06.09;	author p-pomes;	state Exp;
branches;
next	6.21;

6.21
date	95.03.01.21.34.23;	author p-pomes;	state Exp;
branches;
next	6.20;

6.20
date	94.11.18.16.11.30;	author p-pomes;	state Exp;
branches;
next	6.19;

6.19
date	94.11.11.21.34.38;	author p-pomes;	state Exp;
branches;
next	6.18;

6.18
date	94.09.09.20.15.40;	author p-pomes;	state Exp;
branches;
next	6.17;

6.17
date	94.03.12.04.31.21;	author paul;	state Exp;
branches;
next	6.16;

6.16
date	94.03.12.00.13.50;	author paul;	state Exp;
branches;
next	6.15;

6.15
date	93.12.21.21.43.39;	author paul;	state Exp;
branches;
next	6.14;

6.14
date	93.12.20.23.37.56;	author paul;	state Exp;
branches;
next	6.13;

6.13
date	93.12.20.23.30.32;	author paul;	state Exp;
branches;
next	6.12;

6.12
date	93.12.20.22.52.09;	author paul;	state Exp;
branches;
next	6.11;

6.11
date	93.12.16.23.03.42;	author paul;	state Exp;
branches;
next	6.10;

6.10
date	93.11.24.22.30.54;	author paul;	state Exp;
branches;
next	6.9;

6.9
date	93.11.24.18.06.49;	author paul;	state Exp;
branches;
next	6.8;

6.8
date	93.11.19.20.11.17;	author paul;	state Exp;
branches;
next	6.7;

6.7
date	93.10.06.20.26.52;	author paul;	state Exp;
branches;
next	6.6;

6.6
date	93.07.21.22.09.42;	author paul;	state Exp;
branches;
next	6.5;

6.5
date	93.06.22.13.41.41;	author paul;	state Exp;
branches;
next	6.4;

6.4
date	93.06.16.14.17.21;	author paul;	state Exp;
branches;
next	6.3;

6.3
date	93.05.06.04.05.27;	author paul;	state Exp;
branches;
next	6.2;

6.2
date	93.04.06.16.57.07;	author paul;	state Exp;
branches;
next	6.1;

6.1
date	93.04.03.19.36.46;	author paul;	state Exp;
branches;
next	5.12;

5.12
date	93.04.03.19.35.45;	author paul;	state Exp;
branches;
next	5.11;

5.11
date	93.02.23.04.26.42;	author paul;	state Exp;
branches;
next	5.10;

5.10
date	92.12.18.15.32.38;	author paul;	state Exp;
branches;
next	5.9;

5.9
date	92.12.08.20.19.39;	author paul;	state Exp;
branches;
next	5.8;

5.8
date	92.11.15.19.43.16;	author paul;	state Exp;
branches;
next	5.7;

5.7
date	92.08.17.13.35.39;	author paul;	state Exp;
branches;
next	5.6;

5.6
date	92.08.01.13.18.11;	author paul;	state Exp;
branches;
next	5.5;

5.5
date	92.07.27.20.37.10;	author paul;	state Exp;
branches;
next	5.4;

5.4
date	92.07.27.19.41.02;	author paul;	state Exp;
branches;
next	5.3;

5.3
date	92.07.24.16.45.10;	author paul;	state Exp;
branches;
next	5.2;

5.2
date	92.05.14.11.55.27;	author dorner;	state Exp;
branches;
next	5.0;

5.0
date	92.01.31.16.08.48;	author dorner;	state Exp;
branches;
next	4.14;

4.14
date	92.01.31.10.57.57;	author dorner;	state Exp;
branches;
next	4.13;

4.13
date	91.08.08.13.24.44;	author dorner;	state Exp;
branches;
next	4.12;

4.12
date	91.04.23.14.34.36;	author dorner;	state Exp;
branches;
next	4.11;

4.11
date	91.04.23.14.12.07;	author dorner;	state Exp;
branches;
next	4.10;

4.10
date	91.02.06.07.24.53;	author dorner;	state Exp;
branches;
next	4.9;

4.9
date	91.02.05.10.13.44;	author dorner;	state Exp;
branches;
next	4.8;

4.8
date	90.10.30.11.43.59;	author dorner;	state Exp;
branches;
next	4.7;

4.7
date	90.10.29.14.00.33;	author dorner;	state Exp;
branches;
next	4.6;

4.6
date	90.10.24.10.51.25;	author dorner;	state Exp;
branches;
next	4.5;

4.5
date	90.05.18.10.42.37;	author dorner;	state Exp;
branches;
next	4.4;

4.4
date	90.03.29.09.52.26;	author dorner;	state Exp;
branches;
next	4.3;

4.3
date	90.01.23.08.49.37;	author dorner;	state Exp;
branches;
next	4.2;

4.2
date	90.01.18.10.45.47;	author dorner;	state Exp;
branches;
next	4.1;

4.1
date	90.01.17.16.18.25;	author dorner;	state Exp;
branches;
next	4.0;

4.0
date	89.10.18.07.51.32;	author dorner;	state Exp;
branches;
next	3.15;

3.15
date	89.07.25.14.28.49;	author dorner;	state Exp;
branches;
next	3.14;

3.14
date	89.07.25.07.52.43;	author dorner;	state Exp;
branches;
next	3.13;

3.13
date	89.07.20.15.08.00;	author dorner;	state Exp;
branches;
next	3.12;

3.12
date	89.07.20.10.39.28;	author dorner;	state Exp;
branches;
next	3.11;

3.11
date	89.07.19.09.52.38;	author dorner;	state Exp;
branches;
next	3.10;

3.10
date	89.05.08.22.56.28;	author dorner;	state Exp;
branches;
next	3.9;

3.9
date	89.05.08.22.43.56;	author dorner;	state Exp;
branches;
next	3.8;

3.8
date	89.04.13.19.26.39;	author dorner;	state Exp;
branches;
next	3.7;

3.7
date	89.04.10.16.53.57;	author dorner;	state Exp;
branches;
next	3.6;

3.6
date	89.03.21.14.33.09;	author dorner;	state Exp;
branches;
next	3.5;

3.5
date	89.02.07.10.55.44;	author dorner;	state Exp;
branches;
next	3.4;

3.4
date	88.12.08.13.08.44;	author dorner;	state Exp;
branches;
next	3.3;

3.3
date	88.12.02.14.46.08;	author dorner;	state Exp;
branches;
next	3.2;

3.2
date	88.11.15.13.35.50;	author dorner;	state Exp;
branches;
next	3.1;

3.1
date	88.10.06.11.21.46;	author dorner;	state Exp;
branches;
next	3.0;

3.0
date	88.09.07.12.30.26;	author dorner;	state Exp;
branches;
next	2.21;

2.21
date	88.07.28.16.38.14;	author dorner;	state Exp;
branches;
next	2.20;

2.20
date	88.07.27.13.55.53;	author dorner;	state Exp;
branches;
next	2.19;

2.19
date	88.07.25.13.59.48;	author dorner;	state Exp;
branches;
next	2.18;

2.18
date	88.07.20.11.40.50;	author dorner;	state Exp;
branches;
next	2.17;

2.17
date	88.07.18.15.31.09;	author dorner;	state Exp;
branches;
next	2.16;

2.16
date	88.07.06.20.48.36;	author dorner;	state Exp;
branches;
next	2.15;

2.15
date	88.04.29.10.07.20;	author dorner;	state Exp;
branches;
next	2.14;

2.14
date	88.04.29.09.58.54;	author dorner;	state Exp;
branches;
next	2.13;

2.13
date	88.04.28.16.41.05;	author dorner;	state Exp;
branches;
next	2.12;

2.12
date	88.03.10.12.49.11;	author dorner;	state Exp;
branches;
next	2.11;

2.11
date	88.03.10.12.23.34;	author dorner;	state Exp;
branches;
next	2.10;

2.10
date	88.03.09.09.59.32;	author dorner;	state Exp;
branches;
next	2.9;

2.9
date	88.03.01.10.29.48;	author dorner;	state Exp;
branches;
next	2.8;

2.8
date	88.03.01.10.20.58;	author dorner;	state Exp;
branches;
next	2.7;

2.7
date	88.03.01.10.09.07;	author dorner;	state Exp;
branches;
next	2.6;

2.6
date	88.03.01.10.02.35;	author dorner;	state Exp;
branches;
next	2.5;

2.5
date	88.02.24.17.01.56;	author dorner;	state Exp;
branches;
next	2.4;

2.4
date	88.02.17.14.06.48;	author dorner;	state Exp;
branches;
next	2.3;

2.3
date	88.02.17.08.33.01;	author dorner;	state Exp;
branches;
next	2.2;

2.2
date	88.02.15.15.13.53;	author dorner;	state Exp;
branches;
next	2.1;

2.1
date	88.02.15.14.31.58;	author dorner;	state Exp;
branches;
next	2.0;

2.0
date	88.02.15.13.57.23;	author dorner;	state Exp;
branches;
next	1.2;

1.2
date	88.02.10.13.20.25;	author dorner;	state Exp;
branches;
next	;


desc
@This is a modified version of the original ph.
@


7.6
log
@OS/2 changes from Don Meyer <dlmeyer@@uiuc.edu>.
@
text
@/*
 * Copyright (c) 1985 Corporation for Research and Educational Networking
 * Copyright (c) 1988 University of Illinois Board of Trustees, Steven
 *		Dorner, and Paul Pomes
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Corporation for
 *	Research and Educational Networking (CREN), the University of
 *	Illinois at Urbana, and their contributors.
 * 4. Neither the name of CREN, the University nor the names of their
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE TRUSTEES AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE TRUSTEES OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
static char rcsid[] = "@@(#)$Id: ph.c,v 7.5 1995/06/23 12:02:40 p-pomes Exp p-pomes $";
static char rcsrev[] = "100:Ph client $Revision: 7.5 $";
#endif

#ifdef OSF1
# define INT32 int
#else /* !OSF1 */
# define INT32 long
#endif /* OSF1 */

/*
 * This is a client program for CSO's nameserver.  It attempts to contact
 * the nameserver running on ns.uiuc.edu, and query it about entries.
 * It's *HIGHLY* recommended that the DNS be used to resolve ns.uiuc.edu
 * to a specific host.  The following entry in /etc/services will help:
 *
 * /etc/services:
 * csnet-ns		105/tcp     ns		# CCSO nameserver
 */
#ifdef VMS
/*
            P H   for   V A X / V M S
  
  
  Ported to VAX/VMS Version 4.4 using VAXC 2.2 and Wollongong WIN/TCP 3.1
  by Mark Sandrock, UIUC School of Chemical Sciences Computing Services.
  
  VMS 4.4 implementation notes:
  
  1) VAXCRTL does not supply the following routines used by PH:
  
    a) fork: SYS$CREPRC or LIB$SPAWN should be used instead.
    b) execlp: VAXCRTL does provide execl, but it is too limited.
    c) popen/pclose: VAXCRTL does provide "pipe" instead.
    d) index/rindex: VAXCRTL "strchr/strrchr" functions are equivalent.
    e) getpass: implemented in this file.
    f) unlink: VAXCRTL does provide "delete" function.
  
  2) VAX/VMS does not provide the following utilities used by PH:
  
    a) /usr/ucb/more: TYPE/PAGE should be used instead.
    b) /usr/ucb/vi: (callable) EDT should be used instead.
  
  3) The VAXCRTL "getenv" function does not recognize the following
     environment names. SYS$TRNLNM could be used instead, if need be:
  
    a) PAGER: specifies "pager" other than the default (TYPE/PAGE).
    b) EDITOR: specifies editor other than the default (EDT).
  
  4) The SOCKET INTERFACE implemented by Wollongong WIN/TCP 3.1 returns
     a channel number rather than a standard file descriptor, and thus
     is not compatible with the UNIX-style i/o functions such as fdopen,
     read and write. Instead WIN/TCP provides special versions of read/
     write called netread/netwrite for network i/o.
  
  5) The VMS VAXC include files are used wherever possible, with several
     exceptions as noted in the WIN/TCP Programmer's Guide. The following
     include files do not exist under VMS VAXC 2.2 nor under WIN/TCP 3.1,
     and were simply copied over from uxc (4.3 bsd):
  
    a) #include <sgtty.h>
    b) #include <syslog.h>
  
  Change log:
  
  05-May-1988   12:09   MTS   Initial port of ph.c,v 2.15 to vms_ph.c.
                Initial port of cryptit.c to vms_cryptit.c.
  
***************************************************************************/

/*#module vms_ph "2.15"*/
static char *rcsid = "VAX/VMS: ph.c,v 2.15 88/05/05 15:06:50 dorner Locked $";

#include stdio
#include signal
#include <types.h>
#include <socket.h>
#include file
#include <in.h>
#include <netdb.h>
#include ctype
#include <strings.h>
#include descrip		/* VMS descriptor structures defs */
#include iodef			/* VMS I/O function definitions */
#include ssdef			/* VMS System Status definitions */
#include ttdef			/* VMS terminal characteristics */
#include "termdefs.h"		/* VMS defs for setterm() function */

#else /* !VMS */

#include <stdio.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <netdb.h>
#include <ctype.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <pwd.h>
#include <sys/param.h>
#include <errno.h>
#endif /* VMS */

#ifdef KRB4_AUTH
#include <sys/param.h>
#include <kerberosIV/des.h>
#include <kerberosIV/krb.h>
#endif /* KRB4_AUTH */

#ifdef OS2
#include <process.h>
#endif   /* OS2 */

extern int QiAuthDebug;

#include <qiapi.h>

/*
 * vital defines
 */
#define MAXSTR		2048	/* max string length */
#define MAXVAL		14000	/* max value length */
#define DELIM		" \t\n"	/* command delimiters */
#define MAXARGS		20	/* maximum # of arguments in PH environ var. */
#define CLIENT		"ph"
#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN  64
#endif
#ifndef PAGER
# define PAGER		"more"
#endif

#ifdef VMS
char *strchr();			/* VMS equivalent of "index" */
char *strrchr();		/* VMS equivalent of "rindex" */
#endif /* VMS */

#define GetQValue(x)	(strchr(strchr(x,':')+1,':')+1)

/*
 * declarations for the functions in this file
 */
char *GetValue __P((char *, char *));
char *issub __P((char *, char *));
int  ContactQI();
int  DoId();
int  PrintResponse __P((int));

#ifdef VMS
int  GetGood __P((char *, int, int));
#else /* !VMS */
int  GetGood __P((char *, int, FILE *));
#endif /* VMS */

void EnvOptions __P((char *));
void ComplainAboutService();
void ComplainAboutHost __P((char *));
void Interactive();
int  DoCommand __P((char *));
int  DoOtherWPage __P((char *));
int  DoOther __P((char *));

#ifdef MACC
int  DoFields __P((char *));
#endif

int  DoHelp __P((char *));
int  DoQuery __P((char *));
int  DoLogin __P((char *));
int  DoQuit __P((char *));
int  DoEdit __P((char *));
int  DoMake __P((char *));
int  DoRegister __P((char *));
int  EditValue __P((char *));
int  UpdateValue __P((char *, char *, char *));
int  DoFields __P((char *));
int  DoMe __P((char *));
int  DoLogout __P((char *));
int  DoPassword __P((char *));
void VetPassword __P((char *));
int  AllDigits __P((char *));
int  PrintQResponse __P((int, int));
void DoAutoLogin();
void SkipMacdef __P((FILE *));
void EmailLine __P((char *, char *));
void NotRegisteredLine __P((char *, FILE *));
FILE *OpenPager __P((int));
int  DoSwitch __P((char *));

#ifdef __STDC__
# include <unistd.h>
# include <stdlib.h>
# include <string.h>
#else /* !__STDC__ */
# include <strings.h>
char *malloc();
char *getenv();
char *strtok();
#endif /* __STDC__ */

char *getpass __P((const char *));
char *mktemp __P((char *));

#ifndef MAILDOMAIN
# define MAILDOMAIN	NULL
#endif /* !MAILDOMAIN */

/*
 * These are external for convenience' sake
 */
#ifdef MACC_ECHO
int  maccecho = 0;
#endif

#ifdef VMS
int  ToQI;			/* write to this to tell the nameserver stuff */
int  FromQI;			/* read nameserver responses from here */
char ToQIBuf[MAXSTR];
int  ToQILen;
#define qprintf		\	/*this is fairly sneaky... */
{
	\
	   char    *ToQI = ToQIBuf;

	\
	   sprintf
#define qflush(foobar)		\	/*compound sneakiness */
	   ToQILen = strlen(ToQIBuf);
	\
} \

netwrite(ToQI, ToQIBuf, ToQILen)
#else
FILE *ToQI;			/* write to this to tell the nameserver stuff */
FILE *FromQI;			/* read nameserver responses from here */
#define qprintf fprintf
#define qflush fflush
#endif

char MyAlias[MAXSTR];		/* currently logged-in alias */
char *Me;			/* the name of this program */
char *MyPassword = NULL;	/* password read from .netrc (if any) */
char *MailDomain = MAILDOMAIN;	/* mail domain */
int  LocalPort = 0;		/* local port in use */
int  Debug = 0;			/* print debug info if set */
unsigned INT32 Dot2Addr();

/*
 * switches
 */
int  NoNetrc = 0;		/*-n don't read .netrc */
char *UseHost = 0;		/*-s use server on what machine */
int  UsePort = 0;		/*-p use port # */
int  NoReformat = 0;		/*-i don't reformat email fields */
int  NoPager = 0;		/*-m don't use pager */
int  NoBeautify = 0;		/*-b don't beautify output */
int  NoLabels = 0;		/*-l don't use labels */
int  Confirm = 0;		/*-c confirm Edit */
int  Quiet = 0;			/*-q act like a pipe, no extraneous output */
char *DefType = 0;		/*-t prepend this type to queries */
char *ReturnFields = NULL;	/*-f give list of fields */
int  JustHelp = 0;		/*-h give me help */

/*
 * and the fun begins...
 */
int
main(argc, argv)
    int  argc;
    char **argv;
{
    int  code = LR_ERROR;
    int  optionsCount;
    char buffer[4096];

#ifdef MACC_ECHO
    int  margc = 0;
#endif
#ifdef VMS
    char *temps;		/* temp strings */
#endif
    /* figure out what this program is called */
#ifdef VMS
    Me = " ph";
#else
    Me = (char *) strrchr(*argv, '/');
#endif
    if (Me)
	Me++;
    else
	Me = *argv;
    EnvOptions(CLIENT);
#ifndef OS2
    if (strcmp(CLIENT, Me)) {
	sprintf(buffer, "-t %s", Me);
	(void) OptionLine(buffer);
	EnvOptions(Me);
    }
#endif /* OS2 */
    optionsCount = ProcessOptions(--argc, ++argv);
    argc -= optionsCount;
    argv += optionsCount;

    if (!ContactQI()) {
	fputs("Sorry--phone book not available now.\n", stderr);
#ifdef VMS
	exit(SS$_CONNECFAIL);
#else
	exit(1);
#endif
    }
    /* identify ourselves */
    if ((code = DoId()) >= 400)
	exit(code / 100);
    if (!MailDomain && (code = GetMailDomain()) >= 400)
	exit(code / 100);
    if (argc == 0 && !JustHelp)
	Interactive();		/* no arguments--interactive mode */
    else {
	/* make a query out of the arguments */
#ifdef VMS
	temps = JustHelp ? "help ph " : "query ";
	netwrite(ToQI, temps, strlen(temps));
	for (; argc; argc--, argv++) {
	    netwrite(ToQI, *argv, strlen(*argv));
	    if (argc > 1)
		netwrite(ToQI, " ", 1);
	}
	temps = "\nquit\n";
	netwrite(ToQI, temps, strlen(temps));
#else
	strcpy(buffer, JustHelp ? "help " : "query ");
	for (; argc; argc--, argv++) {
	    strcat(buffer, *argv);
	    if (argc > 1)
		strcat(buffer, " ");
	}
	strcat(buffer, "\n");
	code = DoCommand(buffer);
	if (Debug)
	    fprintf(stderr, "sent=quit\n");
	qprintf(ToQI, "quit\n");
	qflush(ToQI);
#endif
    }
#ifdef VMS
    exit(SS$_NORMAL);
#else
    exit(code > 299 ? code / 100 : 0);
#endif
}

/*
 * contact the central nameserver
 */
int
ContactQI()
{
    int  sock;			/* our socket */
    static struct sockaddr_in QI;	/* the address of the nameserver */
    struct servent *sp;		/* nameserver service entry */
    static struct hostent *hp;	/* host entry for nameserver */
    char host[80];
    char *baseHost;
    int  backupNum = 0;
    int  mightBackup;
    int  result = 0;
    int  err;

    QI.sin_family = AF_INET;

    /* give up privs if using anything other than default port and host */
    if (UsePort || (UseHost && *UseHost)) {
	if (Debug)
	    fprintf(stderr, "giving up privs (UsePort || UseHost)\n");
	(void) setgid(getgid());
	(void) setuid(getuid());
    }

    /* find the proper port */
    if (UsePort)
	QI.sin_port = htons(UsePort);
    else if (sp = getservbyname(NSSERVICE, "tcp")) {
	QI.sin_port = sp -> s_port;
    }
    else {
	ComplainAboutService();
	QI.sin_port = htons(atoi(FALLBACKPORT));
    }

    /* find the proper host */
    baseHost = UseHost ? UseHost : HOST;
    if (mightBackup = (*baseHost == '.'))
	sprintf(host, "%s%s", NSSERVICE, baseHost);
    else
	strcpy(host, baseHost);

    if (!geteuid())
	LocalPort = (IPPORT_RESERVED - 1);
    for (;;) {
	/* create the socket */
#ifdef OS2
	sock = socket(PF_INET, SOCK_STREAM, 0);
#else
	sock = LocalPort ? rresvport(&LocalPort) : socket(PF_INET, SOCK_STREAM, 0);
#endif /* OS2 */
	if (sock < 0) {
	    perror("socket");
	    goto done;
	}
	QI.sin_family = AF_INET;
	if (hp = gethostbyname(host)) {
#ifdef _CRAY
	    memmove((char *) &QI.sin_addr, hp -> h_addr, 4);
#else
	    memmove((char *) &QI.sin_addr.s_addr, hp -> h_addr, 4);
#endif
	}
	else if (!backupNum) {
	    ComplainAboutHost(host);
	    QI.sin_addr.s_addr = Dot2Addr(FALLBACKADDR);
	}
	else {
	    fprintf(stderr, "No more backups to try.\n");
	    goto done;
	}

	/* connect to the nameserver */
	if (connect(sock, (struct sockaddr *) & QI, sizeof(QI)) < 0) {
	    if (errno == EADDRINUSE) {
		if (LocalPort)
		    LocalPort = LocalPort - 1;
		continue;
	    }
	    perror(host);
	    if (mightBackup) {
		backupNum++;
		sprintf(host, "%s%d%s", NSSERVICE, backupNum, baseHost);
	    }
	    else
		goto done;
	}
	else
	    break;
    }

    if (backupNum)
	fprintf(stderr, "WARNING--backup host %s; information may be out of date.\n", host);
    /* open path to nameserver */
#ifdef VMS
    ToQI = sock;		/* copy socket channel for netwrite calls */
    FromQI = sock;		/* ditto for netread calls */
#else
    if ((ToQI = fdopen(sock, "w")) == NULL) {
	perror("to qi");
	goto done;
    }
    /* open path from nameserver */
    if ((FromQI = fdopen(sock, "r")) == NULL) {
	perror("from qi");
	goto done;
    }
#endif
    if (UseHost)
	free(UseHost);
    UseHost = strdup(hp ? hp -> h_name : inet_ntoa(QI.sin_addr));
    UsePort = ntohs(QI.sin_port);
    result = 1;

done:
    setgid(getgid());
    setuid(getuid());
    return (result);
}

/*
 * identify ourselves to the nameserver
 */
int
DoId()
{
    int  code;
    char *cpnt = (char *) getlogin();
    struct passwd *pw;

    /* Who is doing this? */
    if (cpnt == NULL || (pw = getpwnam(cpnt)) == NULL) {
	if ((pw = getpwuid(getuid())) == NULL) {
	    perror("getpwuid(getuid())");
	    exit(1);
	}
    }
    if (Debug)
	fprintf(stderr, "sent=id %d\n", pw -> pw_uid);
    qprintf(ToQI, "id %d\n", pw -> pw_uid);
    qflush(ToQI);
    code = PrintResponse(-1);
    return (code);
}

/*
 * get the mail domain from a foreign server
 */
int
GetMailDomain()
{
    char scratch[MAXSTR];
    char *lastc, *s2lastc;
    short code = 0;

    if (Debug)
	fprintf(stderr, "sent=siteinfo\n");
    qprintf(ToQI, "siteinfo\n");
    qflush(ToQI);
    while (GetGood(scratch, MAXSTR, FromQI)) {	/* read it */
	code = atoi(scratch);
	if (code == -200) {
	    if ((lastc = (char *) strrchr(scratch, ':')) && lastc > scratch) {
		*lastc++ = 0;
		if (s2lastc = (char *) strrchr(scratch, ':')) {
		    s2lastc++;
		    if (!strcmp("maildomain", s2lastc)) {
			lastc[strlen(lastc) - 1] = 0;
			MailDomain = strdup(lastc);
		    }
		}
	    }
	}
	else if (code >= LR_OK)
	    break;
    }
    return (code ? 200 : 500);	/* only fail if the cnxn broke */
}

/*
 * print what the QI (Query Interpreter; nameserver) says
 * read replies from nameserver until code indicates a completed
 * command.  This routine does not beautify the responses in any way.
 * if pager is 1, the pager will be used.
 * if pager is 0, no pager will be used.
 * if pager is -1, the response will not be printed at all.
 */
int
PrintResponse(pager)
    int  pager;			/* use the pager? */
{
    char scratch[MAXSTR];	/* some space */
    int  code = LR_ERROR;	/* the reply code */
    FILE *out;

    out = OpenPager(pager);
    while (GetGood(scratch, MAXSTR, FromQI)) {	/* read it */
	code = atoi(scratch);
	if (pager != -1 || code >= 400)
	    fputs(scratch, out);/* echo it */
	if (code >= LR_OK)
	    break;
    }
#ifdef VMS
#else
    if (out != stdout)
	pclose(out);
#endif

    return (code);		/* all done.  return final code */
}


/*
 * complain that there isn't an entry for ns in /etc/services
 */
void
ComplainAboutService()
{
    fprintf(stderr, "Warning--there is no entry for ``%s'' in /etc/services;\n",
	    NSSERVICE);
    fputs("please have your systems administrator add one.\n", stderr);
    fprintf(stderr, "I'm going to use port %s in the meantime.\n", FALLBACKPORT);
}

/*
 * complain that there isn't an entry for HOST in /etc/hosts
 */
void
ComplainAboutHost(name)
    char *name;
{
    fprintf(stderr, "Warning--unable to find address for ``%s''.\n",
	    name);
    fprintf(stderr, "I'm going to use address %s in the meantime.\n",
	    FALLBACKADDR);
}

/*
 * the interactive portion of the client
 */
typedef struct command CMD;

struct command {
    char *cName;		/* the name of the command */
    int  cLog;			/* must be logged in to use? */
    int  (*cFunc) ();		/* function to call for command */
};

CMD  CommandTable[] =
{
 "help", 0, DoHelp,
 "?", 0, DoHelp,
 "query", 0, DoQuery,
#ifndef MACC
 CLIENT, 0, DoQuery,
 "me", 1, DoMe,
 "edit", 1, DoEdit,
 "make", 1, DoMake,
 "register", 1, DoRegister,
 "password", 1, DoPassword,
 "passwd", 1, DoPassword,
 "login", 0, DoLogin,
 "logout", 1, DoLogout,
#endif
#ifdef MACC
 "fields", 0, DoFields,
#else
 "fields", 0, DoOtherWPage,
 "switch", 0, DoSwitch,
#endif
#ifndef MACC
 "add", 1, DoOther,
 "delete", 1, DoOther,
 "set", 0, DoOther,
#endif
 "quit", 0, DoQuit,
 "bye", 0, DoQuit,
 "exit", 0, DoQuit,
 0, 0, 0
};

/*
 * the main loop
 */
int  LastCode = 0;		/* the response from the previous command */

void
Interactive()
{
    char in_line[MAXSTR];	/* space for an input line */
    char *spot;

    *MyAlias = 0;		/* nobody logged in yet... */
    if (!Quiet)
	puts(rcsrev);

    /* print database status */
    if (!Quiet)
	LastCode = DoOther("status\n");

    /* autologin if possible */
#ifndef MACC
    if (!NoNetrc)
	DoAutoLogin();
#endif

    if (!Quiet)
	puts("");

    while (1) {
	(void) signal(SIGPIPE, SIG_IGN);
	if (!Quiet) {
#ifdef MACC_ECHO
	    if (!maccecho)
		printf("%s> ", Me);
#else
	    printf("%s> ", Me);
#endif
	    (void) fflush(stdout);	/* prompt */
	}
	spot = in_line;
	do {
	    if (!fgets(spot, MAXSTR - (spot - in_line), stdin))
		return;		/* read line */
	    spot = in_line + strlen(in_line) - 2;
	    if (*spot == '\\')
		*spot++ = ' ';
	    else
		spot = in_line - 1;
	}
	while (spot >= in_line);
#ifdef MACC_ECHO
	if (maccecho && !Quiet)
	    printf("%s> %s", Me, in_line);
#endif

	if (!(LastCode = DoCommand(in_line)))	/* is it a command we know? */
	    LastCode = DoOther(in_line);	/* unrecognized command */
    }
}

/*
 * look at input line, and if we have a specific command for it, do it
 */
int
DoCommand(in_line)
    char *in_line;		/* the input line */
{
    char scratch[MAXSTR];	/* some space */
    char *token;		/* a token from the command line */
    CMD *cmd;			/* the command name */
    CMD *doMe;
    int  len;

    /* make a safe copy of the input line, so we can play with it */
    strcpy(scratch, in_line);

    if (!(token = strtok(scratch, DELIM)))
	return (LR_ERROR);	/* blank line */

    /* search command table linearly */
    doMe = NULL;
    len = strlen(token);
    for (cmd = CommandTable; cmd -> cName; cmd++)
	if (!strncmp(cmd -> cName, token, len)) {
	    if (doMe) {		/* we found 2 commands that match (bad) */
		printf("%s is ambiguous.\n", token);
		return (LR_ERROR);
	    }
	    doMe = cmd;		/* we found a command that matches */
	}
    if (doMe) {			/* found one and only one command */
	/* expand command name */
	token = strtok((char *) 0, "\n");
	sprintf(in_line, "%s %s\n", doMe -> cName, token ? token : "");

	/* execute command */
	if (doMe -> cLog && !*MyAlias)
	    printf("You must be logged in to use %s.\n", doMe -> cName);
	else
	    return ((*doMe -> cFunc) (in_line));
	return (LR_ERROR);
    }
    return (0);			/* didn't find it */
}

/*
 * execute a command for which we do nothing special; use the pager
 */
int
DoOtherWPage(in_line)
    char *in_line;
{
    if (Debug)
	fprintf(stderr, "sent=%s", in_line);	/* send command */
    qprintf(ToQI, "%s", in_line);	/* send command */
    qflush(ToQI);
    return (PrintResponse(1));	/* get response */
}

/*
 * execute a command for which we do nothing special; don't use pager
 */
int
DoOther(in_line)
    char *in_line;
{
    if (Debug)
	fprintf(stderr, "sent=%s", in_line);	/* send command */
    qprintf(ToQI, "%s", in_line);	/* send command */
    qflush(ToQI);
    return (PrintResponse(0));	/* get response */
}

#ifdef MACC
int
DoFields(in_line)
    char *in_line;
{
    printf("Field Name     Description\n");
    printf("------------------------------\n");
    printf("name          Person Name\n");
    printf("email         Electronic Mail Address if exists\n");
    printf("phone         Telephone Number One\n");
    printf("phone2        Telephone Number Two\n");
    printf("address       Street Address of the Building\n");
    printf("building      Building Name\n");
    printf("department    Department Number One of Person\n");
    printf("department2   Department number Two of Person\n");
    printf("appointment   Appointment Classification Code Number One \n");
    printf("appointment2  Appointment Classification Code Number Two\n");
    printf("title         Title One\n");
    printf("title2        Title Two\n");
    printf("alias         Unique Name built from First Letter of First Name, Last\n");
    printf("              Name and a Number\n\n");
    return (LR_OK);
}

#endif

/*
 * execute a query request
 */
int
DoQuery(in_line)
    char *in_line;
{
    char scratch[4096];
    char *args;
    int  noReformatWas = NoReformat;
    int  code;

    if (ReturnFields && !issub(in_line, "return")) {
	args = in_line + strlen(in_line) - 1;
	sprintf(args, " return %s\n", ReturnFields);
	for (; *args; args++)
	    if (*args == ',')
		*args = ' ';
    }
    if (!NoBeautify && !NoReformat) {
	char *ret = issub(in_line, "return");

	if (ret)
	    NoReformat = !issub(ret, "email");
    }
    if (!DefType || issub(in_line, "type=")) {
	if (Debug)
	    fprintf(stderr, "sent=%s", in_line);	/* send command */
	qprintf(ToQI, "%s", in_line);	/* send command */
    }
    else {
	strcpy(scratch, in_line);
	args = strtok(scratch, " \t");
	args = strtok(0, "\n");
	if (args) {
	    if (Debug)
		fprintf(stderr, "sent=query type=\"%s\" %s\n", DefType, args);	/* send command */
	    qprintf(ToQI, "query type=\"%s\" %s\n", DefType, args);	/* send command */
	}
	else {
	    if (Debug)
		fprintf(stderr, "sent=%s", in_line);
	    qprintf(ToQI, "%s", in_line);
	}
    }

    qflush(ToQI);
    code = (NoBeautify ? PrintResponse(1) : PrintQResponse(1, 0));
    NoReformat = noReformatWas;
    return (code);
}

/*
 * execute a login request, using qiapi.
 */
int
DoLogin(in_line)
    char *in_line;
{
    char scratch[4096];
    char *uname = NULL, *upass = NULL, *r;
    int  opts;

    if (QiAuthDebug)
	fprintf(stderr, "DoLogin(%s)\n", in_line);
    strcpy(scratch, in_line);
    (void) strtok(scratch, DELIM);	/* the login part of the command */
    uname = strtok(NULL, DELIM);/* the username, if any  */
    if (uname)
	upass = strtok(NULL, DELIM);	/* the password, if any  */
    opts = LQ_ALL | LQ_INTERACTIVE | ((uname) ? 0 : LQ_AUTO);
    if ((r = LoginQi(UseHost, ToQI, FromQI, opts, uname, upass)) != NULL) {
	strcpy(MyAlias, r);
	return LR_OK;
    }
    else {
	*MyAlias = '\0';
	return LR_ERROR;
    }
}

/*
 * execute a quit request
 */
int
DoQuit(in_line)
    char *in_line;
{
    DoOther("quit\n");
#ifdef VMS
    exit(SS$_NORMAL);
#else
    exit(LastCode < LR_OK || LastCode >= LR_MORE ? LastCode / 100 : 0);
#endif
}

/*
 * edit a field
 */
int
DoEdit(in_line)
    char *in_line;
{
    char *field;
    char *alias;
    char *value;
    int  code = LR_OK;
    char confirm[10];

    (void) strtok(in_line, DELIM);	/* skip ``edit'' */
    if (!(field = strtok((char *) 0, DELIM))) {
	(void) DoHelp("help edit\n");
	return (LR_ERROR);
    }
    if (!(alias = strtok((char *) 0, DELIM)))
	alias = MyAlias;

    if ((value = GetValue(alias, field)) && EditValue(value)) {
	for (code = UpdateValue(alias, field, value);
	     400 <= code && code <= 499;
	     code = UpdateValue(alias, field, value)) {
	    if (!isatty(0))
		break;
	    printf("Shall I try again [y/n]? ");
	    fgets(confirm, sizeof(confirm), stdin);
	    if (*confirm != 'y' && *confirm != 'Y')
		break;
	}
	if (code < 300 && !strcmp(field, "alias"))
	    strcpy(MyAlias, value);
    }
    return (code);
}

/*
 * get the value of a field from the nameserver
 */
char *
GetValue(alias, field)
    char *alias, *field;
{
    static char value[MAXVAL];	/* will hold the value */
    char *vSpot;
    char scratch[MAXSTR];
    int  code;

    if (!strcmp(field, "password")) {
	puts("Use the ``password'' command, not edit.");
	return (NULL);
    }
    /* do the query */
    if (Debug)
	fprintf(stderr, "sent=query alias=%s return %s\n", alias, field);
    qprintf(ToQI, "query alias=%s return %s\n", alias, field);
    qflush(ToQI);

    *value = '\0';

    /* read qi response lines, concatenating the responses into one value */
    for (vSpot = value;; vSpot += strlen(vSpot)) {
	if (!GetGood(scratch, MAXSTR, FromQI)) {
	    fprintf(stderr, "Ding-dong the server's dead!\n");
	    exit(0);
	}
	if ((code = atoi(scratch)) == -LR_OK)
	    strcpy(vSpot, strchr(GetQValue(scratch), ':') + 2);	/* part of value */
	else if (code >= LR_OK)
	    break;		/* final response */
	else
	    fputs(scratch, stdout);	/* ??? */
    }

    if (code != LR_OK)		/* error */
	fputs(scratch, stdout);

    return (code == LR_OK ? value : NULL);
}

/*
 * Edit a value
 */
int
EditValue(value)
    char *value;		/* the value to edit */
{
    char *fname;		/* name of temp file to use */

#ifdef VMS
    struct dsc$descriptor_s cli_input;
    char template[28], f1[28], f2[28], edit_command[64];
    int  istat;

#else
    char template[20];

#endif
    int  fd;			/* file descriptor for temp file */
    static char nvalue[MAXVAL];	/* new value */
    char *editor;		/* editor program to use */
    int  bytes;			/* number of bytes in file */
    char *from, *to;
    int  badc;			/* did we find a bad character? */

#ifdef WAIT_INT
    int  junk;

#else
    union wait junk;

#endif
    char scratch[80];

    /* put the value into a temp file */
#ifdef VMS
    strcpy(template, "SYS$SCRATCH:PHXXXXXX.TMP");
    fname = mktemp(template);
    strcpy(f1, fname);
    strcpy(f2, fname);
    strcat(f1, ";1");		/* versions needed for delete function */
    strcat(f2, ";2");
    if ((fd = creat(fname, 0)) < 0)
#else /* !VMS */
# ifdef OS2
    strcpy(template, "c:\\temp\\phXXXXXX");
# else /* !OS2 */
    strcpy(template, "/tmp/phXXXXXX");
# endif /* OS2 */
    fname = mktemp(template);
    if ((fd = open(fname, O_RDWR | O_CREAT, 0777)) < 0)
#endif /* VMS */
    {
	perror(fname);
	return (0);
    }
    if (write(fd, value, strlen(value)) < 0) {
	perror(fname);
	(void) close(fd);
	return (0);
    }
    (void) close(fd);

    /* run an editor on the temp file */
#ifdef VMS
    if (!(editor = getenv("EDITOR")))
	editor = "EDIT/EDT";

    strcpy(edit_command, editor);
    strcat(edit_command, " ");
    strcat(edit_command, fname);
    cli_input.dsc$w_length = strlen(edit_command);	/* descriptor for spawn */
    cli_input.dsc$a_pointer = edit_command;
    cli_input.dsc$b_class = DSC$K_CLASS_S;
    cli_input.dsc$b_dtype = DSC$K_DTYPE_T;

    if ((istat = LIB$SPAWN(&cli_input)) != SS$_NORMAL) {
	(void) delete(f1);
	exit(istat);
    }
#else /* !VMS */
# ifdef OS2
    {
	int rc, mode=P_WAIT;

	if (!(editor = getenv("EDITOR"))) {
	    editor = "epm.exe";
	    mode = P_PM;
	}
	rc = spawnlp( mode, editor, editor, fname, NULL);
	if (rc == -1)
	    fprintf(stderr, "Whoops!  Failed to exec %s\n", editor);
	if (mode == P_PM)
	    (void) wait(&junk);
    }
# else /* !OS2 */
    if (!(editor = getenv("EDITOR")))
	editor = "vi";
    if (fork())
	(void) wait(&junk);
    else {
	(void) execlp(editor, editor, fname, NULL);
	fprintf(stderr, "Whoops!  Failed to exec %s\n", editor);
	exit(1);
    }
# endif /* OS2 */
#endif /* VMS */

    /* does the user want the value? */
    if (Confirm) {
	do {
	    printf("Change the value [y]? ");
	    gets(scratch);
	}
	while (*scratch && !strchr("yYnN", *scratch));
    }
    /* read the value back out */
    if ((fd = open(fname, 0)) < 0) {
	perror(fname);
#ifdef VMS
#else
	(void) unlink(fname);
#endif
	return (0);
    }
#ifdef VMS
#else
    (void) unlink(fname);
#endif

    if ((bytes = read(fd, nvalue, MAXSTR - 1)) < 0) {
	perror(fname);
	(void) close(fd);
#ifdef VMS
	(void) delete(f1);	/* delete 1st temp file */
	(void) delete(f2);	/* delete 2nd temp file */
#endif
	return (0);
    }
    (void) close(fd);
#ifdef VMS
    (void) delete(f1);		/* delete 1st temp file */
    (void) delete(f2);		/* delete 2nd temp file */
#endif
    nvalue[bytes] = 0;

    /* did the value change? */
    if (Confirm && *scratch && *scratch != 'y' && *scratch != 'Y' ||
	!strcmp(nvalue, value))
	return (0);

    /* copy new value into old, stripping bad characters */
    badc = 0;
    for (to = value, from = nvalue; *from; from++)
	if (*from == '"') {
	    *to++ = '\\';
	    *to++ = '"';
	}
	else if (*from >= ' ' && *from <= '~')
	    *to++ = *from;
	else if (*from == '\t') {
	    *to++ = '\\';
	    *to++ = 't';
	}
	else if (*from == '\n') {
	    if (*(from + 1)) {	/* skip terminating newline from vi */
		*to++ = '\\';
		*to++ = 'n';
	    }
	}
	else
	    badc = 1;

    *to = 0;

    if (badc) {			/* complain if we found bad characters */
	fputs("Illegal characters were found in your value.\n", stderr);
	fputs("Please use only printable characters, newlines, and tabs.\n", stderr);
	fputs("The offending characters were removed.\n", stderr);
    }
    return (1);
}

/*
 * update a nameserver field with a new value
 */
int
UpdateValue(alias, field, value)
    char *alias, *field, *value;
{
    if (Debug)
	fprintf(stderr, "sent=change alias=%s make %s=\"%s\"\n", alias, field, value);
    qprintf(ToQI, "change alias=%s make %s=\"%s\"\n", alias, field, value);
    qflush(ToQI);

    return (PrintResponse(0));
}

/*
 * print info on current user
 */
/*ARGSUSED*/
int
DoMe(in_line)
    char *in_line;
{
    if (!*MyAlias) {
	return (DoHelp("help me"));
    }
    if (Debug)
	fprintf(stderr, "sent=query alias=%s return all\n", MyAlias);
    qprintf(ToQI, "query alias=%s return all\n", MyAlias);
    qflush(ToQI);

    return (NoBeautify ? PrintResponse(0) : PrintQResponse(0, 0));
}

/*
 * set command-line switches
 */
int
DoSwitch(in_line)
    char *in_line;
{
    in_line = strtok(in_line, DELIM);
    if (!OptionLine(strtok(0, "\n"))) {
	printf("The following things can be changed with \"switch\":\n\n");
	printf("  Paging is %s; use \"switch -%c\" to turn it %s.\n",
	       NoPager ? "OFF" : "ON",
	       NoPager ? 'M' : 'm',
	       NoPager ? "on" : "off");
	printf("  Email reformatting is %s; use \"switch -%c\" to turn it %s.\n",
	       NoReformat ? "OFF" : "ON",
	       NoReformat ? 'R' : 'r',
	       NoReformat ? "on" : "off");
	printf("  Query beautification is %s; use \"switch -%c\" to turn it %s.\n",
	       NoBeautify ? "OFF" : "ON",
	       NoBeautify ? 'B' : 'b',
	       NoBeautify ? "on" : "off");
	printf("  Label printing is %s; use \"switch -%c\" to turn it %s.\n",
	       NoLabels ? "OFF" : "ON",
	       NoLabels ? 'L' : 'l',
	       NoLabels ? "on" : "off");
	printf("  Edit confirmation is %s; use \"switch -%c\" to turn it %s.\n",
	       Confirm ? "ON" : "OFF",
	       Confirm ? 'c' : 'C',
	       Confirm ? "off" : "on");
	printf("  Default entry type is %s; use \"switch -%c%s\" to %s %s.\n",
	       DefType ? DefType : "OFF",
	       DefType ? 'T' : 't',
	       DefType ? "" : " name-of-type",
	       DefType ? "turn it" : "set it to",
	       DefType ? "off" : "\"name-of-type\"");
	printf("  Default field list is %s; use \"switch -%c%s\" to %s to %s.\n",
	       ReturnFields ? ReturnFields : "default",
	       ReturnFields ? 'F' : 'f',
	       ReturnFields ? "" : " field1,field2,... ",
	       ReturnFields ? "revert" : "set it",
	       ReturnFields ? "default" : "\"field1,field2,...\"");
	printf("\nThe following things cannot be changed with \"switch\":\n\n");
	printf("  Connected to server %s at port %d\n", UseHost, UsePort);
	printf("  The .netrc file was %sread.\n", NoNetrc ? "not " : "");
	printf("  The -h switch is meaningless in interactive mode.\n");
    }
    return (LR_OK);
}

/*
 * change a field value from the command line
 */
int
DoMake(in_line)
    char *in_line;
{
    int  code = LR_ERROR;
    char *token;

    if (!*MyAlias)
	DoHelp("help make");
    else {
	char scratch[MAXSTR];

	(void) strcpy(scratch, in_line);
	for (token = strtok(scratch, " \n"); token;
	     token = strtok(0, " \n")) {
	    if (!strncmp(token, "password=", 9)) {
		printf("Use the ``password'' command, not make.\n");
		return (LR_OK);
	    }
	}
	if (Debug)
	    fprintf(stderr, "sent=change alias=%s %s", MyAlias, in_line);
	qprintf(ToQI, "change alias=%s %s", MyAlias, in_line);
	qflush(ToQI);
	code = PrintResponse(0);
	if (code < 300)
	    for (token = strtok(in_line, " \n"); token; token = strtok(0, " \n"))
		if (!strncmp(token, "alias=", 6)) {
		    strcpy(MyAlias, token + 6);
		    break;
		}
    }
    return (code);
}

/*
 * register the current account
 */
int
DoRegister(in_line)
    char *in_line;
{
    int  code = LR_ERROR;
    struct passwd *pw;
    char hostname[MAXHOSTNAMELEN];

    if (!*MyAlias)
	DoHelp("help register");
    else if ((pw = getpwuid(getuid())) && !gethostname(hostname, sizeof(hostname))
	     && strcmp(pw -> pw_name, "phones")) {
	if (Debug)
	    fprintf(stderr, "sent=change alias=%s make email=%s@@%s\n",
		    MyAlias, pw -> pw_name, hostname);
	qprintf(ToQI, "change alias=%s make email=%s@@%s\n",
		MyAlias, pw -> pw_name, hostname);
	qflush(ToQI);
	code = PrintResponse(0);
    }
    return (code);
}

/*
 * change password
 */
int
DoPassword(in_line)
    char *in_line;
{
    char password[80];
    char *confirm;
    char *alias;
    int  code = LR_ERROR;

    if (!*MyAlias) {
	return (DoHelp("help password"));
    }
    /* which alias to use? */
    (void) strtok(in_line, DELIM);
    if (!(alias = strtok((char *) 0, DELIM)))
	alias = MyAlias;

    /* get the password */
    strcpy(password, getpass("Enter new password: "));
    if (!*password)
	return (LR_ERROR);
    confirm = getpass("Type it again: ");
    if (strlen(password) > PH_PW_LEN)
	*(password + PH_PW_LEN) = '\0';
    if (strlen(confirm) > PH_PW_LEN)
	*(confirm + PH_PW_LEN) = '\0';
    if (strcmp(confirm, password)) {
	fprintf(stderr, "Sorry--passwords didn't match.\n");
	return (code);
    }
    VetPassword(confirm);	/* complain if we don't like the password */

    /* encrypt and send the password */
    if (!LocalPort)
	password[encryptit(password, confirm)] = '\0';
    if (Debug)
	fprintf(stderr, "sent=change alias=%s %s password=%s\n", alias,
		LocalPort ? "force" : "make", password);
    qprintf(ToQI, "change alias=%s %s password=%s\n", alias,
	    LocalPort ? "force" : "make", password);
    qflush(ToQI);

    /* see what the nameserver says */
    if ((code = PrintResponse(0)) == LR_OK && !strcmp(alias, MyAlias))
#ifdef PRE_ENCRYPT
	crypt_start(crypt(confirm, confirm));
#else
	crypt_start(confirm);
#endif
    return (code);
}

/*
 * complain about passwords we don't like
 */
void
VetPassword(pass)
    char *pass;
{
    if (strlen(pass) < 5 ||	/* too short */
	AllDigits(pass))	/* digits only */
	fputs("That is an insecure password; please change it.\n", stderr);
}

/*
 * is a string all digits
 */
int
AllDigits(str)
    char *str;
{
    for (; *str; str++)
	if (!isdigit(*str))
	    return (0);
    return (1);
}

/*
 * log out the current user
 */
int
DoLogout(in_line)
    char *in_line;
{
    *MyAlias = '\0';
    return (LogoutQi(ToQI, FromQI));
}

/*
 * print the response to a query
 * this strips out all the nameserver reply codes.
 */
int
PrintQResponse(ref_email, help)
    int  ref_email;

    int  help;
{
    char line[MAXSTR];
    int  code = LR_ERROR;
    int  CurPerson = 0;
    int  person;
    char *cp;
    FILE *out;
    char alias[MAXSTR];
    char email[MAXSTR];
    int  copiedEmail = 0;

    out = OpenPager(1);

    *alias = *email = 0;	/* haven't found an alias yet */
    if (NoReformat || !MailDomain)
	ref_email = 0;
    /* get the response */
    while (GetGood(line, MAXSTR, FromQI)) {
	code = atoi(line);
	if (code == LR_NUMRET) {
#ifdef MACC
	    cp = strchr(line, ':');
	    if (cp != 0)
		fprintf(out, "\n%s\n", cp + 1);	/* strchr returns pointer to :
						 * then add one */
#endif				/* MACC */
	}
	else if (code == -LR_OK || code == -LR_AINFO || code == -LR_ABSENT
		 || code == -LR_ISCRYPT) {
	    person = atoi(strchr(line, ':') + 1);
	    /* output a delimiter */
	    if (person != CurPerson) {
		if (*alias && !*email)
		    NotRegisteredLine(alias, out);
		else if (*email) {
		    EmailLine(email, alias);
		    fputs(GetQValue(email), out);
		    *email = 0;
		}
		fputs("----------------------------------------\n", out);
		CurPerson = person;
		copiedEmail = 0;
	    }
	    if (ref_email) {
		cp = GetQValue(line);
		while (*cp && *cp == ' ')
		    cp++;
		if (!strncmp("alias", cp, 5)) {
		    copiedEmail = 0;
		    strcpy(alias, line);
		    continue;
		}
		else if (!strncmp("email", cp, 5)) {
		    strcpy(email, line);
		    copiedEmail = 1;
		    continue;
		}
		else if (*cp == ':' && copiedEmail)
		    continue;
		else
		    copiedEmail = 0;
	    }
	    /* output the line */
	    if (NoLabels && !help)
		fputs(strchr(GetQValue(line), ':') + 2, out);
	    else
		fputs(GetQValue(line), out);
	}
	else if (code != LR_OK)
	    fputs(line, out);	/* error */

	if (code >= LR_OK) {
	    if (*alias && !*email)
		NotRegisteredLine(alias, out);
	    else if (*email) {
		EmailLine(email, alias);
		/* output the line */
		if (NoLabels && !help)
		    fputs(strchr(GetQValue(email), ':') + 2, out);
		else
		    fputs(GetQValue(email), out);
	    }
	    break;
	}
    }

    /* final "delimiter" */
    if (CurPerson)
	fputs("----------------------------------------\n", out);

#ifdef VMS
#else
    if (out != stdout)
	(void) pclose(out);
#endif

    return (code);
}

#ifndef HASSTRTOK
/*
 * break a string into tokens.  this code is NOT lifted from sysV, but
 * was written from scratch.
 */
/*
 * function:   strtok purpose:	to break a string into tokens parameters:
 * s1 string to be tokenized or 0 (which will use last string) s2 delimiters
 * returns:  pointer to first token.  Puts a null after the token. returns
 * NULL if no tokens remain.
 */
char *
strtok(s1, s2)
    char *s1;

    const char *s2;
{
    static char *old = 0;
    char *p1, *p2;

    if (!(s1 || old))
	return (NULL);
    p1 = (s1 ? s1 : old);
    while (*p1 && (strchr(s2, *p1) != NULL))
	p1++;
    if (*p1) {
	p2 = p1;
	while (*p2 && (strchr(s2, *p2) == NULL))
	    p2++;
	if (*p2) {
	    *p2 = '\0';
	    old = ++p2;
	}
	else
	    old = 0;
	return (p1);
    }
    else
	return (NULL);
}

#endif
#ifdef VMS
/*	setterm.c
 *
 *    module in termlib
 *
 *    contains routines to set terminal mode
 *
 *    V1.0 19-jul-84  P. Schleifer  Initial draft
 */

setterm(characteristic, state)
    INT32 *characteristic, *state;
{
    int  status;
    INT32 efn;
    INT32 new_state;
    short term_chan;
    struct char_buff mode;
    struct mode_iosb term_iosb;

    $DESCRIPTOR(term_desc, "TT:");

    /* get event flag */
    status = lib$get_ef(&efn);
    if (status != SS$_NORMAL)
	return (status);

    /* get channel to terminal */
    status = sys$assign(&term_desc, &term_chan, 0, 0);
    if (status != SS$_NORMAL)
	return (status);

    /* if characteristic is BROADCAST, ECHO, or TYPEAHEAD, state must be
     * toggled */
    if (*characteristic == BROADCAST || *characteristic == ECHO || *characteristic == TYPEAHEAD)
	new_state = !(*state);
    else
	new_state = *state;

    /* get current mode */
    status = sys$qiow(efn, term_chan, IO$_SENSEMODE, &term_iosb, 0, 0, &mode, 12, 0, 0, 0, 0);
    if (status != SS$_NORMAL || term_iosb.stat != SS$_NORMAL) {
	sys$dassgn(term_chan);
	return (status);
    }
    /* change characteristics buffer */
    if (new_state == ON)
	mode.basic_char |= *characteristic;
    else
	mode.basic_char &= ~(*characteristic);

    /* $ SET TERM/...  and then deassign channel */
    status = sys$qiow(efn, term_chan, IO$_SETMODE, &term_iosb, 0, 0, &mode, 12, 0, 0, 0, 0);

    sys$dassgn(term_chan);
    lib$free_ef(&efn);

    if (status != SS$_NORMAL)
	return (status);
    else
	return (term_iosb.stat);
}

/*
 * get password from stdin
 *
 * implement for VMS, since VAXCRTL lacks getpass() function.
 */
char *
getpass(prompt)
    char *prompt;
{

    static char line[12];
    static int echo =
    {ECHO}, off =
    {OFF}, on =
    {ON};

    printf(prompt);
    (void) fflush(stdout);	/* prompt */
    setterm(&echo, &off);
    gets(line);
    setterm(&echo, &on);
    puts("");
    return (line);
}

#endif

/*
 * use .netrc to login to nameserver, if possible
 */
void
DoAutoLogin()
{
    char *r;
    int  opts = LQ_ALL | LQ_AUTO;

    if ((r = LoginQi(UseHost, ToQI, FromQI, opts, NULL, NULL)) != NULL)
	strcpy(MyAlias, r);
    else
	*MyAlias = '\0';
}

/*
 * execute a help request
 */
int
DoHelp(in_line)
    char *in_line;
{
    char scratch[256];
    char *token;

    if (*in_line == '?') {
	/* avoid bug for lone ? */
	sprintf(scratch, "help %s", in_line + 1);
	strcpy(in_line, scratch);
    }
    else
	strcpy(scratch, in_line);
    token = strtok(scratch + 4, DELIM);	/* the word after help */
    if (token && !strcmp(token, "native"))	/* looking for native help */
	strcpy(scratch, in_line);	/* leave the command alone */
    else
	sprintf(scratch, "help %s %s", CLIENT, in_line + 4);	/* insert identifier */

    if (Debug)
	fprintf(stderr, "sent=%s", scratch);	/* send command */
    qprintf(ToQI, "%s", scratch);	/* send command */
    qflush(ToQI);
    return (NoBeautify ? PrintResponse(0) : PrintQResponse(0, 1));
}

/*
 * reformat an email line to include an alias address
 * this is kind of a hack since we're working on an already-formatted line
 */
void
EmailLine(email, alias)
    char *email, *alias;
{
    char scratch[MAXSTR];
    char *emSpot;		/* beginning of email account */
    char *alSpot;		/* beginning of nameserver alias */

    if (*alias) {
	emSpot = (char *) strchr(GetQValue(email), ':') + 2;
	alSpot = (char *) strchr(GetQValue(alias), ':') + 2;
	*(char *) strchr(alSpot, '\n') = 0;
	*(char *) strchr(emSpot, '\n') = 0;
	/* overwrite the email label */
	strcpy(alSpot - 2 - strlen("email to"), "email to");
	alSpot[-2] = ':';	/* strcpy clobbered the colon; repair */
	sprintf(scratch, "@@%s (%s)\n", MailDomain, emSpot);
	strcat(alias, scratch);
	strcpy(email, alias);	/* leave it in the "email" line */
	*alias = 0;		/* we're done with the alias */
    }
}

/*
 * put out a ``not registered'' line with alias
 */
void
NotRegisteredLine(alias, out)
    char *alias;

    FILE *out;
{
    char scratch[MAXSTR];
    char *cp;

    strcpy(scratch, alias);
    cp = (char *) strchr(GetQValue(scratch), ':');
    strcpy(cp - 7, "email");
    cp[-2] = ':';
    strcpy(cp, "no account registered\n");
    EmailLine(scratch, alias);
    /* output the line */
    if (NoLabels)
	fputs(strchr(GetQValue(scratch), ':') + 2, out);
    else
	fputs(GetQValue(scratch), out);
    *alias = 0;			/* done with alias */
}

/*
 * process a set of options
 */
int
ProcessOptions(argc, argv)
    int  argc;

    char **argv;
{
    int  count = 0;

    /* options processing */
    for (; argc && **argv == '-'; argc--, argv++, count++) {
	for ((*argv)++; **argv; (*argv)++) {
	    switch (**argv) {
	      case 'q':
		Quiet = 1;
		break;
	      case 'r':
		NoReformat = 1;
		break;
	      case 'R':
		NoReformat = 0;
		break;
	      case 'n':
		NoNetrc = 1;
		break;
	      case 'N':
		NoNetrc = 0;
		break;
	      case 'm':
		NoPager = 1;
		break;
	      case 'M':
		NoPager = 0;
		break;
	      case 'b':
		NoBeautify = 1;
		break;
	      case 'B':
		NoBeautify = 0;
		break;
	      case 'D':
		QiDebug++;
		Debug++;
		QiAuthDebug++;
		break;
	      case 'l':
		NoLabels = 1;
		break;
	      case 'L':
		NoLabels = 0;
		break;
	      case 'C':
		Confirm = 1;
		break;
	      case 'c':
		Confirm = 0;
		break;
	      case 'H':
		JustHelp = 0;
		break;
	      case 'h':
		JustHelp = 1;
		break;
	      case 's':
		if (argv[0][1]) {
		    if (UseHost)
			free(UseHost);
		    UseHost = strdup(*argv + 1);
		    MailDomain = NULL;
		    goto whilebottom;
		}
		else if (argc > 1) {
		    if (UseHost)
			free(UseHost);
		    UseHost = strdup(argv[1]);
		    argc--, argv++, count++;
		    MailDomain = NULL;
		    goto whilebottom;
		}
		else
		    fprintf(stderr, "-%c option given without server hostname.\n", **argv);
		break;
	      case 't':
		if (argv[0][1]) {
		    if (DefType)
			free(DefType);
		    DefType = strdup(*argv + 1);
		    goto whilebottom;
		}
		else if (argc > 1) {
		    if (DefType)
			free(DefType);
		    DefType = strdup(argv[1]);
		    argc--, argv++, count++;
		    goto whilebottom;
		}
		else
		    fprintf(stderr, "-%t option given without entry type.\n", **argv);
		break;
	      case 'f':
		if (argv[0][1]) {
		    if (ReturnFields)
			free(ReturnFields);
		    ReturnFields = strdup(*argv + 1);
		    goto whilebottom;
		}
		else if (argc > 1) {
		    if (ReturnFields)
			free(ReturnFields);
		    ReturnFields = strdup(argv[1]);
		    argc--, argv++, count++;
		    goto whilebottom;
		}
		else
		    fprintf(stderr, "-%t option given without field list.\n", **argv);
		break;
	      case 'F':
		if (ReturnFields)
		    free(ReturnFields);
		ReturnFields = 0;
		break;
	      case 'T':
		if (DefType)
		    free(DefType);
		DefType = 0;
		break;
	      case 'p':
		if (isdigit(argv[0][1])) {
		    UsePort = atoi(*argv + 1);
		    goto whilebottom;
		}
		else if (argc > 1 && isdigit(*argv[1])) {
		    UsePort = atoi(argv[1]);
		    argc--, argv++, count++;
		    goto whilebottom;
		}
		else
		    fprintf(stderr, "-%c option given without port number.\n", **argv);
		break;
	      default:
		fprintf(stderr, "Unknown option: -%c.\n", **argv);
	    }
	}
whilebottom:;
    }
    return (count);
}

/*
 * Process a lineful of options
 */
int
OptionLine(line)
    char *line;
{
    int  argc;
    char *argv[MAXARGS];
    char *token;

    if (!line || !*line)
	return (0);

    for (argc = 0, token = strtok(line, DELIM); token; argc++, token = strtok(0, DELIM))
	argv[argc] = token;
    argv[argc] = 0;

    return (ProcessOptions(argc, argv));
}

/*
 * OpenPager - open the user's chosen pager
 */
FILE *
OpenPager(pager)
    int  pager;
{
    char *pname;
    FILE *out;

#ifdef VMS
    return (stdout);		/* simpler to skip paging for right now */
#else
    if (NoPager || pager != 1)
	return (stdout);
    else {
	if ((pname = getenv("PAGER")) == NULL)
	    pname = PAGER;
	if ((out = popen(pname, "w")) == NULL)
	    out = stdout;
	return (out);
#endif
    }
}

/*
 * issub - is one string a substring of another?
 */
char *
issub(string, sub)
    char *string, *sub;
{
    int  len;

    len = strlen(sub);
    for (; *string; string++)
	if (!strncmp(string, sub, len))
	    return (string);
    return (0);
}

/*
 * EnvOptions - grab some options from the environment
 */
void
EnvOptions(name)
    char *name;
{
    char buffer[80];
    char *np, *bp;

    for (np = name, bp = buffer; *np; np++, bp++)
	*bp = islower(*np) ? toupper(*np) : *np;
    *bp = 0;
    (void) OptionLine(getenv(buffer));
}

/*
 * Dot2Addr - turn a dotted decimal address into an inet address
 * ---Assumes 4 octets---
 */
unsigned INT32
Dot2Addr(dot)
    char *dot;
{
    unsigned INT32 addr = 0;

    do {
	addr <<= 8;
	addr |= atoi(dot);
	while (isdigit(*dot))
	    dot++;
	if (*dot)
	    dot++;
    }
    while (*dot);
    return ((unsigned INT32) htonl(addr));
}
@


7.5
log
@Indent did _something_ to the qprintf #define that caused xlc to loop
forever.
@
text
@d38 2
a39 2
static char rcsid[] = "@@(#)$Id: ph.c,v 7.4 1995/06/23 04:03:48 p-pomes Exp p-pomes $";
static char rcsrev[] = "100:Ph client $Revision: 7.4 $";
d151 4
d334 1
d340 1
d443 3
d447 1
d1059 4
a1062 1
#else
d1064 1
d1067 1
a1067 1
#endif
d1096 16
a1111 1
#else
d1121 2
a1122 1
#endif
@


7.4
log
@ran indent.
@
text
@d38 2
a39 2
static char rcsid[] = "@@(#)$Id: ph.c,v 7.3 1995/06/23 02:52:21 p-pomes Exp p-pomes $";
static char rcsrev[] = "100:Ph client $Revision: 7.3 $";
d257 1
a257 1
#define qprintf		\	/* this is fairly sneaky... */
d259 2
a260 2
    \
      char *ToQI = ToQIBuf;
d262 5
a266 5
    \
      sprintf
#define qflush(foobar)		\	/* compound sneakiness */
ToQILen = strlen(ToQIBuf);
\
@


7.3
log
@Some #ifdef PRE_ENCRYPT additions.
@
text
@d38 2
a39 2
static char  rcsid[] = "@@(#)$Id: ph.c,v 7.2 1995/06/10 03:51:09 p-pomes Exp p-pomes $";
static char  rcsrev[] = "100:Ph client $Revision: 7.2 $";
d42 5
a46 5
#ifndef OSF1
#define INT32 long
#else
#define INT32 int
#endif
d55 1
a55 1
 * ns     	105/tcp     csnet-ns        # CSO nameserver
d60 2
a61 2


d64 1
a64 1

d66 1
a66 1

d68 1
a68 1

d75 1
a75 1

d77 1
a77 1

d80 1
a80 1

d83 1
a83 1

d86 1
a86 1

d92 1
a92 1

d97 1
a97 1

d100 1
a100 1

d102 1
a102 1

d105 1
a105 1

d120 5
a124 5
#include descrip		/*VMS descriptor structures defs */
#include iodef			/*VMS I/O function definitions */
#include ssdef			/*VMS System Status definitions */
#include ttdef			/*VMS terminal characteristics */
#include "termdefs.h"		/*VMS defs for setterm() function */
d126 1
a126 1
#else	/* !VMS */
d143 1
a143 1
#endif	/* VMS */
d158 4
a161 4
#define MAXSTR		2048	/*max string length */
#define MAXVAL		14000	/*max value length */
#define DELIM		" \t\n"	/*command delimiters */
#define MAXARGS		20	/*maximum # of arguments in PH environ var. */
d171 3
a173 3
char	*strchr();		/*VMS equivalent of "index" */
char	*strrchr();		/*VMS equivalent of "rindex" */
#endif	/* VMS */
d180 19
a198 17
char	*GetValue __P((char *, char *));
char	*issub __P((char *, char *));
int	ContactQI();
int	DoId();
int	PrintResponse __P((int));
#ifdef VMS
int	GetGood __P((char *, int, int));
#else
int	GetGood __P((char *, int, FILE *));
#endif
void	EnvOptions __P((char *));
void	ComplainAboutService();
void	ComplainAboutHost __P((char *));
void	Interactive();
int	DoCommand __P((char *));
int	DoOtherWPage __P((char *));
int	DoOther __P((char *));
d201 1
a201 1
int	DoFields __P((char *));
d204 22
a225 22
int	DoHelp __P((char *));
int	DoQuery __P((char *));
int	DoLogin __P((char *));
int	DoQuit __P((char *));
int	DoEdit __P((char *));
int	DoMake __P((char *));
int	DoRegister __P((char *));
int	EditValue __P((char *));
int	UpdateValue __P((char *, char *, char *));
int	DoFields __P((char *));
int	DoMe __P((char *));
int	DoLogout __P((char *));
int	DoPassword __P((char *));
void	VetPassword __P((char *));
int	AllDigits __P((char *));
int	PrintQResponse __P((int, int));
void	DoAutoLogin();
void	SkipMacdef __P((FILE *));
void	EmailLine __P((char *, char *));
void	NotRegisteredLine __P((char *, FILE *));
FILE	*OpenPager __P((int));
int	DoSwitch __P((char *));
d233 3
a235 3
char	*malloc();
char	*getenv();
char	*strtok();
d237 3
a239 2
char	*getpass __P((const char *));
char	*mktemp __P((char *));
d243 1
a243 1
#endif
d249 1
a249 1
int	maccecho = 0;
d253 5
a257 6
int	ToQI;			/*write to this to tell the nameserver stuff */
int	FromQI;			/*read nameserver responses from here */
char	ToQIBuf[MAXSTR];
int	ToQILen;

#define qprintf		\	/*this is fairly sneaky... */
d259 2
a260 2
	\
	   char    *ToQI = ToQIBuf;
d262 5
a266 5
	\
	   sprintf
#define qflush(foobar)		\	/*compound sneakiness */
	   ToQILen = strlen(ToQIBuf);
	\
d271 2
a272 3
FILE	*ToQI;			/*write to this to tell the nameserver stuff */
FILE	*FromQI;		/*read nameserver responses from here */

d276 7
a282 6
char	MyAlias[MAXSTR];	/*currently logged-in alias */
char	*Me;			/*the name of this program */
char	*MyPassword = NULL;	/*password read from .netrc (if any) */
char	*MailDomain = MAILDOMAIN;	/*mail domain */
int	LocalPort = 0;		/*local port in use */
int	Debug = 0;		/* print debug info if set */
d288 12
a299 12
int	NoNetrc = 0;		/*-n don't read .netrc */
char	*UseHost = 0;		/*-s use server on what machine */
int	UsePort = 0;		/*-p use port # */
int	NoReformat = 0;		/*-i don't reformat email fields */
int	NoPager = 0;		/*-m don't use pager */
int	NoBeautify = 0;		/*-b don't beautify output */
int	NoLabels = 0;		/*-l don't use labels */
int	Confirm = 0;		/*-c confirm Edit */
int	Quiet = 0;		/*-q act like a pipe, no extraneous output */
char	*DefType = 0;		/*-t prepend this type to queries */
char	*ReturnFields = NULL;	/*-f give list of fields */
int	JustHelp = 0;		/*-h give me help */
d306 2
a307 2
	int	argc;
	char   **argv;
d309 3
a311 3
	int	code = LR_ERROR;
	int	optionsCount;
	char	buffer[4096];
d314 1
a314 6
	int	margc = 0;

#endif
#ifdef VMS
	char	*temps;		/*temp strings */

a315 3
	/*
	 * figure out what this program is called
	 */
d317 1
a317 3
	Me = " ph";
#else
	Me = (char *)strrchr(*argv, '/');
d319 1
a319 18
	if (Me)
		Me++;
	else
		Me = *argv;
	EnvOptions(CLIENT);
	if (strcmp(CLIENT, Me))
	{
		sprintf(buffer, "-t %s", Me);
		(void) OptionLine(buffer);
		EnvOptions(Me);
	}
	optionsCount = ProcessOptions(--argc, ++argv);
	argc -= optionsCount;
	argv += optionsCount;

	if (!ContactQI())
	{
		fputs("Sorry--phone book not available now.\n", stderr);
d321 1
a321 1
		exit(SS$_CONNECFAIL);
d323 49
a371 2
		exit(1);
#endif
d373 6
a378 37
	/*
	 * identify ourselves
	 */
	if ((code = DoId()) >= 400)
		exit(code / 100);
	if (!MailDomain && (code = GetMailDomain()) >= 400)
		exit(code / 100);
	if (argc == 0 && !JustHelp)
		Interactive();	/*no arguments--interactive mode */
	else
	{
		/*make a query out of the arguments */
#ifdef VMS
		temps = JustHelp ? "help ph " : "query ";
		netwrite(ToQI, temps, strlen(temps));
		for (; argc; argc--, argv++)
		{
			netwrite(ToQI, *argv, strlen(*argv));
			if (argc > 1)
				netwrite(ToQI, " ", 1);
		}
		temps = "\nquit\n";
		netwrite(ToQI, temps, strlen(temps));
#else
		strcpy(buffer, JustHelp ? "help " : "query ");
		for (; argc; argc--, argv++)
		{
			strcat(buffer, *argv);
			if (argc > 1)
				strcat(buffer, " ");
		}
		strcat(buffer, "\n");
		code = DoCommand(buffer);
		if (Debug)
			fprintf(stderr, "sent=quit\n");
		qprintf(ToQI, "quit\n");
		qflush(ToQI);
d380 1
a380 1
	}
d382 1
a382 1
	exit(SS$_NORMAL);
d384 1
a384 1
	exit(code > 299 ? code / 100 : 0);
d394 12
a405 10
	int	sock;			/*our socket */
	static struct sockaddr_in QI;	/*the address of the nameserver */
	struct servent *sp;		/*nameserver service entry */
	static struct hostent *hp; 	/*host entry for nameserver */
	char	host[80];
	char	*baseHost;
	int	backupNum = 0;
	int	mightBackup;
	int	result = 0;
	int	err;
d407 35
d443 1
a443 43

	/* give up privs if using anything other than default port and host */
	if (UsePort || (UseHost && *UseHost))
	{
		if (Debug)
			fprintf(stderr, "giving up privs (UsePort || UseHost)\n");
		(void) setgid(getgid());
		(void) setuid(getuid());
	}
		
	/*find the proper port */
	if (UsePort)
		QI.sin_port = htons(UsePort);
	else if (sp = getservbyname(NSSERVICE, "tcp"))
	{
		QI.sin_port = sp->s_port;
	} else
	{
		ComplainAboutService();
		QI.sin_port = htons(atoi(FALLBACKPORT));
	}

	/*find the proper host */
	baseHost = UseHost ? UseHost : HOST;
	if (mightBackup = (*baseHost == '.'))
		sprintf(host, "%s%s", NSSERVICE, baseHost);
	else
		strcpy(host, baseHost);

	if (!geteuid())
		LocalPort = (IPPORT_RESERVED - 1);
	for (;;)
	{
		/*create the socket */
		sock = LocalPort ? rresvport(&LocalPort) : socket(PF_INET, SOCK_STREAM, 0);
		if (sock < 0)
		{
			perror("socket");
			goto done;
		}
		QI.sin_family = AF_INET;
		if (hp = gethostbyname(host))
		{
d445 1
a445 1
			memmove((char *) &QI.sin_addr, hp->h_addr, 4);
d447 1
a447 1
			memmove((char *) &QI.sin_addr.s_addr, hp->h_addr, 4);
a448 41
		} else if (!backupNum)
		{
			ComplainAboutHost(host);
			QI.sin_addr.s_addr = Dot2Addr(FALLBACKADDR);
		} else
		{
			fprintf(stderr, "No more backups to try.\n");
			goto done;
		}

		/*connect to the nameserver */
		if (connect(sock, (struct sockaddr *) & QI, sizeof (QI)) < 0)
		{
			if (errno == EADDRINUSE)
			{
				if (LocalPort)
					LocalPort = LocalPort - 1;
				continue;
			}
			perror(host);
			if (mightBackup)
			{
				backupNum++;
				sprintf(host, "%s%d%s", NSSERVICE, backupNum, baseHost);
			} else
				goto done;
		} else
			break;
	}

	if (backupNum)
		fprintf(stderr, "WARNING--backup host %s; information may be out of date.\n", host);
	/*open path to nameserver */
#ifdef VMS
	ToQI = sock;		/*copy socket channel for netwrite calls */
	FromQI = sock;		/*ditto for netread calls */
#else
	if ((ToQI = fdopen(sock, "w")) == NULL)
	{
		perror("to qi");
		goto done;
d450 22
a471 4
	/*open path from nameserver */
	if ((FromQI = fdopen(sock, "r")) == NULL)
	{
		perror("from qi");
d474 31
a504 11
#endif
	if (UseHost)
		free(UseHost);
	UseHost = strdup(hp ? hp->h_name : inet_ntoa(QI.sin_addr));
	UsePort = ntohs(QI.sin_port);
	result = 1;

      done:
	setgid(getgid());
	setuid(getuid());
	return (result);
d513 17
a529 19
	int	code;
	char	*cpnt = (char *)getlogin();
	struct passwd *pw;

	/* Who is doing this? */
	if (cpnt == NULL || (pw = getpwnam(cpnt)) == NULL)
	{
		if ((pw = getpwuid(getuid())) == NULL)
		{
			perror("getpwuid(getuid())");
			exit(1);
		}
	}
	if (Debug)
		fprintf(stderr, "sent=id %d\n", pw->pw_uid);
	qprintf(ToQI, "id %d\n", pw->pw_uid);
	qflush(ToQI);
	code = PrintResponse(-1);
	return (code);
d538 21
a558 28
	char	scratch[MAXSTR];
	char	*lastc, *s2lastc;
	short	code = 0;

	if (Debug)
		fprintf(stderr, "sent=siteinfo\n");
	qprintf(ToQI, "siteinfo\n");
	qflush(ToQI);
	while (GetGood(scratch, MAXSTR, FromQI))	/*read it */
	{
		code = atoi(scratch);
		if (code == -200)
		{
			if ((lastc = (char *)strrchr(scratch, ':')) && lastc > scratch)
			{
				*lastc++ = 0;
				if (s2lastc = (char *)strrchr(scratch, ':'))
				{
					s2lastc++;
					if (!strcmp("maildomain", s2lastc))
					{
						lastc[strlen(lastc) - 1] = 0;
						MailDomain = strdup(lastc);
					}
				}
			}
		} else if (code >= LR_OK)
			break;
d560 4
a563 1
	return (code ? 200 : 500);	/*only fail if the cnxn broke */
d576 1
a576 1
	int	pager;			/*use the pager? */
d578 12
a589 13
	char	scratch[MAXSTR];	/*some space */
	int	code = LR_ERROR;	/*the reply code */
	FILE	*out;

	out = OpenPager(pager);
	while (GetGood(scratch, MAXSTR, FromQI))	/*read it */
	{
		code = atoi(scratch);
		if (pager != -1 || code >= 400)
			fputs(scratch, out);	/*echo it */
		if (code >= LR_OK)
			break;
	}
d592 2
a593 2
	if (out != stdout)
		pclose(out);
d596 1
a596 1
	return (code);		/*all done.  return final code */
d606 4
a609 4
	fprintf(stderr, "Warning--there is no entry for ``%s'' in /etc/services;\n",
		NSSERVICE);
	fputs("please have your systems administrator add one.\n", stderr);
	fprintf(stderr, "I'm going to use port %s in the meantime.\n", FALLBACKPORT);
d617 1
a617 1
	char	*name;
d619 4
a622 4
	fprintf(stderr, "Warning--unable to find address for ``%s''.\n",
		name);
	fprintf(stderr, "I'm going to use address %s in the meantime.\n",
		FALLBACKADDR);
d629 5
a633 5
struct command
{
	char	*cName;		/*the name of the command */
	int	cLog;		/*must be logged in to use? */
	int	(*cFunc) ();	/*function to call for command */
d636 1
a636 1
CMD	CommandTable[] =
d638 3
a640 3
	"help", 0, DoHelp,
	"?", 0, DoHelp,
	"query", 0, DoQuery,
d642 9
a650 9
	CLIENT, 0, DoQuery,
	"me", 1, DoMe,
	"edit", 1, DoEdit,
	"make", 1, DoMake,
	"register", 1, DoRegister,
	"password", 1, DoPassword,
	"passwd", 1, DoPassword,
	"login", 0, DoLogin,
	"logout", 1, DoLogout,
d653 1
a653 1
	"fields", 0, DoFields,
d655 2
a656 2
	"fields", 0, DoOtherWPage,
	"switch", 0, DoSwitch,
d659 8
a666 8
	"add", 1, DoOther,
	"delete", 1, DoOther,
	"set", 0, DoOther,
#endif
	"quit", 0, DoQuit,
	"bye", 0, DoQuit,
	"exit", 0, DoQuit,
	0, 0, 0
d672 1
a672 1
int	LastCode = 0;		/*the response from the previous command */
d677 2
a678 2
	char	in_line[MAXSTR];	/*space for an input line */
	char	*spot;
d680 9
a688 13
	*MyAlias = 0;		/*nobody logged in yet... */
	if (!Quiet)
		puts(rcsrev);

	/*
	 * print database status
	 */
	if (!Quiet)
		LastCode = DoOther("status\n");

	/*
	 * autologin if possible
	 */
d690 2
a691 2
	if (!NoNetrc)
		DoAutoLogin();
d694 2
a695 2
	if (!Quiet)
		puts("");
d697 3
a699 5
	while (1)
	{
		(void) signal(SIGPIPE, SIG_IGN);
		if (!Quiet)
		{
d701 2
a702 2
			if (!maccecho)
				printf("%s> ", Me);
d704 1
a704 1
				printf("%s> ", Me);
d706 13
a718 14
			(void) fflush(stdout);	/*prompt */
		}
		spot = in_line;
		do
		{
			if (!fgets(spot, MAXSTR - (spot - in_line), stdin))
				return; /*read line */
			spot = in_line + strlen(in_line) - 2;
			if (*spot == '\\')
				*spot++ = ' ';
			else
				spot = in_line - 1;
		}
		while (spot >= in_line);
d720 2
a721 2
		if (maccecho && !Quiet)
			printf("%s> %s", Me, in_line);
d724 3
a726 3
		if (!(LastCode = DoCommand(in_line))) /*is it a command we know? */
			LastCode = DoOther(in_line);	/*unrecognized command */
	}
d734 1
a734 1
	char	*in_line;	/*the input line */
d736 19
a754 36
	char	scratch[MAXSTR];	/*some space */
	char	*token;		/*a token from the command line */
	CMD	*cmd;		/*the command name */
	CMD	*doMe;
	int	len;

	/*make a safe copy of the input line, so we can play with it */
	strcpy(scratch, in_line);

	if (!(token = strtok(scratch, DELIM)))
		return (LR_ERROR);	/*blank line */

	/*search command table linearly */
	doMe = NULL;
	len = strlen(token);
	for (cmd = CommandTable; cmd->cName; cmd++)
		if (!strncmp(cmd->cName, token, len))
		{
			if (doMe)	/*we found 2 commands that match (bad) */
			{
				printf("%s is ambiguous.\n", token);
				return (LR_ERROR);
			}
			doMe = cmd;	/*we found a command that matches */
		}
	if (doMe)		/*found one and only one command */
	{
		/*expand command name */
		token = strtok((char *) 0, "\n");
		sprintf(in_line, "%s %s\n", doMe->cName, token ? token : "");

		/*execute command */
		if (doMe->cLog && !*MyAlias)
			printf("You must be logged in to use %s.\n", doMe->cName);
		else
			return ((*doMe->cFunc) (in_line));
d756 2
d759 13
a771 1
	return (0);		/*didn't find it */
d779 1
a779 1
	char	*in_line;
d781 5
a785 5
	if (Debug)
		fprintf(stderr, "sent=%s", in_line); /*send command */
	qprintf(ToQI, "%s", in_line); /*send command */
	qflush(ToQI);
	return (PrintResponse(1));	/*get response */
d793 1
a793 1
	char	*in_line;
d795 5
a799 5
	if (Debug)
		fprintf(stderr, "sent=%s", in_line); /*send command */
	qprintf(ToQI, "%s", in_line); /*send command */
	qflush(ToQI);
	return (PrintResponse(0));	/*get response */
d805 1
a805 1
	char	*in_line;
d807 17
a823 17
	printf("Field Name     Description\n");
	printf("------------------------------\n");
	printf("name          Person Name\n");
	printf("email         Electronic Mail Address if exists\n");
	printf("phone         Telephone Number One\n");
	printf("phone2        Telephone Number Two\n");
	printf("address       Street Address of the Building\n");
	printf("building      Building Name\n");
	printf("department    Department Number One of Person\n");
	printf("department2   Department number Two of Person\n");
	printf("appointment   Appointment Classification Code Number One \n");
	printf("appointment2  Appointment Classification Code Number Two\n");
	printf("title         Title One\n");
	printf("title2        Title Two\n");
	printf("alias         Unique Name built from First Letter of First Name, Last\n");
	printf("              Name and a Number\n\n");
	return (LR_OK);
d833 1
a833 1
	char	*in_line;
d835 43
a877 49
	char	scratch[4096];
	char	*args;
	int	noReformatWas = NoReformat;
	int	code;

	if (ReturnFields && !issub(in_line, "return"))
	{
		args = in_line + strlen(in_line) - 1;
		sprintf(args, " return %s\n", ReturnFields);
		for (; *args; args++)
			if (*args == ',')
				*args = ' ';
	}
	if (!NoBeautify && !NoReformat)
	{
		char	*ret = issub(in_line, "return");

		if (ret)
			NoReformat = !issub(ret, "email");
	}
	if (!DefType || issub(in_line, "type="))
	{
		if (Debug)
			fprintf(stderr, "sent=%s", in_line); /*send command */
		qprintf(ToQI, "%s", in_line); /*send command */
	}
	else
	{
		strcpy(scratch, in_line);
		args = strtok(scratch, " \t");
		args = strtok(0, "\n");
		if (args)
		{
			if (Debug)
				fprintf(stderr, "sent=query type=\"%s\" %s\n", DefType, args); /*send command */
			qprintf(ToQI, "query type=\"%s\" %s\n", DefType, args); /*send command */
		}
		else
		{
			if (Debug)
				fprintf(stderr, "sent=%s", in_line);
			qprintf(ToQI, "%s", in_line);
		}
	}

	qflush(ToQI);
	code = (NoBeautify ? PrintResponse(1) : PrintQResponse(1, 0));
	NoReformat = noReformatWas;
	return (code);
d885 1
a885 1
	char	*in_line;
d887 20
a906 19
	char scratch[4096];
  	char *uname = NULL, *upass = NULL, *r;
	int opts;

	if (QiAuthDebug)
		fprintf(stderr, "DoLogin(%s)\n", in_line);
	strcpy(scratch, in_line);
	(void) strtok(scratch, DELIM);	/*the login part of the command */
	uname = strtok(NULL, DELIM); /* the username, if any  */
	if (uname)
		upass = strtok(NULL, DELIM); /* the password, if any  */
	opts = LQ_ALL|LQ_INTERACTIVE|((uname)?0:LQ_AUTO);
	if ((r = LoginQi(UseHost,ToQI,FromQI,opts,uname,upass)) != NULL) {
	  strcpy(MyAlias,r);
	  return LR_OK;
	} else {
	  *MyAlias = '\0';
	  return LR_ERROR;
	}
d914 1
a914 1
	char	*in_line;
d916 1
a916 1
	DoOther("quit\n");
d918 1
a918 1
	exit(SS$_NORMAL);
d920 1
a920 1
	exit(LastCode < LR_OK || LastCode >= LR_MORE ? LastCode / 100 : 0);
d929 1
a929 1
	char	*in_line;
d931 29
a959 32
	char	*field;
	char	*alias;
	char	*value;
	int	code = LR_OK;
	char	confirm[10];

	(void) strtok(in_line, DELIM);	/*skip ``edit'' */
	if (!(field = strtok((char *) 0, DELIM)))
	{
		(void) DoHelp("help edit\n");
		return (LR_ERROR);
	}
	if (!(alias = strtok((char *) 0, DELIM)))
		alias = MyAlias;

	if ((value = GetValue(alias, field)) && EditValue(value))
	{
		for (code = UpdateValue(alias, field, value);
		     400 <= code && code <= 499;
		     code = UpdateValue(alias, field, value))
		{
			if (!isatty(0))
				break;
			printf("Shall I try again [y/n]? ");
			fgets(confirm, sizeof (confirm), stdin);
			if (*confirm != 'y' && *confirm != 'Y')
				break;
		}
		if (code < 300 && !strcmp(field, "alias"))
			strcpy(MyAlias, value);
	}
	return (code);
d967 1
a967 1
	char *alias, *field;
d969 30
a998 33
	static char value[MAXVAL];	/*will hold the value */
	char	*vSpot;
	char	scratch[MAXSTR];
	int	code;

	if (!strcmp(field, "password"))
	{
		puts("Use the ``password'' command, not edit.");
		return (NULL);
	}
	/*do the query */
	if (Debug)
		fprintf(stderr, "sent=query alias=%s return %s\n", alias, field);
	qprintf(ToQI, "query alias=%s return %s\n", alias, field);
	qflush(ToQI);

	*value = '\0';

	/*read qi response lines, concatenating the responses into one value */
	for (vSpot = value;; vSpot += strlen(vSpot))
	{
		if (!GetGood(scratch, MAXSTR, FromQI))
		{
			fprintf(stderr, "Ding-dong the server's dead!\n");
			exit(0);
		}
		if ((code = atoi(scratch)) == -LR_OK)
			strcpy(vSpot, strchr(GetQValue(scratch), ':') + 2);	/*part of value */
		else if (code >= LR_OK)
			break;	/*final response */
		else
			fputs(scratch, stdout); /*??? */
	}
d1000 2
a1001 2
	if (code != LR_OK)	/*error */
		fputs(scratch, stdout);
d1003 1
a1003 1
	return (code == LR_OK ? value : NULL);
d1011 1
a1011 1
	char	*value;	/*the value to edit */
d1013 1
a1013 1
	char	*fname;	/*name of temp file to use */
d1016 3
a1018 3
	struct dsc$descriptor_s cli_input;
	char	template[28], f1[28], f2[28], edit_command[64];
	int	istat;
d1021 1
a1021 1
	char	template[20];
d1024 6
a1029 6
	int	fd;		/*file descriptor for temp file */
	static char nvalue[MAXVAL];	/*new value */
	char	*editor;	/*editor program to use */
	int	bytes;		/*number of bytes in file */
	char *from, *to;
	int	badc;		/*did we find a bad character? */
d1032 1
a1032 1
	int	junk;
d1035 1
a1035 1
	union wait junk;
d1038 1
a1038 1
	char	scratch[80];
d1040 1
a1040 1
	/*put the value into a temp file */
d1042 7
a1048 7
	strcpy(template, "SYS$SCRATCH:PHXXXXXX.TMP");
	fname = mktemp(template);
	strcpy(f1, fname);
	strcpy(f2, fname);
	strcat(f1, ";1");	/*versions needed for delete function */
	strcat(f2, ";2");
	if ((fd = creat(fname, 0)) < 0)
d1050 10
a1059 14
	strcpy(template, "/tmp/phXXXXXX");
	fname = mktemp(template);
	if ((fd = open(fname, O_RDWR | O_CREAT, 0777)) < 0)
#endif
	{
		perror(fname);
		return (0);
	}
	if (write(fd, value, strlen(value)) < 0)
	{
		perror(fname);
		(void) close(fd);
		return (0);
	}
d1061 3
d1065 1
a1065 1
	/*run an editor on the temp file */
d1067 2
a1068 2
	if (!(editor = getenv("EDITOR")))
		editor = "EDIT/EDT";
d1070 35
a1104 40
	strcpy(edit_command, editor);
	strcat(edit_command, " ");
	strcat(edit_command, fname);
	cli_input.dsc$w_length = strlen(edit_command);	/*descriptor for spawn */
	cli_input.dsc$a_pointer = edit_command;
	cli_input.dsc$b_class = DSC$K_CLASS_S;
	cli_input.dsc$b_dtype = DSC$K_DTYPE_T;

	if ((istat = LIB$SPAWN(&cli_input)) != SS$_NORMAL)
	{
		(void) delete(f1);
		exit(istat);
	}
#else
	if (!(editor = getenv("EDITOR")))
		editor = "vi";
	if (fork())
		(void) wait(&junk);
	else
	{
		(void) execlp(editor, editor, fname, NULL);
		fprintf(stderr, "Whoops!  Failed to exec %s\n", editor);
		exit(1);
	}
#endif

	/*does the user want the value? */
	if (Confirm)
	{
		do
		{
			printf("Change the value [y]? ");
			gets(scratch);
		}
		while (*scratch && !strchr("yYnN", *scratch));
	}
	/*read the value back out */
	if ((fd = open(fname, 0)) < 0)
	{
		perror(fname);
d1107 1
a1107 1
		(void) unlink(fname);
d1109 2
a1110 2
		return (0);
	}
d1113 1
a1113 1
	(void) unlink(fname);
d1116 3
a1118 4
	if ((bytes = read(fd, nvalue, MAXSTR - 1)) < 0)
	{
		perror(fname);
		(void) close(fd);
d1120 2
a1121 2
		(void) delete(f1);	/*delete 1st temp file */
		(void) delete(f2);	/*delete 2nd temp file */
d1123 3
a1125 3
		return (0);
	}
	(void) close(fd);
d1127 2
a1128 2
	(void) delete(f1);	/*delete 1st temp file */
	(void) delete(f2);	/*delete 2nd temp file */
d1130 6
a1135 1
	nvalue[bytes] = 0;
d1137 18
a1154 35
	/*did the value change? */
	if (Confirm && *scratch && *scratch != 'y' && *scratch != 'Y' ||
	    !strcmp(nvalue, value))
		return (0);

	/*copy new value into old, stripping bad characters */
	badc = 0;
	for (to = value, from = nvalue; *from; from++)
		if (*from == '"')
		{
			*to++ = '\\';
			*to++ = '"';
		} else if (*from >= ' ' && *from <= '~')
			*to++ = *from;
		else if (*from == '\t')
		{
			*to++ = '\\';
			*to++ = 't';
		} else if (*from == '\n')
		{
			if (*(from + 1))	/*skip terminating newline from vi */
			{
				*to++ = '\\';
				*to++ = 'n';
			}
		} else
			badc = 1;

	*to = 0;

	if (badc)		/*complain if we found bad characters */
	{
		fputs("Illegal characters were found in your value.\n", stderr);
		fputs("Please use only printable characters, newlines, and tabs.\n", stderr);
		fputs("The offending characters were removed.\n", stderr);
d1156 11
a1166 1
	return (1);
d1174 1
a1174 1
	char *alias, *field, *value;
d1176 4
a1179 4
	if (Debug)
		fprintf(stderr, "sent=change alias=%s make %s=\"%s\"\n", alias, field, value);
	qprintf(ToQI, "change alias=%s make %s=\"%s\"\n", alias, field, value);
	qflush(ToQI);
d1181 1
a1181 1
	return (PrintResponse(0));
d1190 1
a1190 1
	char	*in_line;
d1192 7
a1198 8
	if (!*MyAlias)
	{
		return (DoHelp("help me"));
	}
	if (Debug)
		fprintf(stderr, "sent=query alias=%s return all\n", MyAlias);
	qprintf(ToQI, "query alias=%s return all\n", MyAlias);
	qflush(ToQI);
d1200 1
a1200 1
	return (NoBeautify ? PrintResponse(0) : PrintQResponse(0, 0));
d1208 1
a1208 1
	char	*in_line;
d1210 41
a1250 42
	in_line = strtok(in_line, DELIM);
	if (!OptionLine(strtok(0, "\n")))
	{
		printf("The following things can be changed with \"switch\":\n\n");
		printf("  Paging is %s; use \"switch -%c\" to turn it %s.\n",
		       NoPager ? "OFF" : "ON",
		       NoPager ? 'M' : 'm',
		       NoPager ? "on" : "off");
		printf("  Email reformatting is %s; use \"switch -%c\" to turn it %s.\n",
		       NoReformat ? "OFF" : "ON",
		       NoReformat ? 'R' : 'r',
		       NoReformat ? "on" : "off");
		printf("  Query beautification is %s; use \"switch -%c\" to turn it %s.\n",
		       NoBeautify ? "OFF" : "ON",
		       NoBeautify ? 'B' : 'b',
		       NoBeautify ? "on" : "off");
		printf("  Label printing is %s; use \"switch -%c\" to turn it %s.\n",
		       NoLabels ? "OFF" : "ON",
		       NoLabels ? 'L' : 'l',
		       NoLabels ? "on" : "off");
		printf("  Edit confirmation is %s; use \"switch -%c\" to turn it %s.\n",
		       Confirm ? "ON" : "OFF",
		       Confirm ? 'c' : 'C',
		       Confirm ? "off" : "on");
		printf("  Default entry type is %s; use \"switch -%c%s\" to %s %s.\n",
		       DefType ? DefType : "OFF",
		       DefType ? 'T' : 't',
		       DefType ? "" : " name-of-type",
		       DefType ? "turn it" : "set it to",
		       DefType ? "off" : "\"name-of-type\"");
		printf("  Default field list is %s; use \"switch -%c%s\" to %s to %s.\n",
		       ReturnFields ? ReturnFields : "default",
		       ReturnFields ? 'F' : 'f',
		       ReturnFields ? "" : " field1,field2,... ",
		       ReturnFields ? "revert" : "set it",
		       ReturnFields ? "default" : "\"field1,field2,...\"");
		printf("\nThe following things cannot be changed with \"switch\":\n\n");
		printf("  Connected to server %s at port %d\n", UseHost, UsePort);
		printf("  The .netrc file was %sread.\n", NoNetrc ? "not " : "");
		printf("  The -h switch is meaningless in interactive mode.\n");
	}
	return (LR_OK);
d1258 1
a1258 1
	char	*in_line;
d1260 2
a1261 2
	int	code = LR_ERROR;
	char	*token;
d1263 23
a1285 15
	if (!*MyAlias)
		DoHelp("help make");
	else
	{
		char scratch[MAXSTR];

		(void) strcpy(scratch, in_line);
		for (token = strtok(scratch, " \n"); token;
		     token = strtok(0, " \n"))
		{
			if (!strncmp(token, "password=", 9))
			{
				printf("Use the ``password'' command, not make.\n");
				return (LR_OK);
			}
d1287 2
a1288 14
		if (Debug)
			fprintf(stderr, "sent=change alias=%s %s", MyAlias, in_line);
		qprintf(ToQI, "change alias=%s %s", MyAlias, in_line);
		qflush(ToQI);
		code = PrintResponse(0);
		if (code < 300)
			for (token = strtok(in_line, " \n"); token; token = strtok(0, " \n"))
				if (!strncmp(token, "alias=", 6))
				{
					strcpy(MyAlias, token + 6);
					break;
				}
	}
	return (code);
d1296 1
a1296 1
	char	*in_line;
d1298 17
a1314 18
	int	code = LR_ERROR;
	struct passwd *pw;
	char	hostname[MAXHOSTNAMELEN];

	if (!*MyAlias)
		DoHelp("help register");
	else if ((pw = getpwuid(getuid())) && !gethostname(hostname, sizeof (hostname))
		 && strcmp(pw->pw_name, "phones"))
	{
		if (Debug)
			fprintf(stderr, "sent=change alias=%s make email=%s@@%s\n",
				MyAlias, pw->pw_name, hostname);
		qprintf(ToQI, "change alias=%s make email=%s@@%s\n",
			MyAlias, pw->pw_name, hostname);
		qflush(ToQI);
		code = PrintResponse(0);
	}
	return (code);
d1322 1
a1322 1
	char	*in_line;
d1324 33
a1356 37
	char	password[80];
	char	*confirm;
	char	*alias;
	int	code = LR_ERROR;

	if (!*MyAlias)
	{
		return (DoHelp("help password"));
	}
	/*which alias to use? */
	(void) strtok(in_line, DELIM);
	if (!(alias = strtok((char *) 0, DELIM)))
		alias = MyAlias;

	/*get the password */
	strcpy(password, getpass("Enter new password: "));
	if (!*password)
		return (LR_ERROR);
	confirm = getpass("Type it again: ");
	if (strlen(password) > PH_PW_LEN)
		*(password + PH_PW_LEN) = '\0';
	if (strlen(confirm) > PH_PW_LEN)
			*(confirm + PH_PW_LEN) = '\0';
	if (strcmp(confirm, password))
	{
		fprintf(stderr, "Sorry--passwords didn't match.\n");
		return (code);
	}
	VetPassword(confirm);	/*complain if we don't like the password */

	/*encrypt and send the password */
	if (!LocalPort)
		password[encryptit(password, confirm)] = '\0';
	if (Debug)
		fprintf(stderr, "sent=change alias=%s %s password=%s\n", alias,
			LocalPort ? "force" : "make", password);
	qprintf(ToQI, "change alias=%s %s password=%s\n", alias,
d1358 3
a1360 1
	qflush(ToQI);
d1362 2
a1363 2
	/*see what the nameserver says */
	if ((code = PrintResponse(0)) == LR_OK && !strcmp(alias, MyAlias))
d1365 1
a1365 1
		crypt_start(crypt(confirm,confirm));
d1367 1
a1367 1
		crypt_start(confirm);
d1369 1
a1369 1
	return (code);
d1377 1
a1377 1
	char	*pass;
d1379 3
a1381 3
	if (strlen(pass) < 5 ||	/*too short */
	    AllDigits(pass))	/*digits only */
		fputs("That is an insecure password; please change it.\n", stderr);
d1389 1
a1389 1
	char *str;
d1391 4
a1394 4
	for (; *str; str++)
		if (!isdigit(*str))
			return (0);
	return (1);
d1402 1
a1402 1
	char	*in_line;
d1404 2
a1405 2
	*MyAlias = '\0';
	return (LogoutQi(ToQI,FromQI));
d1414 3
a1416 2
	int	ref_email;
	int	help;
d1418 19
a1436 21
	char	line[MAXSTR];
	int	code = LR_ERROR;
	int	CurPerson = 0;
	int	person;
	char *cp;
	FILE	*out;
	char	alias[MAXSTR];
	char	email[MAXSTR];
	int	copiedEmail = 0;

	out = OpenPager(1);

	*alias = *email = 0;	/*haven't found an alias yet */
	if (NoReformat || !MailDomain)
		ref_email = 0;
	/*get the response */
	while (GetGood(line, MAXSTR, FromQI))
	{
		code = atoi(line);
		if (code == LR_NUMRET)
		{
d1438 35
a1472 65
			cp = strchr(line, ':');
			if (cp != 0)
				fprintf(out, "\n%s\n", cp + 1);	/*strchr returns pointer to : then add one */
#endif /*MACC*/
		} else if (code == -LR_OK || code == -LR_AINFO || code == -LR_ABSENT
			   || code == -LR_ISCRYPT)
		{
			person = atoi(strchr(line, ':') + 1);
			/*output a delimiter */
			if (person != CurPerson)
			{
				if (*alias && !*email)
					NotRegisteredLine(alias, out);
				else if (*email)
				{
					EmailLine(email, alias);
					fputs(GetQValue(email), out);
					*email = 0;
				}
				fputs("----------------------------------------\n", out);
				CurPerson = person;
				copiedEmail = 0;
			}
			if (ref_email)
			{
				cp = GetQValue(line);
				while (*cp && *cp == ' ')
					cp++;
				if (!strncmp("alias", cp, 5))
				{
					copiedEmail = 0;
					strcpy(alias, line);
					continue;
				} else if (!strncmp("email", cp, 5))
				{
					strcpy(email, line);
					copiedEmail = 1;
					continue;
				} else if (*cp == ':' && copiedEmail)
					continue;
				else
					copiedEmail = 0;
			}
			/*output the line */
			if (NoLabels && !help)
				fputs(strchr(GetQValue(line), ':') + 2, out);
			else
				fputs(GetQValue(line), out);
		} else if (code != LR_OK)
			fputs(line, out);	/*error */

		if (code >= LR_OK)
		{
			if (*alias && !*email)
				NotRegisteredLine(alias, out);
			else if (*email)
			{
				EmailLine(email, alias);
				/*output the line */
				if (NoLabels && !help)
					fputs(strchr(GetQValue(email), ':') + 2, out);
				else
					fputs(GetQValue(email), out);
			}
			break;
d1474 26
d1501 1
d1503 3
a1505 3
	/*final "delimiter" */
	if (CurPerson)
		fputs("----------------------------------------\n", out);
d1509 2
a1510 2
	if (out != stdout)
		(void) pclose(out);
d1513 1
a1513 1
	return (code);
d1527 1
a1527 1
char	*
d1529 3
a1531 2
	char	*s1;
	const char *s2;
d1533 2
a1534 2
	static char *old = 0;
	char	*p1, *p2;
d1536 19
a1554 19
	if (!(s1 || old))
		return (NULL);
	p1 = (s1 ? s1 : old);
	while (*p1 && (strchr(s2, *p1) != NULL))
		p1++;
	if (*p1)
	{
		p2 = p1;
		while (*p2 && (strchr(s2, *p2) == NULL))
			p2++;
		if (*p2)
		{
			*p2 = '\0';
			old = ++p2;
		} else
			old = 0;
		return (p1);
	} else
		return (NULL);
d1569 1
a1569 1
	INT32	*characteristic, *state;
d1571 29
a1599 41
	int	status;
	INT32	efn;
	INT32	new_state;
	short	term_chan;
	struct char_buff mode;
	struct mode_iosb term_iosb;

	$DESCRIPTOR(term_desc, "TT:");

	/*get event flag */
	status = lib$get_ef(&efn);
	if (status != SS$_NORMAL)
		return (status);

	/*get channel to terminal */
	status = sys$assign(&term_desc, &term_chan, 0, 0);
	if (status != SS$_NORMAL)
		return (status);

	/*if characteristic is BROADCAST, ECHO, or TYPEAHEAD, state must be toggled */
	if (*characteristic == BROADCAST || *characteristic == ECHO || *characteristic == TYPEAHEAD)
		new_state = !(*state);
	else
		new_state = *state;

	/*get current mode */
	status = sys$qiow(efn, term_chan, IO$_SENSEMODE, &term_iosb, 0, 0, &mode, 12, 0, 0, 0, 0);
	if (status != SS$_NORMAL || term_iosb.stat != SS$_NORMAL)
	{
		sys$dassgn(term_chan);
		return (status);
	}
	/*change characteristics buffer */
	if (new_state == ON)
		mode.basic_char |= *characteristic;
	else
		mode.basic_char &= ~(*characteristic);

	/*$ SET TERM/...  and then deassign channel */
	status = sys$qiow(efn, term_chan, IO$_SETMODE, &term_iosb, 0, 0, &mode, 12, 0, 0, 0, 0);

d1601 18
a1618 6
	lib$free_ef(&efn);

	if (status != SS$_NORMAL)
		return (status);
	else
		return (term_iosb.stat);
d1626 1
a1626 1
char	*
d1628 1
a1628 1
	char	*prompt;
d1631 13
a1643 13
	static char line[12];
	static int echo =
	{ECHO},	off =
	{OFF},	on =
	{ON};

	printf(prompt);
	(void) fflush(stdout);	/*prompt */
	setterm(&echo, &off);
	gets(line);
	setterm(&echo, &on);
	puts("");
	return (line);
d1654 2
a1655 2
  	char *r;
	int opts = LQ_ALL|LQ_AUTO;
d1657 4
a1660 4
	if ((r = LoginQi(UseHost,ToQI,FromQI,opts,NULL,NULL)) != NULL)
	  strcpy(MyAlias,r);
	else
	  *MyAlias = '\0';
d1668 1
a1668 1
	char	*in_line;
d1670 2
a1671 2
	char	scratch[256];
	char	*token;
d1673 18
a1690 20
	if (*in_line == '?')
	{
		/*
		 * avoid bug for lone ?
		 */
		sprintf(scratch, "help %s", in_line + 1);
		strcpy(in_line, scratch);
	} else
		strcpy(scratch, in_line);
	token = strtok(scratch + 4, DELIM);	/*the word after help */
	if (token && !strcmp(token, "native"))	/*looking for native help */
		strcpy(scratch, in_line);	/*leave the command alone */
	else
		sprintf(scratch, "help %s %s", CLIENT, in_line + 4);	/*insert identifier */

	if (Debug)
		fprintf(stderr, "sent=%s", scratch);	/*send command */
	qprintf(ToQI, "%s", scratch);	/*send command */
	qflush(ToQI);
	return (NoBeautify ? PrintResponse(0) : PrintQResponse(0, 1));
d1699 1
a1699 1
	char	*email, *alias;
d1701 17
a1717 20
	char	scratch[MAXSTR];
	char	*emSpot;	/*beginning of email account */
	char	*alSpot;	/*beginning of nameserver alias */

	if (*alias)
	{
		emSpot = (char *)strchr(GetQValue(email), ':') + 2;
		alSpot = (char *)strchr(GetQValue(alias), ':') + 2;
		*(char *)strchr(alSpot, '\n') = 0;
		*(char *)strchr(emSpot, '\n') = 0;
		/*
		 * overwrite the email label
		 */
		strcpy(alSpot - 2 - strlen("email to"), "email to");
		alSpot[-2] = ':';	/*strcpy clobbered the colon; repair */
		sprintf(scratch, "@@%s (%s)\n", MailDomain, emSpot);
		strcat(alias, scratch);
		strcpy(email, alias);	/*leave it in the "email" line */
		*alias = 0;	/*we're done with the alias */
	}
d1725 3
a1727 2
	char	*alias;
	FILE	*out;
d1729 2
a1730 2
	char	scratch[MAXSTR];
	char *cp;
d1732 12
a1743 12
	strcpy(scratch, alias);
	cp = (char *)strchr(GetQValue(scratch), ':');
	strcpy(cp - 7, "email");
	cp[-2] = ':';
	strcpy(cp, "no account registered\n");
	EmailLine(scratch, alias);
	/*output the line */
	if (NoLabels)
		fputs(strchr(GetQValue(scratch), ':') + 2, out);
	else
		fputs(GetQValue(scratch), out);
	*alias = 0;		/*done with alias */
d1751 3
a1753 2
	int	argc;
	char	**argv;
d1755 1
a1755 1
	int	count = 0;
d1757 121
a1877 138
	/*
	 * options processing
	 */
	for (; argc && **argv == '-'; argc--, argv++, count++)
	{
		for ((*argv)++; **argv; (*argv)++)
		{
			switch (**argv)
			{
			case 'q':
				Quiet = 1;
				break;
			case 'r':
				NoReformat = 1;
				break;
			case 'R':
				NoReformat = 0;
				break;
			case 'n':
				NoNetrc = 1;
				break;
			case 'N':
				NoNetrc = 0;
				break;
			case 'm':
				NoPager = 1;
				break;
			case 'M':
				NoPager = 0;
				break;
			case 'b':
				NoBeautify = 1;
				break;
			case 'B':
				NoBeautify = 0;
				break;
			case 'D':
				QiDebug++;
				Debug++;
				QiAuthDebug++;
				break;
			case 'l':
				NoLabels = 1;
				break;
			case 'L':
				NoLabels = 0;
				break;
			case 'C':
				Confirm = 1;
				break;
			case 'c':
				Confirm = 0;
				break;
			case 'H':
				JustHelp = 0;
				break;
			case 'h':
				JustHelp = 1;
				break;
			case 's':
				if (argv[0][1])
				{
					if (UseHost)
						free(UseHost);
					UseHost = strdup(*argv + 1);
					MailDomain = NULL;
					goto whilebottom;
				} else if (argc > 1)
				{
					if (UseHost)
						free(UseHost);
					UseHost = strdup(argv[1]);
					argc--, argv++, count++;
					MailDomain = NULL;
					goto whilebottom;
				} else
					fprintf(stderr, "-%c option given without server hostname.\n", **argv);
				break;
			case 't':
				if (argv[0][1])
				{
					if (DefType)
						free(DefType);
					DefType = strdup(*argv + 1);
					goto whilebottom;
				} else if (argc > 1)
				{
					if (DefType)
						free(DefType);
					DefType = strdup(argv[1]);
					argc--, argv++, count++;
					goto whilebottom;
				} else
					fprintf(stderr, "-%t option given without entry type.\n", **argv);
				break;
			case 'f':
				if (argv[0][1])
				{
					if (ReturnFields)
						free(ReturnFields);
					ReturnFields = strdup(*argv + 1);
					goto whilebottom;
				} else if (argc > 1)
				{
					if (ReturnFields)
						free(ReturnFields);
					ReturnFields = strdup(argv[1]);
					argc--, argv++, count++;
					goto whilebottom;
				} else
					fprintf(stderr, "-%t option given without field list.\n", **argv);
				break;
			case 'F':
				if (ReturnFields)
					free(ReturnFields);
				ReturnFields = 0;
				break;
			case 'T':
				if (DefType)
					free(DefType);
				DefType = 0;
				break;
			case 'p':
				if (isdigit(argv[0][1]))
				{
					UsePort = atoi(*argv + 1);
					goto whilebottom;
				} else if (argc > 1 && isdigit(*argv[1]))
				{
					UsePort = atoi(argv[1]);
					argc--, argv++, count++;
					goto whilebottom;
				} else
					fprintf(stderr, "-%c option given without port number.\n", **argv);
				break;
			default:
				fprintf(stderr, "Unknown option: -%c.\n", **argv);
			}
d1879 15
a1893 3
	      whilebottom:;
	}
	return (count);
d1901 1
a1901 1
	char	*line;
d1903 3
a1905 3
	int	argc;
	char	*argv[MAXARGS];
	char	*token;
d1907 2
a1908 2
	if (!line || !*line)
		return (0);
d1910 3
a1912 3
	for (argc = 0, token = strtok(line, DELIM); token; argc++, token = strtok(0, DELIM))
		argv[argc] = token;
	argv[argc] = 0;
d1914 1
a1914 1
	return (ProcessOptions(argc, argv));
d1920 1
a1920 1
FILE	*
d1922 1
a1922 1
	int	pager;
d1924 2
a1925 2
	char	*pname;
	FILE	*out;
d1928 1
a1928 1
	return (stdout);	/*simpler to skip paging for right now */
d1930 8
a1937 9
	if (NoPager || pager != 1)
		return (stdout);
	else
	{
		if ((pname = getenv("PAGER")) == NULL)
			pname = PAGER;
		if ((out = popen(pname, "w")) == NULL)
			out = stdout;
		return (out);
d1939 1
a1939 1
	}
d1945 1
a1945 1
char	*
d1947 1
a1947 1
	char *string, *sub;
d1949 1
a1949 1
	int	len;
d1951 5
a1955 5
	len = strlen(sub);
	for (; *string; string++)
		if (!strncmp(string, sub, len))
			return (string);
	return (0);
d1963 1
a1963 1
	char	*name;
d1965 2
a1966 2
	char	buffer[80];
	char *np, *bp;
d1968 4
a1971 4
	for (np = name, bp = buffer; *np; np++, bp++)
		*bp = islower(*np) ? toupper(*np) : *np;
	*bp = 0;
	(void) OptionLine(getenv(buffer));
d1980 1
a1980 1
	char	*dot;
d1982 1
a1982 1
	unsigned INT32 addr = 0;
d1984 10
a1993 11
	do
	{
		addr <<= 8;
		addr |= atoi(dot);
		while (isdigit(*dot))
			dot++;
		if (*dot)
			dot++;
	}
	while (*dot);
	return ((unsigned INT32) htonl(addr));
@


7.2
log
@Minor changes to RCS strings.
@
text
@d38 2
a39 2
static char  rcsid[] = "@@(#)$Id: ph.c,v 7.1 1995/06/09 03:27:04 p-pomes Exp p-pomes $";
static char  rcsrev[] = "100:Ph client $Revision$";
d1427 1
d1429 3
@


7.1
log
@Time for a new major revision to.
@
text
@d38 2
a39 2
static char  rcsid[] = "@@(#)$Id: ph.c,v 6.23 1995/06/07 19:14:09 p-pomes Exp p-pomes $";
static char  rcsrev[] = "100:$Rev";
d302 1
a302 1
int 
d400 1
a400 1
int 
d527 1
a527 1
int 
d554 1
a554 1
int 
d597 1
a597 1
int 
d627 1
a627 1
void 
d639 1
a639 1
void 
d698 1
a698 1
void 
d763 1
a763 1
int 
d811 1
a811 1
int 
d825 1
a825 1
int 
d837 1
a837 1
int 
d865 1
a865 1
int 
d923 1
a923 1
int 
d951 1
a951 1
int 
d966 1
a966 1
int 
d1054 1
a1054 1
int 
d1226 1
a1226 1
int 
d1242 1
a1242 1
int 
d1261 1
a1261 1
int 
d1312 1
a1312 1
int 
d1354 1
a1354 1
int 
d1381 1
a1381 1
int 
d1434 1
a1434 1
void 
d1446 1
a1446 1
int 
d1459 1
a1459 1
int 
d1471 1
a1471 1
int 
d1713 1
a1713 1
void 
d1728 1
a1728 1
int 
d1761 1
a1761 1
void 
d1790 1
a1790 1
void 
d1815 1
a1815 1
int 
d2032 1
a2032 1
void 
d2049 1
a2049 1
unsigned INT32 
@


6.23
log
@another checkpoint
@
text
@d38 2
a39 1
static char  rcsid[] = "@@(#)$Id: ph.c,v 6.22 1995/03/03 01:06:09 p-pomes Exp p-pomes $";
d706 1
a706 1
		puts(rcsid);
@


6.22
log
@checkpoint
@
text
@d38 1
a38 1
static char  rcsid[] = "@@(#)$Id: ph.c,v 6.21 1995/03/01 21:34:23 p-pomes Exp p-pomes $";
d1426 1
a1426 1
		crypt_start(confirm);
@


6.21
log
@development checkpoint
@
text
@d38 1
a38 1
static char  rcsid[] = "@@(#)$Id: ph.c,v 6.20 1994/11/18 16:11:30 p-pomes Exp p-pomes $";
a179 1
char	*makestr __P((char *));
d513 1
a513 1
	UseHost = makestr(hp ? hp->h_name : inet_ntoa(QI.sin_addr));
d578 1
a578 1
						MailDomain = makestr(lastc);
d927 1
a927 1
  	char *uname, *upass, *r;
d930 2
d1885 1
a1885 1
					UseHost = makestr(*argv + 1);
d1892 1
a1892 1
					UseHost = makestr(argv[1]);
d1904 1
a1904 1
					DefType = makestr(*argv + 1);
d1910 1
a1910 1
					DefType = makestr(argv[1]);
d1921 1
a1921 1
					ReturnFields = makestr(*argv + 1);
d1927 1
a1927 1
					ReturnFields = makestr(argv[1]);
a2009 16
}

/*
 * makestr - make a copy of a string in malloc-space
 */
char	*
makestr(str)
	char	*str;
{
	char	*copy;
	int	len;

	len = strlen(str);
	if (copy = malloc(len + 1))
		strcpy(copy, str);
	return (copy);
@


6.20
log
@*** empty log message ***
@
text
@d38 1
a38 1
static char  rcsid[] = "@@(#)$Id: ph.c,v 6.19 1994/11/11 21:34:38 p-pomes Exp p-pomes $";
d144 1
a144 1
#ifdef KERBEROS
d146 3
a148 2
#include <des.h>
#include <krb.h>
d150 1
a150 2
extern int krb_debug;
#endif /* KERBEROS */
d238 4
d247 1
a248 1
#endif
d1859 1
a1859 3
#ifdef KERBEROS
				krb_debug++;
#endif /* KERBEROS */
@


6.19
log
@Add -q switch to make ph look more like qi.  login command can now
take password as second argument.
@
text
@d38 1
a38 1
static char  rcsid[] = "@@(#)$Id: ph.c,v 6.18 1994/09/09 20:15:40 p-pomes Exp p-pomes $";
a104 1
/*
@


6.18
log
@OSF/1 V2.1 patches for DEC Alpha where longs are 64 bits.  Contributed
by Steve Madsen <smadsen@@cs.muohio.edu>.
@
text
@d38 1
a38 1
static char  rcsid[] = "@@(#)$Id: ph.c,v 6.17 1994/03/12 04:31:21 paul Exp p-pomes $";
d291 1
d702 2
a703 1
	puts(rcsid);
d708 2
a709 1
	LastCode = DoOther("status\n");
d719 2
a720 1
	puts("");
d725 2
d728 2
a729 2
		if (!maccecho)
			printf("%s> ", Me);
d731 1
a731 1
		printf("%s> ", Me);
d733 2
a734 1
		(void) fflush(stdout);	/*prompt */
d748 1
a748 1
		if (maccecho)
d925 1
a925 1
  	char *uname, *r;
d931 2
d934 1
a934 1
	if ((r = LoginQi(UseHost,ToQI,FromQI,opts,uname,NULL)) != NULL) {
d1826 3
@


6.17
log
@csnet-ns can't be made to work wither Kerberos.  Stick with ns for now.
@
text
@d38 1
a38 1
static char  rcsid[] = "@@(#)$Id: ph.c,v 6.16 1994/03/12 00:13:50 paul Exp paul $";
d41 6
d278 1
a278 1
unsigned long Dot2Addr();
d1617 1
a1617 1
	long	*characteristic, *state;
d1620 2
a1621 2
	long	efn;
	long	new_state;
d2050 1
a2050 1
unsigned long 
d2054 1
a2054 1
	unsigned long addr = 0;
d2066 1
a2066 1
	return ((unsigned long) htonl(addr));
@


6.16
log
@Added new copyright statement.
@
text
@d38 1
a38 1
static char  rcsid[] = "@@(#)$Id$";
d48 1
a48 1
 * csnet-ns     105/tcp     ns        # CSO nameserver
@


6.15
log
@GetGood() now in LoginQi.c
@
text
@d2 33
a34 5
 * This software is Copyright (C) 1988 by Steven Dorner and the
 * University of Illinois Board of Trustees, and by CSNET.  No warranties of
 * any kind are expressed or implied.  No support will be provided.
 * This software may not be redistributed without prior consent of CSNET.
 * You may direct questions to nameserv@@uiuc.edu
d36 5
d43 3
a45 6
 * the nameserver running on garcon.cso.uiuc.edu, and query it about
 * entries.  The following entries in /etc/hosts (if you're using one) and
 * /etc/services will help matters:
 *
 * /etc/hosts:
 * 128.174.5.58 garcon.cso.uiuc.edu garcon
d48 1
a48 1
 * ns     105/tcp     ns        # CSO nameserver
a120 2
static char *rcsid = "$Date: 1993/12/20 23:37:56 $$Revision: 6.14 $";
static char *srcid = "$Source: /usr/local/src/net/qi/ph/RCS/ph.c,v $";
@


6.14
log
@more casts.
@
text
@d91 1
a91 1
static char *rcsid = "$Date: 1993/12/20 23:30:32 $$Revision: 6.13 $";
a584 62
/*
 * get a non-comment line from a stream
 * a comment is a line beginning with a # sign
 */
int 
GetGood(str, maxc, fp)
	char	*str;		/*space to put the chars */
	int	maxc;		/*max # of chars we want */

#ifdef VMS
	int	fp;	/*stream to read them from */
{
	static char Qbuf[MAXSTR + 4] =
	{'\0'};
	static int pos =
	{0},	end =
	{0},	len =
	{0};
	char	*linp;

	for (;;)
	{
		if (pos >= len)
		{
			len = netread(fp, Qbuf, maxc);
			if (len <= 0)
				return (0);
			Qbuf[len] = '\0';
			pos = 0;
		}
		linp = strchr(Qbuf + pos, '\n'); /*find next newline char */
		if (linp == NULL)
			end = len;		/*no newline chars left */
		else
			end = linp - Qbuf;	/*convert pointer to index */

		strncpy(str, Qbuf + pos, end - pos + 1);
		*(str + end - pos + 1) = '\0';
		pos = end + 1;		/*save new position for next time */

		if (!*str)
#else
	FILE	*fp;			/*stream to read them from */
{
	errno = 0;
	for (;;)
	{
		if (! fgets(str, maxc, fp))
#endif
		{
			fputs("Oops; lost connection to server.\n", stderr);
			if (errno)
				perror("");
			exit(1);
		} else if (*str != '#')
		{
			if (Debug)
				fprintf(stderr, "read =%s", str);
			return (1);	/*not a comment; success! */
		}
	}
}
@


6.13
log
@*** empty log message ***
@
text
@d91 1
a91 1
static char *rcsid = "$Date: 1993/12/20 22:52:09 $$Revision: 6.12 $";
d287 1
a287 1
	Me = strrchr(*argv, '/');
d493 1
a493 1
	char	*cpnt = getlogin();
d532 1
a532 1
			if ((lastc = strrchr(scratch, ':')) && lastc > scratch)
d535 1
a535 1
				if (s2lastc = strrchr(scratch, ':'))
d1785 2
a1786 2
		emSpot = strchr(GetQValue(email), ':') + 2;
		alSpot = strchr(GetQValue(alias), ':') + 2;
d1813 1
a1813 1
	cp = strchr(GetQValue(scratch), ':');
@


6.12
log
@*** empty log message ***
@
text
@d91 1
a91 1
static char *rcsid = "$Date: 1993/12/16 23:03:42 $$Revision: 6.11 $";
a119 4

#ifdef NO_MEMMOVE
# define	memmove(a,b,c)	bcopy(b,a,c)
#endif
@


6.11
log
@Turn on krb_debug with -D as well.
@
text
@d91 2
a92 2
static char *rcsid = "$Date: 1993/11/24 22:30:54 $$Revision: 6.10 $";
static char *srcid = "$Source: /pub/unix/net/qi/ph/RCS/ph.c,v $";
d1791 2
a1792 2
		*strchr(alSpot, '\n') = 0;
		*strchr(emSpot, '\n') = 0;
@


6.10
log
@New Kerberos patches from Alan Crosswell <alan@@curta.cc.columbia.edu>.
@
text
@d91 2
a92 2
static char *rcsid = "$Date: 1993/11/24 18:06:49 $$Revision: 6.9 $";
static char *srcid = "$Source: /usr/local/src/net/qi/ph/RCS/ph.c,v $";
d115 2
d385 2
d1876 3
@


6.9
log
@*** empty log message ***
@
text
@a7 1

d91 1
a91 1
static char *rcsid = "$Date: 1993/11/19 20:11:17 $$Revision: 6.8 $";
a182 1
#ifndef KERBEROS
a185 1
#endif /* !KERBEROS */
a188 1
int	TryLogin __P((char *, char *));
a241 1
#ifndef KERBEROS
a242 1
#endif /* !KERBEROS */
a694 1
# ifndef KERBEROS
a696 1
# endif /* !KERBEROS */
d939 1
a939 1
 * execute a login request
a940 178
#ifdef KERBEROS
int
DoLogin(inputLine)
	char	*inputLine;
{
	struct sockaddr_in sin, lsin;
	int	status;
	int	sock = fileno(ToQI);
	int	namelen;
	KTEXT_ST ticket;
	long	authopts;
	MSG_DAT	msg_data;
	CREDENTIALS cred;
	Key_schedule sched;
	char	scratch[MAXSTR];
	char	principal[ANAME_SZ];
	char	instance[INST_SZ];
	char	realm[REALM_SZ];
	char	*username;
	int	code;
	char	krbtkfile[MAXPATHLEN];
	char	okrbtkfile[MAXPATHLEN];

	/* find out who I am */
	namelen = sizeof (lsin);
	if (getsockname(sock, (struct sockaddr *) & lsin, &namelen) < 0)
	{
		perror("getsockname");
		return (LR_ERROR);
	}

	/* find out who the other side is */
	namelen = sizeof (sin);
	if (getpeername(sock, (struct sockaddr *) & sin, &namelen) < 0)
	{
		perror("getpeername");
		return (LR_ERROR);
	}

	/* Did the user specify a username? */
	(void) strcpy(scratch, inputLine);
	(void) strtok(scratch, DELIM);
	username = strtok(0, DELIM);	/* If == NULL, usr didn't specify */

	/* If not, and if we're not logged in to kerberos, prompt for one. */
	if (!username)
	{
		struct stat dummy;

		if (stat(TKT_FILE, &dummy))
		{
			printf("Enter username: ");
			fgets(scratch, sizeof (scratch), stdin);
			if (!*scratch)
				return (LR_ERROR);
			else
			{
				/* zap newline*/
				scratch[strlen(scratch) - 1] = 0;
				username = scratch;
			}
		}
	}

	/* if we're not already logged in with kerberos */
	if (username)
	{
		status = kname_parse(principal, instance, realm, username);
		if (status != KSUCCESS)
		{
			fprintf(stderr, "%s\n", krb_err_txt[status]);
			return LR_ERROR;
		}
		if (!*realm && krb_get_lrealm(realm, 1))
		{
			fprintf(stderr, "Unable to get realm.\n");
			return LR_ERROR;
		}

		/* set tkt file we'll use */
		strcpy(okrbtkfile, TKT_FILE);
		sprintf(krbtkfile, "/tmp/tkt_ph_%d", getpid());
		krb_set_tkt_string(krbtkfile);

		/* login */
		status = krb_get_pw_in_tkt(principal, instance, realm,
					  "krbtgt", realm, 96, 0);
		if (status != KSUCCESS)
		{
			fprintf(stderr, "Kerberos login failed: %s\n",
				krb_err_txt[status]);
			if (username)
			{
				krb_set_tkt_string(okrbtkfile);
			}
			return LR_ERROR;
		}
	}
	if (Debug)
		fprintf(stderr, "sent=klogin\n");	/* send login request */
	qprintf(ToQI, "klogin\n");	/* send login request */
	qflush(ToQI);

	for (;;)		/* read the response */
	{
		if (!GetGood(scratch, MAXSTR, FromQI))
		{
			fprintf(stderr, "Whoops--the nameserver died.\n");
			if (username)
				dest_tkt();	/* destroy temp tickets for
					specified username */
			exit(1);
		}
		code = atoi(scratch);
		if (code != LR_LOGIN)	/* intermediate or strange response */
			fputs(scratch, stdout);
		if (code >= LR_OK)	/* final response */
			break;
	}

	if (code == LR_LOGIN)
	{
		/*
		 * call Kerberos library routine to obtain an authenticator,
		 * pass it over the socket to the server, and obtain mutual
		 * authentication.
		 */

		authopts = KOPT_DO_MUTUAL;
		status = krb_sendauth(authopts, sock, &ticket,
				     "ns", UseHost,
				     krb_realmofhost(UseHost),
				     0, &msg_data, &cred,
				     sched, &lsin, &sin, "VERSION9");
		if (status != KSUCCESS)
		{
			fprintf(stderr, "ph cannot authenticate to server: (%d) %s\n",
				status, krb_err_txt[status]);
			/* Server will return the error code we need to return,
			so don't return here */
		}
		if (username)
			dest_tkt();	/* destroy special tickets as soon as
					possible */

		/* get the final response */
		for (;;)
		{
			if (!GetGood(scratch, MAXSTR, FromQI))
			{
				fprintf(stderr, "Whoops--the nameserver died.\n");
				exit(1);
			}
			code = atoi(scratch);
			fputs(scratch, stdout);
			if (code >= LR_OK)	/* final response */
				break;
		}
	} else if (username)
		dest_tkt();

	if (username)
	{
		krb_set_tkt_string(okrbtkfile);
	}
	if (code == LR_OK)	/* logged in */
	{
		strcpy(MyAlias, strchr(scratch, ':') + 1);
#ifdef ultrix
		*((char *) strchr(MyAlias, ':')) = '\0';
#else /* not ULTRIX */
		*strchr(MyAlias, ':') = '\0';
#endif /* ULTRIX */
	} else
		*MyAlias = '\0';
	return (code);
}
#else /* !KERBEROS */
d945 3
a947 6
	char	encryptMe[MAXSTR];	/*string from nameserver */
	char	encrypted[MAXSTR];	/*string from ns, encrypted */
	char	*password;		/*user's nameserver password */
	int	code;
	int	expect = 0;		/* to handle servers w.o. email auth */
	char	scratch[MAXSTR];
d951 8
a958 99

	/* Quick, verify that crypt() is sane! */
	if (strcmp(crypt("fredfred", "fredfred"), "frxWbx4IRuBBA"))
	{
		fprintf(stderr, "Incompatible crypt() - check bit order in fcrypt.c\n");
		fprintf(stderr, "or recompile w.o.  #define crypt fcrypt  in qiapi.h\n");
		return (LR_ERROR);
	}
	if (!strtok(0, DELIM))	/*check for an alias */
	{
		printf("Enter nameserver alias: ");	/*ask for missing alias */
		fgets(scratch, sizeof (scratch), stdin);
		if (!*scratch)
			return (LR_ERROR);
		sprintf(in_line, "login %s", scratch);
	}
      tryagain:
	if (Debug)
		fprintf(stderr, "sent=%s", in_line); /*send login request */
	qprintf(ToQI, "%s", in_line); /*send login request */
	qflush(ToQI);

	for (;;)		/*read the response */
	{
		if (!GetGood(encryptMe, MAXSTR, FromQI))
		{
			fprintf(stderr, "Whoops--the nameserver died.\n");
			exit(1);
		}
		code = atoi(encryptMe);
		if (expect && code == -LR_NOANSWER)
			expect = 0;
		else if (code != LR_LOGIN) /*intermediate or strange response */
			fputs(encryptMe, stdout);
		if (code >= LR_OK)	/*final response */
			break;
	}

	if (code == LR_LOGIN)
	{
#ifdef EMAIL_AUTH
		/*the nameserver has issued a challenge */
		if (LocalPort)
		{
			if (Debug)
				fprintf(stderr, "sent=email %s\n", getpwuid(getuid())->pw_name);
			qprintf(ToQI, "email %s\n", getpwuid(getuid())->pw_name);
		}
		else
#endif
		{
			password = MyPassword ? MyPassword :
				getpass("Enter nameserver password: ");
			if (strlen(password) > PH_PW_LEN)
				*(password + PH_PW_LEN) = '\0';
			crypt_start(password);

			/*encrypt the challenge with the password */
			encryptMe[strlen(encryptMe) - 1] = '\0';	/*strip linefeed */
			encrypted[encryptit(encrypted, strchr(encryptMe, ':') + 1)] = '\0';

			/*send the encrypted text to qi */
			if (Debug)
				fprintf(stderr, "sent=answer %s\n", encrypted);
			qprintf(ToQI, "answer %s\n", encrypted);
		}
		qflush(ToQI);

		/*get the final response */
		for (;;)
		{
			if (!GetGood(encryptMe, MAXSTR, FromQI))
			{
				fprintf(stderr, "Whoops--the nameserver died.\n");
				exit(1);
			}
			code = atoi(encryptMe);
			if (code == LR_NOEMAIL)
			{
				LocalPort = 0;
				goto tryagain;
			}
			if (code == LR_NOCMD && LocalPort)
			{
				/*
				 * We have a local privileged port, but remote
				 * server isn't configured for it, so it didn't
				 * understand the "email" command we sent,
				 * so try again.
				 */
				LocalPort = 0;
				expect = 1;  /* since we're about to send login cmd again */
				goto tryagain;
			}

			fputs(encryptMe, stdout);
			if (code >= LR_OK)	/*final response */
				break;
		}
a959 9
	if (code == LR_OK)	/*logged in */
	{
		strcpy(MyAlias, strchr(encryptMe, ':') + 1);
		*strchr(MyAlias, ':') = '\0';
		if (!LocalPort)
			VetPassword(password);
	} else
		*MyAlias = '\0';
	return (code);
a960 1
#endif /* KERBEROS */
a1391 1
#ifndef KERBEROS
a1468 1
#endif /* !KERBEROS */
d1478 1
a1478 1
	return (DoOther(in_line));
d1730 2
a1731 7
	FILE	*netrc;		/*the .netrc file */
	char	path[1024];	/*pathname of .netrc file */
	struct stat statbuf;	/*permissions, etc. of .netrc file */
	char	key[80], val[80];	/*line from the .netrc file */
	char	*token;		/*token (word) from the line from the .netrc file */
	char	*alias = NULL;	/*the user's alias */
	char	*pw = NULL;	/*the user's password */
d1733 4
a1736 110
	/*
	 * manufacture the pathname of the user's .netrc file
	 */
	sprintf(path, "%s/.netrc", getenv("HOME"));

	/*
	 * make sure its permissions are ok
	 */
	if (stat(path, &statbuf) < 0)
		return;
	if (statbuf.st_mode & 077)
		return;		/*refuse insecure files */

	/*
	 * try to open it
	 */
	if (!(netrc = fopen(path, "r")))
		return;

	/*
	 * look for a ``machine'' named ``ph''
	 */
	while (2 == fscanf(netrc, "%s %s", key, val))
	{
		if (!strcmp(key, "machine") && !strcmp(val, CLIENT))
		{
			/*
			 * found an entry for ph.  look now for other items
			 */
			while (2 == fscanf(netrc, "%s %s", key, val))
			{
				if (!strcmp(key, "machine"))	/*new machine */
					goto out;
				else if (!strcmp(key, "login"))
					alias = strcpy(malloc((unsigned) strlen(val) + 1), val);
				else if (!strcmp(key, "password"))
					pw = strcpy(malloc((unsigned) strlen(val) + 1), val);
				else if (!strcmp(key, "macdef"))
					SkipMacdef(netrc);

			}
		} else if (!strcmp(key, "macdef"))
			SkipMacdef(netrc);
	}

      out:
	if (alias && (pw || LocalPort))
		TryLogin(alias, pw);
	if (alias)
		free(alias);
	if (pw)
		free(pw);
	return;
}

/*
 * skip a macdef in the .netrc file
 */
void 
SkipMacdef(netrc)
	FILE	*netrc;
{
	int	c, wasNl;

	for (wasNl = 0; (c = getc(netrc)) != EOF; wasNl = (c == '\n'))
		if (wasNl && c == '\n')
			break;
}

/*
 * try a login alias and password
 */
int 
TryLogin(alias, password)
	char *alias, *password;
{
	char	line[80];
	int	success;

	/*
	 * construct a login line
	 */
	sprintf(line, "login %s\n", alias);

#ifndef KERBEROS
	/*
	 * set our password
	 */
	MyPassword = password;
#endif /* !KERBEROS */

	/*
	 * try the login
	 */
	success = DoLogin(line);

#ifndef KERBEROS
	/*
	 * reset our password
	 */
	MyPassword = NULL;
	if (password)
		while (*password)
			*password++ = 'x';
#endif /* !KERBEROS */

	/*
	 * return our success (or failure)
	 */
	return (success);
a1738 1

d1870 2
a1871 1
				Debug = 1;
@


6.8
log
@Added crypt()/fcrypt() sanity test.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1993/10/06 20:26:52 $$Revision: 6.7 $";
d119 4
@


6.7
log
@UseHost should copy the result of a gethostbyname() since it points to static
data.
Reported by Alan Crosswell <alan@@curta.cc.columbia.edu>
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1993/07/21 22:09:42 $$Revision: 6.6 $";
d105 1
a105 1
#include <sys/fcntl.h>
d1136 8
@


6.6
log
@Posix'isms
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1993/06/22 13:41:41 $$Revision: 6.5 $";
d476 3
a478 1
	UseHost = hp ? hp->h_name : inet_ntoa(QI.sin_addr);
@


6.5
log
@Make sure passwords are PH_PW_LEN or less.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1993/06/16 14:17:21 $$Revision: 6.4 $";
a104 1
#ifdef SYSV
a105 1
#endif
a118 3
#ifdef _CRAY
#include <sys/fcntl.h>
#endif	/* _CRAY */
d131 3
d138 1
a138 3

#define index		strchr
#define rindex		strrchr
a140 4
#else	/* !VMS */

#define GetQValue(x)	(index(index(x,':')+1,':')+1)
#endif	/* VMS */
a197 7
# ifndef index
#  define index strchr
#  define rindex strrchr
# endif /* !index */
# ifndef bcopy
#  define bcopy(source,dest,count)	memcpy(dest,source,count)
# endif /* !bcopy */
d291 1
a291 1
	Me = rindex(*argv, '/');
d423 1
a423 1
			bcopy(hp->h_addr, (char *) &QI.sin_addr, 4);
d425 1
a425 1
			bcopy(hp->h_addr, (char *) &QI.sin_addr.s_addr, 4);
d532 1
a532 1
			if ((lastc = rindex(scratch, ':')) && lastc > scratch)
d535 1
a535 1
				if (s2lastc = rindex(scratch, ':'))
d615 1
a615 1
		linp = index(Qbuf + pos, '\n'); /*find next newline char */
d1110 1
a1110 1
		strcpy(MyAlias, index(scratch, ':') + 1);
d1112 1
a1112 1
		*((char *) index(MyAlias, ':')) = '\0';
d1114 1
a1114 1
		*index(MyAlias, ':') = '\0';
d1185 1
a1185 1
			encrypted[encryptit(encrypted, index(encryptMe, ':') + 1)] = '\0';
d1228 2
a1229 2
		strcpy(MyAlias, index(encryptMe, ':') + 1);
		*index(MyAlias, ':') = '\0';
d1328 1
a1328 1
			strcpy(vSpot, index(GetQValue(scratch), ':') + 2);	/*part of value */
d1440 1
a1440 1
		while (*scratch && !index("yYnN", *scratch));
d1797 1
a1797 1
			person = atoi(index(line, ':') + 1);
d1835 1
a1835 1
				fputs(index(GetQValue(line), ':') + 2, out);
d1850 1
a1850 1
					fputs(index(GetQValue(email), ':') + 2, out);
d1893 1
a1893 1
	while (*p1 && (index(s2, *p1) != NULL))
d1898 1
a1898 1
		while (*p2 && (index(s2, *p2) == NULL))
d2175 4
a2178 4
		emSpot = index(GetQValue(email), ':') + 2;
		alSpot = index(GetQValue(alias), ':') + 2;
		*index(alSpot, '\n') = 0;
		*index(emSpot, '\n') = 0;
d2203 1
a2203 1
	cp = index(GetQValue(scratch), ':');
d2210 1
a2210 1
		fputs(index(GetQValue(scratch), ':') + 2, out);
d2404 1
a2404 5
#ifdef SYSV
			pname = "pg";
#else /* !SYSV */
			pname = "more";
#endif /* SYSV */
@


6.4
log
@rresvport() doesn't want port numbers in network order after all. sigh.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1993/05/06 04:05:27 $$Revision: 6.3 $";
d1194 2
d1710 4
@


6.3
log
@Straighten out conversion of port numbers to network byte order.
Try and get real id of user.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1993/04/06 16:57:07 $$Revision: 6.2 $";
a95 1
#include <cdefs.h>
d120 1
a120 1
#include "replies.h"
d262 1
a262 1
int	Debug = 0;		/*local port in use */
a290 1
	short	port = htons(IPPORT_RESERVED - 1);
d424 1
a424 1
		LocalPort = htons(IPPORT_RESERVED - 1);
d458 1
a458 4
				{
					LocalPort = ntohs(LocalPort) - 1;
					LocalPort = htons(LocalPort);
				}
@


6.2
log
@Added debug 'D' option.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1993/04/03 19:36:46 $$Revision: 6.1 $";
d292 1
a292 1
	short	port = IPPORT_RESERVED - 1;
d408 1
a408 1
		QI.sin_port = UsePort;
d426 1
a426 1
		LocalPort = IPPORT_RESERVED - 1;
d460 4
a463 1
					LocalPort--;
d497 1
a497 1
	UsePort = QI.sin_port;
d513 2
d516 9
d526 2
a527 2
		fprintf(stderr, "sent=id %d\n", getuid());
	qprintf(ToQI, "id %d\n", getuid());
d2360 1
a2360 1
					UsePort = htons(atoi(*argv + 1));
d2364 1
a2364 1
					UsePort = htons(atoi(argv[1]));
@


6.1
log
@Force new version.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1993/04/03 19:35:45 $$Revision: 5.12 $";
d263 1
d367 2
d402 2
a403 2
		setgid(getgid());
		setuid(getuid());
d509 4
d515 2
a516 1
	return (PrintResponse(-1));
d529 2
d635 1
d642 2
d646 3
d650 1
d841 2
d855 2
d916 3
d920 1
d927 3
d931 1
d933 3
d937 1
d1047 2
d1149 2
d1175 3
d1179 1
d1192 2
d1316 2
d1524 2
d1544 2
d1629 2
d1661 3
d1709 3
d2154 2
d2258 3
@


5.12
log
@Added Brown University kerberos support.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1993/02/23 04:26:42 $$Revision: 5.11 $";
@


5.11
log
@Define bcopy as memcpy if __STDC__ is defined.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1992/12/18 15:32:38 $$Revision: 5.10 $";
d115 6
d188 2
a190 1
int	DoLogout __P((char *));
d193 1
d258 1
d260 1
d684 1
d687 1
d916 176
d1197 1
d1618 1
a1665 11
 * log out the current user
 */
int 
DoLogout(in_line)
	char	*in_line;
{
	*MyAlias = '\0';
	return (DoOther(in_line));
}

/*
d1689 12
d2043 1
d2048 1
d2055 1
d2063 1
@


5.10
log
@Eliminate fixed path names.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1992/12/08 20:19:39 $$Revision: 5.9 $";
a107 2
#define index strchr
#define rindex strrchr
a112 1
/* #define bcopy(source,dest,count)	memcpy(dest,source,count) */
d203 3
@


5.9
log
@Wrapped defines of index with test to see if they're already defined.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1992/11/15 19:43:16 $$Revision: 5.8 $";
d115 1
a115 4
#ifdef hpux
#include <memory.h>
#define bcopy(source,dest,count)	memcpy(dest,source,count)
#endif	/* hpux */
d1191 1
a1191 6
#if defined(hpux) || defined(sgi)
		editor = "/usr/bin/vi";
#else
		editor = "/usr/ucb/vi";
#endif

d2148 1
a2148 1
			pname = "/usr/bin/pg";
d2150 1
a2150 9
#ifdef hpux
			pname = "/usr/bin/more";
#else /* !hpux */
#ifdef sgi
			pname = "/usr/bsd/more";
#else /* !sgi */
			pname = "/usr/ucb/more";
#endif /* sgi */
#endif /* hpux */
@


5.8
log
@Date:    Fri, 13 Nov 1992 10:39:16 -0700
From:    "Mark Erikson" <merikson@@qualcomm.com>
Subject: ph bug

Ph was doing an fgets and falling into an infinite loop.  Fgets was
returning a NULL for EOF but it was checking str for the null pointer.
Fgets cannot modify the value of str so the check was invalid.  Since
changing this I have not seen a problem.

Mark
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1992/08/17 13:35:39 $$Revision: 5.7 $";
d205 5
a209 3
# define index strchr
# define rindex strrchr
#else
d214 1
a214 1
#endif
@


5.7
log
@Deleted extraneous newline, relocated index/strchr defines.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1992/08/11 15:48:46 $$Revision: 5.7 $";
d611 2
d618 1
a618 1
		(void) fgets(str, maxc, fp);
a619 1
		if (!*str)
@


5.6
log
@Some changes from the NWU version, other portability fixes.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1992/08/01 13:08:14 $$Revision: 5.11 $";
a117 2
#define index strchr
#define rindex strrchr
d205 2
d357 1
a357 1
		qprintf(ToQI, "\nquit\n");
@


5.5
log
@Handle case of setuid ph client and non EMAIL_AUTH configured server.  Patch
from John Sellens <jmsellen@@math.waterloo.edu>
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1992/07/27 19:41:02 $$Revision: 5.4 $";
a106 1
#include <string.h>
a109 2
#else
#include <strings.h>
d206 1
d208 4
a211 3
#define const
char	*getenv __P((char *));
char	*malloc __P((unsigned));
d256 1
a256 1
/************************************************************************
d258 1
a258 1
 ************************************************************************/
d387 7
d486 1
d655 1
a655 1
typedef struct command Command;
d663 1
a663 1
Command	CommandTable[] =
d700 1
d757 3
a759 3
/***********************************************************************
* look at input line, and if we have a specific command for it, do it
***********************************************************************/
d766 2
a767 2
	Command *cmd;		/*the command name */
	Command *doMe;
d1066 4
a1069 4
/***********************************************************************
* get the value of a field from the nameserver
***********************************************************************/
char	*
d1071 1
a1071 2
	char	*alias;
	char	*field;
d1111 3
a1113 3
/***********************************************************************
* Edit a value
***********************************************************************/
d1191 1
a1191 1
#ifdef hpux
d1293 1
a1293 3
	char	*alias;
	char	*field;
	char	*value;
d1377 1
a1377 1
	int	 code = LR_ERROR;
d1384 12
d1495 2
a1496 2
VetPassword(thePassword)
	char	*thePassword;
d1498 2
a1499 2
	if (strlen(thePassword) < 5 ||	/*too short */
	    AllDigits(thePassword))	/*digits only */
d1847 1
a1847 2
	char	*alias;
	char	*password;
d1918 1
a1918 2
	char	*email;
	char	*alias;
d2116 1
d2125 1
a2125 1
		return;
d2154 1
a2154 1
#else
d2157 4
a2160 1
#else
d2162 3
a2164 2
#endif
#endif
d2193 1
a2193 2
	char	*string;
	char	*sub;
d2217 1
a2217 1
	OptionLine(getenv(buffer));
@


5.4
log
@Some SYSV changes.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1992/07/24 16:45:10 $$Revision: 5.3 $";
d904 1
d929 3
a931 1
		if (code != LR_LOGIN)	/*intermediate or strange response */
d973 13
@


5.3
log
@Re-formatted for clarity.
@
text
@d92 1
a92 1
static char *rcsid = "$Date: 1992/05/14 11:55:27 $$Revision: 5.2 $";
d106 6
d113 1
d139 3
d936 1
d941 1
d2120 3
d2127 1
@


5.2
log
@*** empty log message ***
@
text
@d1 7
a7 8
/***********************************************************************/
/*********************************************************************
* This software is Copyright (C) 1988 by Steven Dorner and the
* University of Illinois Board of Trustees, and by CSNET.  No warranties of
* any kind are expressed or implied.  No support will be provided.
* This software may not be redistributed without prior consent of CSNET.
* You may direct questions to dorner@@garcon.cso.uiuc.edu.
**********************************************************************/
d9 12
a20 12
/***********************************************************************
* This is a client program for CSO's nameserver.  It attempts to contact
* the nameserver running on garcon.cso.uiuc.edu, and query it about
* entries.  The following entries in /etc/hosts (if you're using one) and
* /etc/services will help matters:
* 
* /etc/hosts:
* 128.174.5.58  garcon.cso.uiuc.edu garcon
* 
* /etc/services:
* ns      105/tcp     ns        # CSO nameserver
*************************************************************************/
d23 1
a23 1
	    P H   for   V A X / V M S
d68 1
a68 1
		Initial port of cryptit.c to vms_cryptit.c.
d85 9
a93 5
#include descrip    /*VMS descriptor structures defs */
#include iodef      /*VMS I/O function definitions */
#include ssdef      /*VMS System Status definitions */
#include ttdef      /*VMS terminal characteristics */
#include "termdefs.h"   /*VMS defs for setterm() function */
a94 4
#else
static char *rcsid = "$Date: 92/05/12 10:34:32 $$Revision: 5.1 $";
static char *srcid = "$Source: /Users/Dorner/Projects/Qi/Ph/RCS/ph.c,v $";

d96 1
d114 4
a117 8
#define index(string,ch) strchr(string,ch)
#define rindex(string,ch) strrchr(string,ch)
#else
#ifndef NeXT
void bcopy();
#endif
#endif
#endif
d122 23
a144 33
#endif
/***********************************************************************
* vital defines
***********************************************************************/
#define MAXSTR      2048  /*max string length */
#define MAXVAL      14000   /*max value length */
#define DELIM       " \t\n"/*command delimiters */
#define MAXARGS	    20    /*maximum # of arguments in PH environ var. */
#define CLIENT	    "ph"
/***********************************************************************
* declarations for a couple of useful functions
***********************************************************************/
char   *GetValue();
char   *strtok();
char   *getenv();
#ifdef VMS
char *strchr();             /*VMS equivalent of "index" */
char *strrchr();            /*VMS equivalent of "rindex" */
#define index(a,b) strchr(a,b)
#define rindex(a,b) strrchr(a,b)

#define GetQValue(aLine)    \
      (strchr(strchr(aLine,':')+1,':')+1)
#else
FILE   *popen();

#define GetQValue(aLine)    \
      (index(index(aLine,':')+1,':')+1)
#endif
char *malloc();
char *getpass();
void exit(), free(), perror();
char *makestr();
d146 1
a146 1
/************************************************************************
d148 20
a167 14
 ************************************************************************/
int main();
char *issub();
int ContactQI();
int DoId();
int PrintResponse();
int GetGood();
void EnvOptions();
void ComplainAboutService();
void ComplainAboutHost();
void Interactive();
int DoCommand();
int DoOtherWPage();
int DoOther();
d169 1
a169 1
int DoFields();
a170 23
int DoHelp();
int DoQuery();
int DoLogin();
int DoQuit();
int DoEdit();
int DoMake();
int DoRegister();
int EditValue();
int UpdateValue();
int DoFields();
int DoMe();
int DoPassword();
int DoLogout();
void VetPassword();
int AllDigits();
int PrintQResponse();
void DoAutoLogin();
void SkipMacdef();
int TryLogin();
void EmailLine();
void NotRegisteredLine();
FILE *OpenPager();
int DoSwitch();
d172 38
a209 3
/***********************************************************************
* These are external for convenience' sake
***********************************************************************/
d211 2
a212 1
int maccecho =0;
d215 5
a219 4
int  ToQI;		/*write to this to tell the nameserver stuff */
int  FromQI;		/*read nameserver responses from here */
char ToQIBuf[MAXSTR];
int ToQILen;
d221 6
a226 3
  {			\
    char *ToQI=ToQIBuf;	\
    sprintf
d228 5
a232 3
    ToQILen = strlen(ToQIBuf);	\
  }				\
  netwrite(ToQI,ToQIBuf,ToQILen)
d234 3
a236 2
FILE   *ToQI;		/*write to this to tell the nameserver stuff */
FILE   *FromQI;		/*read nameserver responses from here */
d240 5
a244 5
char  MyAlias[MAXSTR];  /*currently logged-in alias */
char   *Me;		/*the name of this program */
char *MyPassword=NULL;  /*password read from .netrc (if any) */
char *MailDomain=MAILDOMAIN;	/*mail domain */
int LocalPort=0;	/*local port in use */
d246 1
d250 25
a274 22
int NoNetrc = 0;	/*-n don't read .netrc */
char *UseHost = 0;	/*-s use server on what machine */
int UsePort = 0;	/*-p use port # */
int NoReformat=0;	/*-i don't reformat email fields */
int NoPager=0;		/*-m don't use pager */
int NoBeautify=0;	/*-b don't beautify output */
int NoLabels=0;		/*-l don't use labels */
int Confirm=0;		/*-c confirm Edit */
char *DefType=0;	/*-t prepend this type to queries */
char *ReturnFields=NULL;/*-f give list of fields */
int JustHelp=0;		/*-h give me help */
/***********************************************************************
* and the fun begins...
***********************************************************************/
int main(argc, argv)
int   argc;
char  **argv;
{
  int theCode=LR_ERROR;
  int optionsCount;
  char buffer[4096];
  short port=IPPORT_RESERVED-1;
d276 14
a289 1
	int margc=0;
d291 18
d310 3
a312 1
char *temps;          /*temp strings */
d314 36
a349 65
  /*
   * figure out what this program is called
   */
#ifdef VMS
  Me = " ph";
#else
  Me = rindex(*argv,'/');
#endif
  if (Me)
    Me++;
  else
    Me = *argv;
  EnvOptions(CLIENT);
  if (strcmp(CLIENT,Me))
  {
    sprintf(buffer,"-t %s",Me);
    (void) OptionLine(buffer);
    EnvOptions(Me);
  }
  optionsCount = ProcessOptions(--argc,++argv);
  argc -= optionsCount;
  argv += optionsCount; 

  if (!ContactQI())
  {
    fputs("Sorry--phone book not available now.\n", stderr);
#ifdef VMS
    exit(SS$_CONNECFAIL);
#else
    exit(1);
#endif
  }

  /*
   * identify ourselves
   */
  if ((theCode=DoId())>=400) exit(theCode/100);
  if (!MailDomain && (theCode=GetMailDomain())>=400) exit(theCode/100);
  if (argc==0 && !JustHelp)
    Interactive();      /*no arguments--interactive mode */
  else
  {
    /*make a query out of the arguments */
#ifdef VMS
    temps = JustHelp ? "help ph " : "query ";
    netwrite(ToQI,temps,strlen(temps));
    for (; argc; argc--, argv++)
    {
      netwrite(ToQI,*argv,strlen(*argv));
      if (argc>1) netwrite(ToQI," ",1);
    }
    temps = "\nquit\n";
    netwrite(ToQI,temps,strlen(temps));
#else
    strcpy(buffer,JustHelp ? "help ":"query ");
    for (; argc; argc--, argv++)
    {
      strcat(buffer,*argv);
      if (argc > 1)
	strcat(buffer," ");
    }
    strcat(buffer,"\n");
    theCode = DoCommand(buffer);
    qprintf(ToQI,"\nquit\n");
    qflush(ToQI);
d351 1
a351 1
  }
d353 1
a353 1
  exit(SS$_NORMAL);
d355 1
a355 1
  exit(theCode > 299 ? theCode/100 : 0);
d359 1
a359 1
/***********************************************************************
d361 3
a363 2
 ***********************************************************************/
int ContactQI()
d365 46
a410 42
  int   sock;         /*our socket */
  static struct sockaddr_in QI;    /*the address of the nameserver */
  struct servent *theNs;    	   /*nameserver service entry */
  static struct hostent *theHost;  /*host entry for nameserver */
  char host[80];
  char *baseHost;
  int backupNum=0;
  int mightBackup;
  int result=0;
  int err;

  QI.sin_family = AF_INET;

  /*find the proper port */
  if (UsePort)
    QI.sin_port = UsePort;
  else if (theNs = getservbyname(NSSERVICE, "tcp"))
  {
    QI.sin_port = theNs->s_port;
  }
  else
  {
    ComplainAboutService();
    QI.sin_port = htons(atoi(FALLBACKPORT));
  }

  /*find the proper host */
  baseHost = UseHost ? UseHost : HOST;
  if (mightBackup=(*baseHost=='.'))
    sprintf(host,"%s%s",NSSERVICE,baseHost);
  else
    strcpy(host,baseHost);
  
  if (!geteuid()) LocalPort = IPPORT_RESERVED-1;
  for (;;)
  {
    /*create the socket */
    sock = LocalPort ? rresvport(&LocalPort) : socket(PF_INET, SOCK_STREAM, 0);
    if (sock < 0) {perror("socket");goto done;}
    QI.sin_family = AF_INET;
    if (theHost = gethostbyname(host))
    {
d412 40
a451 1
      bcopy(theHost->h_addr, (char *) &QI.sin_addr, 4);
d453 11
a463 1
      bcopy(theHost->h_addr, (char *) &QI.sin_addr.s_addr, 4);
d465 7
a471 55
    }
    else if (!backupNum)
    {
      ComplainAboutHost(host);
      QI.sin_addr.s_addr = Dot2Addr(FALLBACKADDR);
    }
    else
    {
      fprintf(stderr,"No more backups to try.\n");
      goto done;
    }
  
    /*connect to the nameserver */
    if (connect(sock, (struct sockaddr *)&QI, sizeof(QI)) < 0)
    {
      if (errno == EADDRINUSE) {if (LocalPort) LocalPort--;continue;}
      perror(host);
      if (mightBackup)
      {
        backupNum++;
	sprintf(host,"%s%d%s",NSSERVICE,backupNum,baseHost);
      }
      else
        goto done;
    }
    else break;
  }

  if (backupNum)
    fprintf(stderr,"WARNING--backup host %s; information may be out of date.\n",host);
  /*open path to nameserver */
#ifdef VMS
  ToQI = sock;        /*copy socket channel for netwrite calls */
  FromQI = sock;            /*ditto for netread calls */
#else
  if ((ToQI = fdopen(sock, "w")) == NULL)
  {
    perror("to qi");
    goto done;
  }

  /*open path from nameserver */
  if ((FromQI = fdopen(sock, "r")) == NULL)
  {
    perror("from qi");
    goto done;
  }
#endif
  UseHost = theHost ? theHost->h_name : inet_ntoa(QI.sin_addr);
  UsePort = QI.sin_port;
  result = 1;

done:
  setuid(getuid());  
  return (result);
d474 5
a478 4
/***********************************************************************
* identify ourselves to the nameserver
***********************************************************************/
int DoId()
d480 3
a482 3
  qprintf(ToQI,"id %d\n",getuid());
  qflush(ToQI);
  return (PrintResponse(-1));
d485 1
a485 1
/************************************************************************
d487 3
a489 2
 ************************************************************************/
int GetMailDomain()
d491 28
a518 29
  char scratch[MAXSTR];
  char *lastc, *s2lastc;
  short code=0;
  
  qprintf(ToQI,"siteinfo\n");
  qflush(ToQI);
  while (GetGood(scratch, MAXSTR, FromQI))  /*read it */
  {
    code = atoi(scratch);
    if (code==-200)
    {
      if ((lastc=rindex(scratch,':')) && lastc>scratch)
      {
	*lastc++ = 0;
	if (s2lastc=rindex(scratch,':'))
	{
	  s2lastc++;
	  if (!strcmp("maildomain",s2lastc))
	  {
	    lastc[strlen(lastc)-1] = 0;
	    MailDomain = makestr(lastc);
	  }
	}
      }
    }
    else if (code >= LR_OK)
      break;
  }
  return(code ? 200 : 500);  /*only fail if the cnxn broke */
d521 1
a521 1
/***********************************************************************
d525 21
a545 19
 * if doPaging is 1, the pager will be used.
 * if doPaging is 0, no pager will be used.
 * if doPaging is -1, the response will not be printed at all.
 ***********************************************************************/
int PrintResponse(doPaging)
int doPaging;       /*use the pager? */
{
  char  scratch[MAXSTR];  /*some space */
  int   code=LR_ERROR;         /*the reply code */
  FILE   *theOutput;

  theOutput = OpenPager(doPaging);
  while (GetGood(scratch, MAXSTR, FromQI))  /*read it */
  {
    code = atoi(scratch);
    if (doPaging!= -1 || code>=400) fputs(scratch, theOutput);   /*echo it */
    if (code >= LR_OK)
      break;
  }
d548 2
a549 2
  if (theOutput != stdout)
    pclose(theOutput);
d552 1
a552 1
  return (code);        /*all done.  return final code */
d555 53
a607 48
/***********************************************************************
* get a non-comment line from a stream
* a comment is a line beginning with a # sign
***********************************************************************/
int GetGood(theString, maxChars, theFile)
char   *theString;        /*space to put the chars */
int   maxChars;         /*max # of chars we want */
#ifdef VMS
int   theFile;        /*stream to read them from */
{
static char Qbuf [MAXSTR+4] = { '\0' } ;
static int  pos = {0}, end = {0}, len = {0} ;
char *linp;

  for (;;)
  {
    if (pos >= len)
    {
      len = netread(theFile,Qbuf,maxChars);
      if (len <= 0) return (0);
      Qbuf [len] = '\0';
      pos = 0;
    }

    linp = index(Qbuf+pos, '\n');   /*find next newline char */
    if (linp == NULL)
      end = len;          /*no newline chars left */
    else
      end = linp - Qbuf;      /*convert pointer to index */

    strncpy(theString, Qbuf+pos, end-pos+1);
    *(theString+end-pos+1) = '\0';
    pos = end + 1;          /*save new position for next time */
#else   
FILE  *theFile;             /*stream to read them from */
{
  for (;;)
  {
    (void) fgets(theString, maxChars, theFile);
#endif
    if (!*theString)
    {
      fputs("Oops; lost connection to server.\n",stderr);
      exit(1);
    }
    else if (*theString != '#')
      return (1);     /*not a comment; success! */
  }
d610 5
a614 4
/***********************************************************************
* complain that there isn't an entry for ns in /etc/services
***********************************************************************/
void ComplainAboutService()
d616 4
a619 4
  fprintf(stderr, "Warning--there is no entry for ``%s'' in /etc/services;\n",
      NSSERVICE);
  fputs("please have your systems administrator add one.\n", stderr);
  fprintf(stderr, "I'm going to use port %s in the meantime.\n", FALLBACKPORT);
d622 11
a632 10
/***********************************************************************
* complain that there isn't an entry for garcon in /etc/hosts
***********************************************************************/
void ComplainAboutHost(name)
char *name;
{
  fprintf(stderr, "Warning--unable to find address for ``%s''.\n",
    name);
  fprintf(stderr, "I'm going to use address %s in the meantime.\n",
      FALLBACKADDR);
d635 3
a637 3
/***********************************************************************
* the interactive portion of the client
***********************************************************************/
d641 3
a643 3
  char   *cName;        /*the name of the command */
  int   cLog;         /*must be logged in to use? */
  int   (*cFunc) ();    /*function to call for command */
d646 1
a646 1
Command CommandTable[] =
d648 3
a650 3
  "help", 0, DoHelp,
  "?", 0, DoHelp,
  "query", 0, DoQuery,
d652 9
a660 9
  CLIENT, 0, DoQuery,
  "me", 1, DoMe,
  "edit", 1, DoEdit,
  "make", 1, DoMake,
  "register", 1, DoRegister,
  "password", 1, DoPassword,
  "passwd", 1, DoPassword,
  "login", 0, DoLogin,
  "logout", 1, DoLogout,
d662 2
a663 2
#ifdef MACC  
  "fields", 0, DoFields,
d665 2
a666 2
  "fields", 0, DoOtherWPage,
  "switch", 0, DoSwitch,
d669 8
a676 8
  "add", 1, DoOther,
  "delete", 1, DoOther,
  "set", 0, DoOther,
#endif
  "quit", 0, DoQuit,
  "bye", 0, DoQuit,
  "exit", 0, DoQuit,
  0, 0, 0
d679 21
a699 20
/***********************************************************************
* the main loop
***********************************************************************/
int LastCode = 0;	/*the response from the previous command */
void Interactive()
{
  char  inputLine[MAXSTR];  /*space for an input line */
  char *spot;

  *MyAlias = 0;         /*nobody logged in yet... */
  puts(rcsid);

  /*
   * print database status
   */
  LastCode = DoOther("status\n",0);

  /*
   * autologin if possible
   */
d701 2
a702 1
  if (!NoNetrc) DoAutoLogin();
d705 5
a709 5
  puts("");
  
  while (1)
  {
    (void) signal(SIGPIPE,SIG_IGN);
d711 2
a712 2
  if (!maccecho)
    printf("%s> ",Me);
d714 1
a714 1
    printf("%s> ",Me);
d716 13
a728 10
    (void) fflush(stdout);  /*prompt */
    spot=inputLine;
    do {
      if (!fgets(spot, MAXSTR-(spot-inputLine), stdin))
	return;        /*read line */
      spot = inputLine + strlen(inputLine)-2;
      if (*spot=='\\') *spot++ = ' ';
      else spot=inputLine-1;
    }
    while (spot>=inputLine);
d730 2
a731 2
	if (maccecho)
    		printf("%s> %s",Me,inputLine);
d734 3
a736 3
    if (!(LastCode=DoCommand(inputLine)))   /*is it a command we know? */
      LastCode = DoOther(inputLine);    /*unrecognized command */
  }
d742 43
a784 44
int DoCommand(inputLine)
char   *inputLine;        /*the input line */
{
  char  scratch[MAXSTR];  /*some space */
  char   *theToken;       /*a token from the command line */
  Command *theCommand;    /*the command name */
  Command *doMe;
  int   len;

  /*make a safe copy of the input line, so we can play with it */
  strcpy(scratch, inputLine);

  if (!(theToken = strtok(scratch, DELIM)))
    return (LR_ERROR);       /*blank line */

  /*search command table linearly */
  doMe = NULL;
  len = strlen(theToken);
  for (theCommand = CommandTable; theCommand->cName; theCommand++)
    if (!strncmp(theCommand->cName, theToken, len))
    {
      if (doMe)       /*we found 2 commands that match (bad) */
      {
	printf("%s is ambiguous.\n", theToken);
	return (LR_ERROR);
      }
      doMe = theCommand;  /*we found a command that matches */
    }

  if (doMe)           /*found one and only one command */
  {
    /*expand command name */
    theToken = strtok((char *)0, "\n");
    sprintf(inputLine, "%s %s\n", doMe->cName, theToken ? theToken : "");

    /*execute command */
    if (doMe->cLog && !*MyAlias)
      printf("You must be logged in to use %s.\n",doMe->cName);
    else
      return((*doMe->cFunc) (inputLine));
    return (LR_ERROR);
  }

  return (0);         /*didn't find it */
d787 10
a796 9
/***********************************************************************
* execute a command for which we do nothing special; use the pager
***********************************************************************/
int DoOtherWPage(inputLine)
char   *inputLine;
{
  qprintf(ToQI,"%s",inputLine);   /*send command */
  qflush(ToQI);
  return (PrintResponse(1));  /*get response */
d799 10
a808 9
/***********************************************************************
* execute a command for which we do nothing special; don't use pager
***********************************************************************/
int DoOther(inputLine)
char   *inputLine;
{
  qprintf(ToQI,"%s",inputLine);   /*send command */
  qflush(ToQI);
  return (PrintResponse(0));  /*get response */
d812 21
a832 20
int DoFields(inputLine)
char   *inputLine;
{
  printf("Field Name     Description\n"); 
  printf("------------------------------\n");
  printf("name          Person Name\n");
  printf("email         Electronic Mail Address if exists\n");
  printf("phone         Telephone Number One\n");
  printf("phone2        Telephone Number Two\n");
  printf("address       Street Address of the Building\n");
  printf("building      Building Name\n");
  printf("department    Department Number One of Person\n");
  printf("department2   Department number Two of Person\n");
  printf("appointment   Appointment Classification Code Number One \n");
  printf("appointment2  Appointment Classification Code Number Two\n");
  printf("title         Title One\n");
  printf("title2        Title Two\n");
  printf("alias         Unique Name built from First Letter of First Name, Last\n");   
  printf("              Name and a Number\n\n"); 
  return(LR_OK);
d834 1
d837 44
a880 39
/***********************************************************************
* execute a query request
***********************************************************************/
int DoQuery(inputLine)
char   *inputLine;
{
  char scratch[4096];
  char *args;
  int noReformatWas = NoReformat;
  int code;

  if (ReturnFields && !issub(inputLine,"return"))
  {
    args=inputLine+strlen(inputLine)-1;
    sprintf(args," return %s\n",ReturnFields);
    for (;*args;args++) if (*args==',') *args=' ';
  }
  if (!NoBeautify && !NoReformat)
  {
    char *ret = issub(inputLine,"return");
    if (ret) NoReformat = !issub(ret,"email");
  }
  if (!DefType || issub(inputLine,"type="))
    qprintf(ToQI,"%s",inputLine);   /*send command */
  else
  {
    strcpy(scratch,inputLine);
    args = strtok(scratch," \t");
    args = strtok(0,"\n");
    if (args)
      qprintf(ToQI,"query type=\"%s\" %s\n",DefType,args);   /*send command */
    else
      qprintf(ToQI,"%s",inputLine);
  }
  
  qflush(ToQI);
  code = (NoBeautify ? PrintResponse(1) : PrintQResponse(1,0));
  NoReformat = noReformatWas;
  return (code);
d883 89
a971 85
/***********************************************************************
* execute a login request
***********************************************************************/
int DoLogin(inputLine)
char   *inputLine;
{
  char  encryptMe[MAXSTR];  /*string from nameserver */
  char  encrypted[MAXSTR];  /*string from ns, encrypted */
  char   *password;       /*user's nameserver password */
  int   code;
  char scratch[MAXSTR];

  strcpy(scratch,inputLine);
  (void) strtok(scratch,DELIM);	/*the login part of the command */
  if (!strtok(0,DELIM))		/*check for an alias */
  {
    printf("Enter nameserver alias: ");	/*ask for missing alias */
    fgets(scratch,sizeof(scratch),stdin);
    if (!*scratch) return(LR_ERROR);
    sprintf(inputLine,"login %s",scratch);
  }

tryagain:
  qprintf(ToQI,"%s",inputLine);   /*send login request */
  qflush(ToQI);

  for (;;)          /*read the response */
  {
    if (!GetGood(encryptMe, MAXSTR, FromQI))
    {
      fprintf(stderr, "Whoops--the nameserver died.\n");
      exit(1);
    }
    code = atoi(encryptMe);
    if (code != LR_LOGIN)   /*intermediate or strange response */
      fputs(encryptMe, stdout);
    if (code >= LR_OK)    /*final response */
      break;
  }

  if (code == LR_LOGIN)
  {
     /*the nameserver has issued a challenge */
    if (LocalPort)
      qprintf(ToQI,"email %s\n",getpwuid(getuid())->pw_name);
    else
    {
      password = MyPassword ? MyPassword :
		    getpass("Enter nameserver password: ");
      crypt_start(password);
  
      /*encrypt the challenge with the password */
      encryptMe[strlen(encryptMe) - 1] = '\0';    /*strip linefeed */
      encrypted[encryptit(encrypted, index(encryptMe, ':') + 1)] = '\0';
  
      /*send the encrypted text to qi */
      qprintf(ToQI, "answer %s\n", encrypted);
    }
    qflush(ToQI);

    /*get the final response */
    for (;;)
    {
      if (!GetGood(encryptMe, MAXSTR, FromQI))
      {
	fprintf(stderr, "Whoops--the nameserver died.\n");
	exit(1);
      }
      code = atoi(encryptMe);
      if (code == LR_NOEMAIL) {LocalPort = 0; goto tryagain;}
      fputs(encryptMe, stdout);
      if (code >= LR_OK)  /*final response */
	break;
    }
  }

  if (code == LR_OK)      /*logged in */
  {
    strcpy(MyAlias, index(encryptMe, ':') + 1);
    *index(MyAlias, ':') = '\0';
    if (!LocalPort) VetPassword(password);
  }
  else
    *MyAlias = '\0';
  return(code);
d974 6
a979 5
/***********************************************************************
* execute a quit request
***********************************************************************/
int DoQuit(inputLine)
char   *inputLine;
d981 1
a981 1
  DoOther("quit\n");
d983 1
a983 1
  exit(SS$_NORMAL);
d985 1
a985 1
  exit(LastCode<LR_OK || LastCode >=LR_MORE ? LastCode/100 : 0);
d989 39
a1027 37
/***********************************************************************
* edit a field
***********************************************************************/
int DoEdit(inputLine)
char   *inputLine;
{
  char   *theField;
  char   *theAlias;
  char   *theValue;
  int theCode=LR_OK;
  char confirm[10];

  (void) strtok(inputLine, DELIM);  /*skip ``edit'' */
  if (!(theField = strtok((char *) 0, DELIM)))
  {
    (void) DoHelp("help edit\n");
    return(LR_ERROR);
  }

  if (!(theAlias = strtok((char *) 0, DELIM)))
    theAlias = MyAlias;

  if ((theValue = GetValue(theAlias, theField)) && EditValue(theValue))
  {
    for (theCode=UpdateValue(theAlias,theField,theValue);
         400<=theCode && theCode<=499;
	 theCode=UpdateValue(theAlias,theField,theValue))
    {
      if (!isatty(0)) break;
      printf("Shall I try again [y/n]? ");
      fgets(confirm,sizeof(confirm),stdin);
      if (*confirm!='y' && *confirm!='Y') break;
    }
    if (theCode<300 && !strcmp(theField,"alias"))
      strcpy(MyAlias,theValue);
  }
  return(theCode);
d1033 36
a1068 37
char *GetValue(theAlias, theField)
char   *theAlias;
char   *theField;
{
  static char theValue[MAXVAL];     /*will hold the value */
  char   *vSpot;
  char  scratch[MAXSTR];
  int   code;

  if (!strcmp(theField, "password"))
  {
    puts("Use the ``password'' command, not edit.");
    return (NULL);
  }

  /*do the query */
  qprintf(ToQI, "query alias=%s return %s\n", theAlias, theField);
  qflush(ToQI);

  *theValue = '\0';

  /*read qi response lines, concatenating the responses into one value */
  for (vSpot = theValue;; vSpot += strlen(vSpot))
  {
    if (!GetGood(scratch, MAXSTR, FromQI))
    {
      fprintf(stderr, "Ding-dong the server's dead!\n");
      exit(0);
    }
    if ((code = atoi(scratch)) == -LR_OK)
      strcpy(vSpot, index(GetQValue(scratch), ':') + 2);  /*part of value */
    else
    if (code >= LR_OK)
      break;        /*final response */
    else
      fputs(scratch, stdout);   /*??? */
  }
d1070 2
a1071 2
  if (code != LR_OK)      /*error */
    fputs(scratch, stdout);
d1073 1
a1073 1
  return (code == LR_OK ? theValue : NULL);
d1079 3
a1081 2
int EditValue(theValue)
char   *theValue;         /*the value to edit */
d1083 2
a1084 2
  char   *theFileName;    /*name of temp file to use */
  char   *mktemp();
d1086 15
a1100 12
  struct dsc$descriptor_s cli_input;
  char  template[28], f1[28], f2[28], edit_command[64];
  int   istat;
#else
  char  template[20];
#endif
  int   fd;         /*file descriptor for temp file */
  static char newValue[MAXVAL];     /*new value */
  char   *editor;           /*editor program to use */
  int   bytes;            /*numnber of bytes in file */
  register char *from, *to;
  int   badChar;          /*did we find a bad character? */
d1102 17
a1118 1
  int   junk;
d1120 3
a1122 1
  union wait   junk;
d1124 11
a1134 1
  char scratch[80];
d1136 1
a1136 1
  /*put the value into a temp file */
d1138 16
a1153 44
  strcpy(template, "SYS$SCRATCH:PHXXXXXX.TMP");
  theFileName = mktemp(template);
  strcpy (f1, theFileName);
  strcpy (f2, theFileName);
  strcat (f1, ";1");      /*versions needed for delete function */
  strcat (f2, ";2");
  if ((fd = creat(theFileName, 0)) < 0)
#else
  strcpy(template, "/tmp/phXXXXXX");
  theFileName = mktemp(template);
  if ((fd = open(theFileName, O_RDWR | O_CREAT, 0777)) < 0)
#endif
  {
    perror(theFileName);
    return (0);
  }

  if (write(fd, theValue, strlen(theValue)) < 0)
  {
    perror(theFileName);
    (void) close(fd);
    return (0);
  }

  (void) close(fd);

  /*run an editor on the temp file */
#ifdef VMS
  if (!(editor = getenv("EDITOR")))
    editor = "EDIT/EDT";

  strcpy(edit_command, editor);
  strcat(edit_command, " ");
  strcat(edit_command, theFileName);
  cli_input.dsc$w_length = strlen(edit_command);  /*descriptor for spawn */
  cli_input.dsc$a_pointer = edit_command;
  cli_input.dsc$b_class = DSC$K_CLASS_S;
  cli_input.dsc$b_dtype = DSC$K_DTYPE_T;

  if( (istat = LIB$SPAWN(&cli_input)) != SS$_NORMAL )
  {
    (void) delete (f1);
    exit(istat);
  }
d1155 1
a1155 1
  if (!(editor = getenv("EDITOR")))
d1157 36
a1192 1
    editor = "/usr/bin/vi";
d1194 17
a1210 1
    editor = "/usr/ucb/vi";
d1212 1
d1214 27
a1240 96
  if (fork())
    (void) wait(&junk);
  else
  {
    (void) execlp(editor, editor, theFileName, NULL);
    fprintf(stderr,"Whoops!  Failed to exec %s\n",editor);
    exit(1);
  }
#endif

  /*does the user want the value? */
  if (Confirm)
  { 
    do
    {
      printf("Change the value [y]? ");
      gets(scratch);
    }
    while (*scratch && !index("yYnN",*scratch));
  }
  
  /*read the value back out */
  if ((fd = open(theFileName, 0)) < 0)
  {
    perror(theFileName);
#ifdef VMS
#else
    (void) unlink(theFileName);
#endif
    return (0);
  }

#ifdef VMS
#else
  (void) unlink(theFileName);
#endif

  if ((bytes = read(fd, newValue, MAXSTR - 1)) < 0)
  {
    perror(theFileName);
    (void) close(fd);
#ifdef VMS
    (void) delete (f1);   /*delete 1st temp file */
    (void) delete (f2);   /*delete 2nd temp file */
#endif
    return (0);
  }
  (void) close(fd);
#ifdef VMS
  (void) delete (f1);     /*delete 1st temp file */
  (void) delete (f2);     /*delete 2nd temp file */
#endif
  newValue[bytes] = 0;

  /*did the value change? */
  if (Confirm && *scratch && *scratch!='y' && *scratch!='Y' ||
      !strcmp(newValue, theValue))
    return (0);

  /*copy new value into old, stripping bad characters */
  badChar = 0;
  for (to = theValue, from = newValue; *from; from++)
    if (*from == '"')
    {
      *to++ = '\\';
      *to++ = '"';
    }
    else
    if (*from >= ' ' && *from <= '~')
      *to++ = *from;
    else
    if (*from == '\t')
    {
      *to++ = '\\';
      *to++ = 't';
    }
    else
    if (*from == '\n')
    {
      if (*(from + 1))  /*skip terminating newline from vi */
      {
	*to++ = '\\';
	*to++ = 'n';
      }
    }
    else
      badChar = 1;

  *to = 0;

  if (badChar)        /*complain if we found bad characters */
  {
    fputs("Illegal characters were found in your value.\n", stderr);
    fputs("Please use only printable characters, newlines, and tabs.\n", stderr);
    fputs("The offending characters were removed.\n", stderr);
  }
d1242 9
a1250 1
  return (1);
d1253 8
a1260 7
/***********************************************************************
* update a nameserver field with a new value
***********************************************************************/
int UpdateValue(theAlias, theField, theValue)
char   *theAlias;
char   *theField;
char   *theValue;
d1262 2
a1263 2
  qprintf(ToQI, "change alias=%s make %s=\"%s\"\n", theAlias, theField, theValue);
  qflush(ToQI);
d1265 1
a1265 1
  return(PrintResponse(0));
d1267 4
a1270 3
/***********************************************************************
* print info on current user
***********************************************************************/
d1272 3
a1274 2
int DoMe(inputLine)
char   *inputLine;
d1276 6
a1281 7
  if (!*MyAlias)
  {
    return(DoHelp("help me"));
  }

  qprintf(ToQI, "query alias=%s return all\n", MyAlias);
  qflush(ToQI);
d1283 1
a1283 1
  return(NoBeautify ? PrintResponse(0) : PrintQResponse(0,0));
d1286 6
a1291 5
/***********************************************************************
* set command-line switches
***********************************************************************/
int DoSwitch(inputLine)
char   *inputLine;
d1293 42
a1334 42
  inputLine = strtok(inputLine,DELIM);
  if (!OptionLine(strtok(0,"\n")))
  {
    printf("The following things can be changed with \"switch\":\n\n");
    printf("  Paging is %s; use \"switch -%c\" to turn it %s.\n",
    	NoPager ? "OFF" : "ON",
    	NoPager ? 'M' : 'm',
    	NoPager ? "on" : "off");
    printf("  Email reformatting is %s; use \"switch -%c\" to turn it %s.\n",
    	NoReformat ? "OFF" : "ON",
    	NoReformat ? 'R' : 'r',
    	NoReformat ? "on" : "off");
    printf("  Query beautification is %s; use \"switch -%c\" to turn it %s.\n",
    	NoBeautify ? "OFF" : "ON",
    	NoBeautify ? 'B' : 'b',
    	NoBeautify ? "on" : "off");
    printf("  Label printing is %s; use \"switch -%c\" to turn it %s.\n",
    	NoLabels ? "OFF" : "ON",
    	NoLabels ? 'L' : 'l',
    	NoLabels ? "on" : "off");
    printf("  Edit confirmation is %s; use \"switch -%c\" to turn it %s.\n",
    	Confirm ? "ON" : "OFF",
    	Confirm ? 'c' : 'C',
    	Confirm ? "off" : "on");
    printf("  Default entry type is %s; use \"switch -%c%s\" to %s %s.\n",
    	DefType ? DefType : "OFF",
    	DefType ? 'T' : 't',
    	DefType ? "" : " name-of-type",
    	DefType ? "turn it" : "set it to",
	DefType ? "off" : "\"name-of-type\"");
    printf("  Default field list is %s; use \"switch -%c%s\" to %s to %s.\n",
        ReturnFields ? ReturnFields : "default",
	ReturnFields ? 'F' : 'f',
	ReturnFields ? "" : " field1,field2,... ",
	ReturnFields ? "revert" : "set it",
	ReturnFields ? "default" : "\"field1,field2,...\"");
    printf("\nThe following things cannot be changed with \"switch\":\n\n");
    printf("  Connected to server %s at port %d\n", UseHost,UsePort);
    printf("  The .netrc file was %sread.\n", NoNetrc ? "not " : "");
    printf("  The -h switch is meaningless in interactive mode.\n");
  }
  return(LR_OK);
d1337 6
a1342 5
/***********************************************************************
* change a field value from the command line
***********************************************************************/
int DoMake(inputLine)
char   *inputLine;
d1344 2
a1345 2
  int theCode=LR_ERROR;
  char *token;
d1347 3
a1349 10
  if (!*MyAlias)
    DoHelp("help make");
  else
  {
    qprintf(ToQI,"change alias=%s %s",MyAlias,inputLine);
    qflush(ToQI);
    theCode = PrintResponse(0);
    if (theCode<300)
      for (token=strtok(inputLine," \n");token;token=strtok(0," \n"))
        if (!strncmp(token,"alias=",6))
d1351 10
a1360 2
	  strcpy(MyAlias,token+6);
	  break;
d1362 1
a1362 2
  }
  return(theCode);
d1365 22
a1386 21
/***********************************************************************
* register the current account
***********************************************************************/
int DoRegister(inputLine)
char   *inputLine;
{
  int theCode=LR_ERROR;
  struct passwd *pw;
  char hostname[MAXHOSTNAMELEN];

  if (!*MyAlias)
    DoHelp("help register");
  else if ((pw=getpwuid(getuid())) && !gethostname(hostname,sizeof(hostname))
	    && strcmp(pw->pw_name,"phones"))
  {
    qprintf(ToQI,"change alias=%s make email=%s@@%s\n",
		  MyAlias,pw->pw_name,hostname);
    qflush(ToQI);
    theCode = PrintResponse(0);
  }
  return(theCode);
d1388 45
a1432 43
  
/***********************************************************************
* change password
***********************************************************************/
int DoPassword(inputLine)
char   *inputLine;
{
  char  password[80];
  char   *confirm;
  char   *theAlias;
  int theCode=LR_ERROR;

  if (!*MyAlias)
  {
    return(DoHelp("help password"));
  }  

  /*which alias to use? */
  (void) strtok(inputLine, DELIM);
  if (!(theAlias = strtok((char *) 0, DELIM)))
    theAlias = MyAlias;

  /*get the password */
  strcpy(password, getpass("Enter new password: "));
  if (!*password) return(LR_ERROR);
  confirm = getpass("Type it again: ");
  if (strcmp(confirm, password))
  {
    fprintf(stderr, "Sorry--passwords didn't match.\n");
    return(theCode);
  }
  VetPassword(confirm);     /*complain if we don't like the password */

  /*encrypt and send the password */
  if (!LocalPort) password[encryptit(password, confirm)] = '\0';
  qprintf(ToQI, "change alias=%s %s password=%s\n", theAlias, 
          LocalPort ? "force" : "make", password);
  qflush(ToQI);

  /*see what the nameserver says */
  if ((theCode=PrintResponse(0)) == LR_OK && !strcmp(theAlias,MyAlias))
    crypt_start(confirm);
  return(theCode);
d1435 6
a1440 5
/***********************************************************************
* log out the current user
***********************************************************************/
int DoLogout(inputLine)
char   *inputLine;
d1442 2
a1443 2
  *MyAlias = '\0';
  return(DoOther(inputLine));
d1446 10
a1455 9
/***********************************************************************
* complain about passwords we don't like
***********************************************************************/
void VetPassword(thePassword)
char   *thePassword;
{
  if (strlen(thePassword) < 5 ||    /*too short */
    AllDigits(thePassword)) /*digits only */
    fputs("That is an insecure password; please change it.\n", stderr);
d1458 11
a1468 10
/***********************************************************************
* is a string all digits
***********************************************************************/
int AllDigits(theString)
register char *theString;
{
  for (; *theString; theString++)
    if (!isdigit(*theString))
      return (0);
  return (1);
d1471 30
a1500 28
/***********************************************************************
* print the response to a query
* this strips out all the nameserver reply codes.
***********************************************************************/
int PrintQResponse(reformatEmail,amHelping)
int reformatEmail;
int amHelping;
{
  char  theLine[MAXSTR];
  int   theCode=LR_ERROR;
  int   currentPerson = 0;
  int   thePerson;
  register char *cp;
  FILE   *theOutput;
  char  alias[MAXSTR];
  char  email[MAXSTR];
  int copiedEmail=0;

  theOutput = OpenPager(1);

  *alias = *email = 0;		/*haven't found an alias yet */
  if (NoReformat || !MailDomain) reformatEmail=0;
  /*get the response */
  while (GetGood(theLine, MAXSTR, FromQI))
  {
    theCode = atoi(theLine);
    if (theCode == LR_NUMRET)
    {
d1502 3
a1504 3
	cp = strchr(theLine,':');
	if ( cp != 0)
	fprintf(theOutput,"\n%s\n",cp+1); /*strchr returns pointer to : then add one */
d1506 62
a1567 36
    }
    else
    if (theCode == -LR_OK || theCode == -LR_AINFO || theCode == -LR_ABSENT
      || theCode == -LR_ISCRYPT)
    {
      thePerson = atoi(index(theLine, ':') + 1);
      /*output a delimiter */
      if (thePerson != currentPerson)
      {
	if (*alias && !*email)
	  NotRegisteredLine(alias,theOutput);
	else if (*email)
	{
	  EmailLine(email,alias);
	  fputs(GetQValue(email),theOutput);
	  *email = 0;
	}
	fputs("----------------------------------------\n", theOutput);
	currentPerson = thePerson;
	copiedEmail=0;
      }
      if (reformatEmail)
      {
	cp = GetQValue(theLine);
	while (*cp && *cp==' ') cp++;
	if (!strncmp("alias",cp,5))
	{
	  copiedEmail = 0;
	  strcpy(alias,theLine);
	  continue;
	}
	else if (!strncmp("email",cp,5))
	{
	  strcpy(email,theLine);
	  copiedEmail = 1;
	  continue;
d1569 4
a1572 30
	else if (*cp==':' && copiedEmail)
	  continue;
	else
	  copiedEmail = 0;
      }
      /*output the line */
      if (NoLabels && !amHelping)
        fputs(index(GetQValue(theLine),':')+2, theOutput);
      else
        fputs(GetQValue(theLine), theOutput);
    }
    else if (theCode != LR_OK)
      fputs(theLine, theOutput);  /*error */

    if (theCode >= LR_OK)
    {
      if (*alias && !*email)
	NotRegisteredLine(alias,theOutput);
      else if (*email)
      {
	EmailLine(email,alias);
	/*output the line */
	if (NoLabels && !amHelping)
	  fputs(index(GetQValue(email),':')+2, theOutput);
	else
	  fputs(GetQValue(email), theOutput);
      }
      break;
    }
  }
a1573 4
  /*final "delimiter" */
  if (currentPerson)
    fputs("----------------------------------------\n", theOutput);
  
d1576 2
a1577 2
  if (theOutput != stdout)
    (void) pclose(theOutput);
d1580 1
a1580 1
  return(theCode);
d1584 4
a1587 4
/***********************************************************************
* break a string into tokens.  this code is NOT lifted from sysV, but
* was written from scratch.
***********************************************************************/
d1589 1
a1589 1
 * function:   strtok purpose:  to break a string into tokens parameters:
d1592 1
a1592 1
 * NULL if no tokens remain. 
d1594 1
a1594 1
char   *
d1596 2
a1597 1
char   *s1, *s2;
d1599 2
a1600 2
  static char *old = 0;
  char   *p1, *p2;
d1602 19
a1620 21
  if (!(s1 || old))
    return (NULL);
  p1 = (s1 ? s1 : old);
  while (*p1 && (index(s2, *p1) != NULL))
    p1++;
  if (*p1)
  {
    p2 = p1;
    while (*p2 && (index(s2, *p2) == NULL))
      p2++;
    if (*p2)
    {
      *p2 = '\0';
      old = ++p2;
    }
    else
      old = 0;
    return (p1);
  }
  else
    return (NULL);
d1622 1
d1625 1
a1625 1
/*       setterm.c
d1635 1
a1635 1
long  *characteristic, *state;
d1637 37
a1673 31
  int     status;
  long    efn;
  long    new_state;
  short     term_chan;
  struct char_buff  mode;
  struct mode_iosb  term_iosb;
  $DESCRIPTOR(term_desc, "TT:");

  /*get event flag */
  status = lib$get_ef(&efn);
  if ( status != SS$_NORMAL ) return (status);

  /*get channel to terminal */
  status = sys$assign(&term_desc, &term_chan, 0, 0);
  if (status != SS$_NORMAL) return (status);

  /*if characteristic is BROADCAST, ECHO, or TYPEAHEAD, state must be toggled */
  if (*characteristic == BROADCAST || *characteristic == ECHO || *characteristic == TYPEAHEAD)
    new_state = !(*state);
  else
    new_state = *state;

  /*get current mode */
  status = sys$qiow(efn, term_chan, IO$_SENSEMODE, &term_iosb, 0, 0, &mode, 12, 0, 0, 0, 0);
  if (status != SS$_NORMAL || term_iosb.stat != SS$_NORMAL) { sys$dassgn(term_chan); return (status); }

  /*change characteristics buffer */
  if (new_state == ON)
    mode.basic_char |= *characteristic;
  else
    mode.basic_char &= ~(*characteristic);
d1675 2
a1676 2
  /*$ SET TERM/...  and then deassign channel */
  status = sys$qiow(efn, term_chan, IO$_SETMODE, &term_iosb, 0, 0, &mode, 12, 0, 0, 0, 0);
d1678 2
a1679 2
  sys$dassgn(term_chan);
  lib$free_ef(&efn);
d1681 4
a1684 2
  if (status != SS$_NORMAL) return (status);
  else return (term_iosb.stat);
d1687 24
a1710 11
/***********************************************************************
* get password from stdin
*
* implement for VMS, since VAXCRTL lacks getpass() function.
***********************************************************************/
char *getpass(prompt)
char *prompt;
{

static char line [12];
static int echo = {ECHO}, off = {OFF}, on = {ON};
a1711 7
  printf(prompt); (void) fflush(stdout);        /*prompt */
  setterm(&echo, &off);
  gets(line);
  setterm(&echo, &on);
  puts("");
  return(line);
}
d1714 5
a1718 4
/***********************************************************************
* use .netrc to login to nameserver, if possible
***********************************************************************/
void DoAutoLogin()
d1720 61
a1780 57
  FILE *netrc;    /*the .netrc file */
  char pathName[1024];/*pathname of .netrc file */
  struct stat theStat;/*permissions, etc. of .netrc file */
  char key[80], val[80];    /*line from the .netrc file */
  char *token;    /*token (word) from the line from the .netrc file */
  char *alias=NULL;   /*the user's alias */
  char *pw=NULL;    /*the user's password */

  /*
   * manufacture the pathname of the user's .netrc file
   */
  sprintf(pathName,"%s/.netrc",getenv("HOME"));

  /*
   * make sure its permissions are ok
   */
  if (stat(pathName,&theStat)<0)
    return;
  if (theStat.st_mode & 077)
    return;             /*refuse insecure files */

  /*
   * try to open it
   */
  if (!(netrc=fopen(pathName,"r")))
    return;

  /*
   * look for a ``machine'' named ``ph''
   */
  while (2==fscanf(netrc,"%s %s",key,val))
  {
    if (!strcmp(key,"machine") && !strcmp(val,CLIENT))
    {
      /*
       * found an entry for ph.  look now for other items
       */
      while (2==fscanf(netrc,"%s %s",key,val))
      {
	if (!strcmp(key,"machine"))     /*new machine */
	  goto out;
	else if (!strcmp(key,"login"))
	    alias=strcpy(malloc((unsigned)strlen(val)+1),val);
	else if (!strcmp(key,"password"))
	    pw=strcpy(malloc((unsigned)strlen(val)+1),val);
	else if (!strcmp(key,"macdef")) SkipMacdef(netrc);

      }
    }
    else if (!strcmp(key,"macdef")) SkipMacdef(netrc);
  }

out:
  if (alias && (pw||LocalPort)) TryLogin(alias,pw);
  if (alias) free(alias);
  if (pw) free(pw);
  return;
d1783 12
a1794 10
/***********************************************************************
* skip a macdef in the .netrc file
***********************************************************************/
void SkipMacdef(netrc)
FILE *netrc;
{
  int c, wasNl;
  
  for (wasNl=0;(c=getc(netrc))!=EOF;wasNl=(c=='\n'))
    if (wasNl && c=='\n') break;
d1797 38
a1834 35
/***********************************************************************
* try a login alias and password
***********************************************************************/
int TryLogin(alias,password)
char *alias;
char *password;
{
  char loginLine[80];
  int success;

  /*
   * construct a login line
   */
  sprintf(loginLine,"login %s\n",alias);

  /*
   * set our password
   */
  MyPassword=password;

  /*
   * try the login
   */
  success = DoLogin(loginLine,0);

  /*
   * reset our password
   */
  MyPassword = NULL;
  if (password) while (*password) *password++ = 'x';

  /*
   * return our success (or failure)
   */
  return(success);
d1838 6
a1843 5
/***********************************************************************
* execute a help request
***********************************************************************/
int DoHelp(inputLine)
char   *inputLine;
d1845 21
a1865 22
  char scratch[256];
  char *token;
  
  if (*inputLine=='?')
  {
    /*
     * avoid bug for lone ?
     */
    sprintf(scratch,"help %s",inputLine+1);
    strcpy(inputLine,scratch);
  }
  else
    strcpy(scratch,inputLine);
  token = strtok(scratch+4,DELIM);	/*the word after help */
  if (token && !strcmp(token,"native")) /*looking for native help */
    strcpy(scratch,inputLine);		/*leave the command alone */
  else
    sprintf(scratch,"help %s %s",CLIENT,inputLine+4); /*insert identifier */
    
  qprintf(ToQI,"%s",scratch);   /*send command */
  qflush(ToQI);
  return (NoBeautify ? PrintResponse(0) : PrintQResponse(0,1));
d1868 1
a1868 1
/************************************************************************
d1871 26
a1896 25
 ************************************************************************/
void EmailLine(email,alias)
char *email;
char *alias;
{
  char scratch[MAXSTR];
  char *emSpot;		/*beginning of email account */
  char *alSpot;		/*beginning of nameserver alias */
  
  if (*alias)
  {
    emSpot = index(GetQValue(email), ':') + 2;
    alSpot = index(GetQValue(alias), ':') + 2;
    *index(alSpot,'\n') = 0;
    *index(emSpot,'\n') = 0;
    /*
     * overwrite the email label
     */
    strcpy(alSpot-2-strlen("email to"),"email to");
    alSpot[-2] = ':';	/*strcpy clobbered the colon; repair */
    sprintf(scratch,"@@%s (%s)\n",MailDomain,emSpot);
    strcat(alias,scratch);
    strcpy(email,alias);		/*leave it in the "email" line */
    *alias = 0;			/*we're done with the alias */
  }
d1899 1
a1899 1
/************************************************************************
d1901 21
a1921 20
 ************************************************************************/
void NotRegisteredLine(alias,theOutput)
char *alias;
FILE *theOutput;
{
  char scratch[MAXSTR];
  register char *cp;
  
  strcpy(scratch,alias);
  cp = index(GetQValue(scratch),':');
  strcpy(cp-7,"email");
  cp[-2] = ':';
  strcpy(cp,"no account registered\n");
  EmailLine(scratch,alias);
  /*output the line */
  if (NoLabels)
    fputs(index(GetQValue(scratch),':')+2, theOutput);
  else
    fputs(GetQValue(scratch), theOutput);
  *alias = 0; 				/*done with alias */
d1924 1
a1924 1
/************************************************************************
d1926 142
a2067 112
 ************************************************************************/
int ProcessOptions(argc,argv)
int argc;
char **argv;
{
  int count = 0;
  /*
   * options processing
   */
  for (;argc && **argv=='-'; argc--,argv++,count++)
  {
    for ((*argv)++; **argv; (*argv)++)
    {
      switch(**argv)
      {
	case 'r': NoReformat = 1; break;
	case 'R': NoReformat = 0; break;
	case 'n': NoNetrc = 1; break;
	case 'N': NoNetrc = 0; break;
	case 'm': NoPager = 1; break;
	case 'M': NoPager = 0; break;
	case 'b': NoBeautify = 1; break;
	case 'B': NoBeautify = 0; break;
	case 'l': NoLabels = 1; break;
	case 'L': NoLabels = 0; break;
	case 'C': Confirm = 1; break;
	case 'c': Confirm = 0; break;
	case 'H': JustHelp = 0; break;
	case 'h': JustHelp = 1; break;
	case 's':
	  if (argv[0][1])
	  {
	    if (UseHost) free(UseHost);
	    UseHost = makestr(*argv + 1);
	    MailDomain = NULL;
	    goto whilebottom;
	  }
	  else if (argc>1)
	  {
	    if (UseHost) free(UseHost);
	    UseHost = makestr(argv[1]);
	    argc--,argv++,count++;
	    MailDomain = NULL;
	    goto whilebottom;
	  }
	  else
	    fprintf(stderr,"-%c option given without server hostname.\n", **argv);
	  break;
	case 't':
	  if (argv[0][1])
	  {
	    if (DefType) free(DefType);
	    DefType = makestr(*argv + 1);
	    goto whilebottom;
	  }
	  else if (argc>1)
	  {
	    if (DefType) free(DefType);
	    DefType = makestr(argv[1]);
	    argc--,argv++,count++;
	    goto whilebottom;
	  }
	  else
	    fprintf(stderr,"-%t option given without entry type.\n", **argv);
	  break;
	case 'f':
	  if (argv[0][1])
	  {
	    if (ReturnFields) free(ReturnFields);
	    ReturnFields = makestr(*argv + 1);
	    goto whilebottom;
	  }
	  else if (argc>1)
	  {
	    if (ReturnFields) free(ReturnFields);
	    ReturnFields = makestr(argv[1]);
	    argc--,argv++,count++;
	    goto whilebottom;
	  }
	  else
	    fprintf(stderr,"-%t option given without field list.\n", **argv);
	  break;
	case 'F':
	  if (ReturnFields) free(ReturnFields);
	  ReturnFields = 0;
	  break;
	case 'T':
	  if (DefType) free(DefType);
	  DefType = 0;
	  break;
	case 'p':
	  if (isdigit(argv[0][1]))
	  {
	    UsePort = htons(atoi(*argv + 1));
	    goto whilebottom;
	  }
	  else if (argc>1 && isdigit(*argv[1]))
	  {
	    UsePort = htons(atoi(argv[1]));
	    argc--,argv++,count++;
	    goto whilebottom;
	  }
	  else
	    fprintf(stderr,"-%c option given without port number.\n", **argv);
	  break;
	default:
	  fprintf(stderr,"Unknown option: -%c.\n",**argv);
      }
    }
    whilebottom:;
  }
  return(count);
d2070 1
a2070 1
/************************************************************************
d2072 1
a2072 1
 ************************************************************************/
d2074 1
a2074 1
char *line;
d2076 12
a2087 11
  int argc;
  char *argv[MAXARGS];
  char *token;
  
  if (!line || !*line) return;
  
  for (argc=0,token=strtok(line,DELIM);token;argc++,token=strtok(0,DELIM))
    argv[argc] = token;
  argv[argc] = 0;
  
  return(ProcessOptions(argc,argv));
d2090 1
a2090 1
/************************************************************************
d2092 4
a2095 3
 ************************************************************************/
FILE *OpenPager(doPaging)
int doPaging;
d2097 11
a2107 11
  char *thePager;
  FILE *theOutput;
  
#ifdef VMS
  return(stdout);     /*simpler to skip paging for right now */
#else
  if (NoPager || doPaging!=1)
    return(stdout);
  else
  {
    if ((thePager = getenv("PAGER")) == NULL)
d2109 1
a2109 1
      thePager = "/usr/bin/more";
d2111 1
a2111 1
      thePager = "/usr/ucb/more";
d2113 3
a2115 3
    if ((theOutput = popen(thePager, "w")) == NULL)
      theOutput = stdout;
    return(theOutput);
d2117 1
a2117 1
  }
d2120 1
a2120 1
/************************************************************************
d2122 12
a2133 11
 ************************************************************************/
char *makestr(str)
char *str;
{
  char *copy;
  int len;
  
  len = strlen(str);
  if (copy=malloc(len+1))
    strcpy(copy,str);
  return(copy);
d2136 1
a2136 1
/************************************************************************
d2138 13
a2150 12
 ************************************************************************/
char *issub(string, sub)
char   *string;
char   *sub;
{
  int   len;

  len = strlen(sub);
  for (; *string; string++)
    if (!strncmp(string, sub, len))
      return (string);
  return (0);
d2153 1
a2153 1
/***********************************************************************
d2155 12
a2166 11
 ***********************************************************************/
void EnvOptions(name)
char *name;
{
  char buffer[80];
  register char *np,*bp;

  for (np=name,bp=buffer; *np; np++,bp++)
    *bp = islower(*np) ? toupper(*np) : *np;
  *bp = 0;
  OptionLine(getenv(buffer));
d2169 1
a2169 1
/************************************************************************
d2172 4
a2175 3
 ************************************************************************/
unsigned long Dot2Addr(dot)
char *dot;
d2177 13
a2189 11
  unsigned long addr = 0;
  
  do
  {
    addr <<= 8;
    addr |= atoi(dot);
    while (isdigit(*dot)) dot++;
    if (*dot) dot++;
  }
  while (*dot);
  return((unsigned long)htonl(addr));
a2190 1

@


5.0
log
@email authentication
@
text
@d86 5
a90 5
#include descrip    /* VMS descriptor structures defs */
#include iodef      /* VMS I/O function definitions */
#include ssdef      /* VMS System Status definitions */
#include ttdef      /* VMS terminal characteristics */
#include "termdefs.h"   /* VMS defs for setterm() function */
d93 2
a94 2
static char *rcsid = "$Date: 92/01/31 10:57:57 $$Revision: 4.14 $";
static char *srcid = "$Source: /nameserv/Src/Ph/RCS/ph.c,v $";
d124 3
a126 1

d130 5
a134 4
#define MAXSTR      2048  /* max string length */
#define MAXVAL      14000   /* max value length */
#define DELIM       " \t\n"/* command delimiters */
#define MAXARGS	    20    /* maximum # of arguments in PH environ var. */
d142 2
a143 2
char *strchr();             /* VMS equivalent of "index" */
char *strrchr();            /* VMS equivalent of "rindex" */
d210 2
a211 2
int  ToQI;		/* write to this to tell the nameserver stuff */
int  FromQI;		/* read nameserver responses from here */
d214 1
a214 1
#define qprintf		\	/* this is fairly sneaky... */
d218 1
a218 1
#define qflush(foobar)		\	/* compound sneakiness */
d223 2
a224 2
FILE   *ToQI;		/* write to this to tell the nameserver stuff */
FILE   *FromQI;		/* read nameserver responses from here */
d228 6
a233 5
char  MyAlias[MAXSTR];  /* currently logged-in alias */
char   *Me;		/* the name of this program */
char *MyPassword=NULL;  /* password read from .netrc (if any) */
char *MailDomain=MAILDOMAIN;	/* mail domain */
int LocalPort=0;	/* local port in use */
d237 11
a247 10
int NoNetrc = 0;	/* -n don't read .netrc */
char *UseHost = 0;	/* -s use server on what machine */
int UsePort = 0;	/* -p use port # */
int NoReformat=0;	/* -i don't reformat email fields */
int NoPager=0;		/* -m don't use pager */
int NoBeautify=0;	/* -b don't beautify output */
int NoLabels=0;		/* -l don't use labels */
int Confirm=0;		/* -c confirm Edit */
char *DefType=0;	/* -t prepend this type to queries */
char *ReturnFields=NULL;/* -f give list of fields */
d263 1
a263 1
char *temps;          /* temp strings */
d303 2
a304 2
  if (argc==0)
    Interactive();      /* no arguments--interactive mode */
d307 1
a307 1
    /* make a query out of the arguments */
d309 1
a309 1
    temps = "query ";
d319 1
a319 1
    strcpy(buffer,"query ");
d344 4
a347 4
  int   sock;         /* our socket */
  static struct sockaddr_in QI;    /* the address of the nameserver */
  struct servent *theNs;    	   /* nameserver service entry */
  static struct hostent *theHost;  /* host entry for nameserver */
d357 1
a357 1
  /* find the proper port */
d367 1
a367 1
    QI.sin_port = htons(FALLBACKPORT);
d370 1
a370 1
  /* find the proper host */
d380 1
a380 1
    /* create the socket */
d386 3
d390 1
d395 1
a395 1
      QI.sin_addr.s_addr = htonl(FALLBACKADDR);
d403 1
a403 1
    /* connect to the nameserver */
d421 1
a421 1
  /* open path to nameserver */
d423 2
a424 2
  ToQI = sock;        /* copy socket channel for netwrite calls */
  FromQI = sock;            /* ditto for netread calls */
d432 1
a432 1
  /* open path from nameserver */
d469 1
a469 1
  while (GetGood(scratch, MAXSTR, FromQI))  /* read it */
d491 1
a491 1
  return(code ? 200 : 500);  /* only fail if the cnxn broke */
d503 1
a503 1
int doPaging;       /* use the pager? */
d505 2
a506 2
  char  scratch[MAXSTR];  /* some space */
  int   code=LR_ERROR;         /* the reply code */
d510 1
a510 1
  while (GetGood(scratch, MAXSTR, FromQI))  /* read it */
d513 1
a513 1
    if (doPaging!= -1 || code>=400) fputs(scratch, theOutput);   /* echo it */
d523 1
a523 1
  return (code);        /* all done.  return final code */
d531 2
a532 2
char   *theString;        /* space to put the chars */
int   maxChars;         /* max # of chars we want */
d534 1
a534 1
int   theFile;        /* stream to read them from */
d550 1
a550 1
    linp = index(Qbuf+pos, '\n');   /* find next newline char */
d552 1
a552 1
      end = len;          /* no newline chars left */
d554 1
a554 1
      end = linp - Qbuf;      /* convert pointer to index */
d558 1
a558 1
    pos = end + 1;          /* save new position for next time */
d560 1
a560 1
FILE  *theFile;             /* stream to read them from */
d572 1
a572 1
      return (1);     /* not a comment; success! */
d584 1
a584 1
  fprintf(stderr, "I'm going to use port %d in the meantime.\n", FALLBACKPORT);
d595 1
a595 1
  fprintf(stderr, "I'm going to use address 0x%x in the meantime.\n",
d605 3
a607 3
  char   *cName;        /* the name of the command */
  int   cLog;         /* must be logged in to use? */
  int   (*cFunc) ();    /* function to call for command */
d646 1
a646 1
int LastCode = 0;	/* the response from the previous command */
d649 1
a649 1
  char  inputLine[MAXSTR];  /* space for an input line */
d652 1
a652 2
  *MyAlias = 0;         /* nobody logged in yet... */
#ifndef MACC
a653 6
  printf("Send mail to %s to get your password (see \"help password\").\n",PASSW);
  printf("Mail other questions or comments to %s.\n",ADMIN);
#else
  printf("Lookup - ELECTRONIC MAIL DIRECTORY SERVICE\n\n");
  printf("Please mail questions or comments to %s.\n",ADMIN);
#endif
d678 1
a678 1
    (void) fflush(stdout);  /* prompt */
d682 1
a682 1
	return;        /* read line */
d693 2
a694 2
    if (!(LastCode=DoCommand(inputLine)))   /* is it a command we know? */
      LastCode = DoOther(inputLine);    /* unrecognized command */
d702 1
a702 1
char   *inputLine;        /* the input line */
d704 3
a706 3
  char  scratch[MAXSTR];  /* some space */
  char   *theToken;       /* a token from the command line */
  Command *theCommand;    /* the command name */
d710 1
a710 1
  /* make a safe copy of the input line, so we can play with it */
d714 1
a714 1
    return (LR_ERROR);       /* blank line */
d716 1
a716 1
  /* search command table linearly */
d722 1
a722 1
      if (doMe)       /* we found 2 commands that match (bad) */
d727 1
a727 1
      doMe = theCommand;  /* we found a command that matches */
d730 1
a730 1
  if (doMe)           /* found one and only one command */
d732 1
a732 1
    /* expand command name */
d736 1
a736 1
    /* execute command */
d744 1
a744 1
  return (0);         /* didn't find it */
d753 1
a753 1
  qprintf(ToQI,"%s",inputLine);   /* send command */
d755 1
a755 1
  return (PrintResponse(1));  /* get response */
d764 1
a764 1
  qprintf(ToQI,"%s",inputLine);   /* send command */
d766 1
a766 1
  return (PrintResponse(0));  /* get response */
d816 1
a816 1
    qprintf(ToQI,"%s",inputLine);   /* send command */
d823 1
a823 1
      qprintf(ToQI,"query type=\"%s\" %s\n",DefType,args);   /* send command */
d840 3
a842 3
  char  encryptMe[MAXSTR];  /* string from nameserver */
  char  encrypted[MAXSTR];  /* string from ns, encrypted */
  char   *password;       /* user's nameserver password */
d847 2
a848 2
  (void) strtok(scratch,DELIM);	/* the login part of the command */
  if (!strtok(0,DELIM))		/* check for an alias */
d850 1
a850 1
    printf("Enter nameserver alias: ");	/* ask for missing alias */
d857 1
a857 1
  qprintf(ToQI,"%s",inputLine);   /* send login request */
d860 1
a860 1
  for (;;)          /* read the response */
d868 1
a868 1
    if (code != LR_LOGIN)   /* intermediate or strange response */
d870 1
a870 1
    if (code >= LR_OK)    /* final response */
d876 1
a876 1
     /* the nameserver has issued a challenge */
d885 2
a886 2
      /* encrypt the challenge with the password */
      encryptMe[strlen(encryptMe) - 1] = '\0';    /* strip linefeed */
d889 1
a889 1
      /* send the encrypted text to qi */
d894 1
a894 1
    /* get the final response */
d905 1
a905 1
      if (code >= LR_OK)  /* final response */
d910 1
a910 1
  if (code == LR_OK)      /* logged in */
d947 1
a947 1
  (void) strtok(inputLine, DELIM);  /* skip ``edit'' */
d981 1
a981 1
  static char theValue[MAXVAL];     /* will hold the value */
d992 1
a992 1
  /* do the query */
d998 1
a998 1
  /* read qi response lines, concatenating the responses into one value */
d1007 1
a1007 1
      strcpy(vSpot, index(GetQValue(scratch), ':') + 2);  /* part of value */
d1010 1
a1010 1
      break;        /* final response */
d1012 1
a1012 1
      fputs(scratch, stdout);   /* ??? */
d1015 1
a1015 1
  if (code != LR_OK)      /* error */
d1025 1
a1025 1
char   *theValue;         /* the value to edit */
d1027 1
a1027 1
  char   *theFileName;    /* name of temp file to use */
d1036 4
a1039 4
  int   fd;         /* file descriptor for temp file */
  static char newValue[MAXVAL];     /* new value */
  char   *editor;           /* editor program to use */
  int   bytes;            /* numnber of bytes in file */
d1041 2
a1042 1
  int   badChar;          /* did we find a bad character? */
d1044 3
d1049 1
a1049 1
  /* put the value into a temp file */
d1055 1
a1055 1
  strcat (f1, ";1");      /* versions needed for delete function */
d1077 1
a1077 1
  /* run an editor on the temp file */
d1085 1
a1085 1
  cli_input.dsc$w_length = strlen(edit_command);  /* descriptor for spawn */
d1104 1
a1104 1
    (void) wait((union wait *)&junk);
d1113 1
a1113 1
  /* does the user want the value? */
d1124 1
a1124 1
  /* read the value back out */
d1145 2
a1146 2
    (void) delete (f1);   /* delete 1st temp file */
    (void) delete (f2);   /* delete 2nd temp file */
d1152 2
a1153 2
  (void) delete (f1);     /* delete 1st temp file */
  (void) delete (f2);     /* delete 2nd temp file */
d1157 1
a1157 1
  /* did the value change? */
d1162 1
a1162 1
  /* copy new value into old, stripping bad characters */
d1182 1
a1182 1
      if (*(from + 1))  /* skip terminating newline from vi */
d1193 1
a1193 1
  if (badChar)        /* complain if we found bad characters */
d1279 1
d1348 1
a1348 11
  }
 
  if (LocalPort)
  {
    char scratch[MAXSTR];
    LocalPort = 0;
    sprintf(scratch,"login %s\n",MyAlias);
    DoLogin(scratch);
    if (!*MyAlias) return(LR_ERROR);
  }
  
d1350 1
a1350 1
  /* which alias to use? */
d1355 1
a1355 1
  /* get the password */
d1364 1
a1364 1
  VetPassword(confirm);     /* complain if we don't like the password */
d1366 4
a1369 3
  /* encrypt and send the password */
  password[encryptit(password, confirm)] = '\0';
  qprintf(ToQI, "change alias=%s make password=%s\n", theAlias, password);
d1372 1
a1372 1
  /* see what the nameserver says */
d1394 2
a1395 2
  if (strlen(thePassword) < 5 ||    /* too short */
    AllDigits(thePassword)) /* digits only */
d1431 1
a1431 1
  *alias = *email = 0;		/* haven't found an alias yet */
d1433 1
a1433 1
  /* get the response */
d1442 2
a1443 2
	fprintf(theOutput,"\n%s\n",cp+1); /* strchr returns pointer to : then add one */
#endif MACC
d1450 1
a1450 1
      /* output a delimiter */
d1486 1
a1486 1
      /* output the line */
d1493 1
a1493 1
      fputs(theLine, theOutput);  /* error */
d1502 1
a1502 1
	/* output the line */
d1512 1
a1512 1
  /* final "delimiter" */
d1525 1
a1525 1
#ifndef NeXT
d1567 1
a1567 1
/*        setterm.c
d1587 1
a1587 1
  /* get event flag */
d1591 1
a1591 1
  /* get channel to terminal */
d1595 1
a1595 1
  /* if characteristic is BROADCAST, ECHO, or TYPEAHEAD, state must be toggled */
d1601 1
a1601 1
  /* get current mode */
d1605 1
a1605 1
  /* change characteristics buffer */
d1611 1
a1611 1
  /* $ SET TERM/...  and then deassign channel */
d1633 1
a1633 1
  printf(prompt); (void) fflush(stdout);        /* prompt */
d1647 7
a1653 7
  FILE *netrc;    /* the .netrc file */
  char pathName[1024];/* pathname of .netrc file */
  struct stat theStat;/* permissions, etc. of .netrc file */
  char key[80], val[80];    /* line from the .netrc file */
  char *token;    /* token (word) from the line from the .netrc file */
  char *alias=NULL;   /* the user's alias */
  char *pw=NULL;    /* the user's password */
d1666 1
a1666 1
    return;             /* refuse insecure files */
d1686 1
a1686 1
	if (!strcmp(key,"machine"))     /* new machine */
d1775 3
a1777 3
  token = strtok(scratch+4,DELIM);	/* the word after help */
  if (token && !strcmp(token,"native")) /* looking for native help */
    strcpy(scratch,inputLine);		/* leave the command alone */
d1779 1
a1779 1
    sprintf(scratch,"help %s %s",CLIENT,inputLine+4); /* insert identifier */
d1781 1
a1781 1
  qprintf(ToQI,"%s",scratch);   /* send command */
d1795 2
a1796 2
  char *emSpot;		/* beginning of email account */
  char *alSpot;		/* beginning of nameserver alias */
d1808 1
a1808 1
    alSpot[-2] = ':';	/* strcpy clobbered the colon; repair */
d1811 2
a1812 2
    strcpy(email,alias);		/* leave it in the "email" line */
    *alias = 0;			/* we're done with the alias */
d1832 1
a1832 1
  /* output the line */
d1837 1
a1837 1
  *alias = 0; 				/* done with alias */
d1869 2
d1985 1
a1985 1
  return(stdout);     /* simpler to skip paging for right now */
d2049 21
@


4.14
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 91/08/08 13:24:44 $$Revision: 4.13 $";
a349 2
  if (sock < 0)
    return (0);
d405 1
a405 1
        return (0);
d1347 1
a1347 1
    sprintf(scratch,"login %s",MyAlias);
@


4.13
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 91/04/23 14:12:07 $$Revision: 4.11 $";
d110 1
d229 1
d253 1
d347 2
a349 2
  /* create the socket */
  sock = socket(PF_INET, SOCK_STREAM, 0);
d374 1
d378 2
a379 3
    sock = socket(PF_INET, SOCK_STREAM, 0);
    if (sock < 0)
      return (0);
d393 1
a393 1
      return(0);
d399 1
d422 1
a422 1
    return (0);
d429 1
a429 1
    return (0);
d434 5
a438 2
  
  return (1);
d559 6
a564 1
    if (*theString != '#')
a565 3
    else
    if (!*theString)
      return (0);     /* empty string==end of stream */
d856 1
d876 16
a891 11
    /* the nameserver has issued a challenge */
    password = MyPassword ? MyPassword :
		  getpass("Enter nameserver password: ");
    crypt_start(password);

    /* encrypt the challenge with the password */
    encryptMe[strlen(encryptMe) - 1] = '\0';    /* strip linefeed */
    encrypted[encryptit(encrypted, index(encryptMe, ':') + 1)] = '\0';

    /* send the encrypted text to qi */
    qprintf(ToQI, "answer %s\n", encrypted);
d903 1
d914 1
a914 1
    VetPassword(password);  /* make sure password is reasonable */
d1319 1
a1319 1
           && strcmp(pw->pw_name,"phones"))
d1322 1
a1322 1
                  MyAlias,pw->pw_name,hostname);
d1344 10
d1691 1
a1691 5
	{
	    if (alias) {free(alias);alias=NULL;}
	    if (pw) {free(pw);pw=NULL;}
	    break;
	}
a1697 2
	if (alias && pw && TryLogin(alias,pw))
	  goto done;
d1703 2
a1704 1
done:
d1751 1
a1751 1
  while (*password) *password++ = 'x';
@


4.12
log
@No help here.
@
text
@d108 2
d181 1
d604 1
d1270 1
d1277 30
@


4.11
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 91/02/06 07:24:53 $$Revision: 4.10 $";
d1713 10
a1722 1
  strcpy(scratch,inputLine);
@


4.10
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 91/02/05 10:13:44 $$Revision: 4.9 $";
d107 1
d224 1
d291 1
d425 1
a425 1
  UseHost = theHost->h_name;
d441 36
d930 1
a930 1
    (void) DoCommand("help edit\n");
d1375 1
a1375 1
  if (NoReformat) reformatEmail=0;
d1748 1
a1748 1
    sprintf(scratch,"@@%s (%s)\n",MAILDOMAIN,emSpot);
d1813 1
d1821 1
@


4.9
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 90/10/30 11:43:59 $$Revision: 4.8 $";
d532 2
a533 1
void ComplainAboutHost(char *name)
d777 1
a777 1
  code = (NoBeautify ? PrintResponse(1) : PrintQResponse(1));
d1168 1
a1168 1
  return(NoBeautify ? PrintResponse(0) : PrintQResponse(0));
d1319 1
a1319 1
int PrintQResponse(reformatEmail)
d1321 1
d1391 2
a1392 2
      if (NoLabels)
        fputs(rindex(theLine,':')+2, theOutput);
d1407 2
a1408 2
	if (NoLabels)
	  fputs(rindex(email,':')+2, theOutput);
d1683 1
a1683 1
  return (NoBeautify ? PrintResponse(0) : PrintQResponse(0));
@


4.8
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 90/03/29 09:52:26 $$Revision: 4.4 $";
d334 4
d359 3
a361 4
  if (theHost = gethostbyname(UseHost ? UseHost : HOST))
  {
    bcopy(theHost->h_addr, (char *) &QI.sin_addr.s_addr, 4);
  }
d363 3
d367 33
a399 2
    ComplainAboutHost();
    QI.sin_addr.s_addr = htonl(FALLBACKADDR);
d402 2
a403 7
  /* connect to the nameserver */
  if (connect(sock, (struct sockaddr *)&QI, sizeof(QI)) < 0)
  {
    perror("connect");
    return (0);
  }

d532 1
a532 1
void ComplainAboutHost()
d535 1
a535 1
    UseHost ? UseHost : HOST);
d885 1
d898 11
a908 2
    if ((theCode=UpdateValue(theAlias, theField, theValue))<300 &&
      !strcmp(theField,"alias"))
d910 1
d1390 1
a1390 1
        fputs(index(GetQValue(theLine),':')+2, theOutput);
d1406 1
a1406 1
	  fputs(index(GetQValue(email),':')+2, theOutput);
@


4.7
log
@No help here.
@
text
@d738 1
a738 1
      qprintf(ToQI,"query type=\"%s\" %s",DefType,args);   /* send command */
@


4.6
log
@No help here.
@
text
@d126 1
a126 1
#define DELIM       " ,\t\n"/* command delimiters */
@


4.5
log
@No help here.
@
text
@d235 1
d390 1
a390 1
  UseHost = theHost ? theHost->h_name : HOST;
d558 1
d594 9
a602 3

    if (!fgets(inputLine, MAXSTR, stdin))
      break;        /* read line */
d719 6
d738 1
a738 1
      qprintf(ToQI,"query type=\"%s\" %s\n",DefType,args);   /* send command */
d1163 6
d1757 21
@


4.4
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 90/01/23 08:49:37 $$Revision: 4.3 $";
d389 1
a389 1
  UseHost = theHost->h_name;
@


4.3
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 90/01/18 10:45:47 $$Revision: 4.2 $";
d233 1
d926 1
d992 11
d1037 2
a1038 1
  if (!strcmp(newValue, theValue))
d1139 4
d1702 2
@


4.2
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 90/01/17 16:18:25 $$Revision: 4.1 $";
d156 2
a157 1
void main();
d237 1
a237 1
void main(argc, argv)
d286 1
a286 1
  DoId();
d422 3
a424 2
    if (doPaging!= -1) fputs(scratch, theOutput);   /* echo it */
    if ((code = atoi(scratch)) >= LR_OK)
d707 8
d729 3
a731 1
  return (NoBeautify ? PrintResponse(1) : PrintQResponse(1));
d1812 1
a1812 1
issub(string, sub)
d1821 1
a1821 1
      return (1);
@


4.1
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 89/10/18 07:51:32 $$Revision: 4.0 $";
d161 1
d176 1
d261 7
a267 1
  OptionLine(getenv("PH"));
d311 2
a312 2
    fputs("\nquit\n", ToQI);
    fflush(ToQI);
d521 1
a521 1
  "ph", 0, DoQuery,
d524 1
d703 2
d709 7
a715 3
    char *nl=index(inputLine,'\n');
    if (nl) *nl = 0;
    qprintf(ToQI,"%s type=\"%s\"\n",inputLine,DefType);   /* send command */
d1113 1
a1113 1
    printf("  Default field type is %s; use \"switch -%c%s\" to set it to %s.\n",
d1117 1
d1127 19
d1311 5
a1315 1
	fputs(GetQValue(email),theOutput);
d1488 1
a1488 1
    if (!strcmp(key,"machine") && !strcmp(val,"ph"))
d1637 5
a1641 1
  fputs(GetQValue(scratch), theOutput);
d1811 15
@


4.0
log
@All sorts of nifty new features.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 89/10/10 15:49:18 $$Revision: 4.0 $";
d151 1
d229 2
d240 1
d294 1
a294 1
    fputs("query ", ToQI);
d297 1
a297 1
      fputs(*argv, ToQI);
d299 1
a299 1
	putc(' ', ToQI);
d301 2
a305 3

    /* print what the nameserver says */
    theCode = NoBeautify ? PrintResponse(1) : PrintQResponse(1);
d588 2
a589 2
    if (!(LastCode=DoCommand(inputLine, 0)))   /* is it a command we know? */
      LastCode = DoOther(inputLine, 0);    /* unrecognized command */
d694 9
a702 1
  qprintf(ToQI,"%s",inputLine);   /* send command */
d815 1
a815 1
    DoEdit(inputLine, 1);
d1094 9
d1201 1
d1237 1
d1245 1
d1252 1
d1255 4
d1261 4
a1264 1
      fputs(GetQValue(theLine), theOutput);
d1627 2
d1632 2
a1633 1
	    UseHost = *argv + 1;
d1638 3
a1640 2
	    UseHost = argv[1];
	    argc--,argv++;
d1646 21
d1676 1
a1676 1
	    argc--,argv++;
d1737 31
@


3.15
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 89/07/25 07:52:43 $$Revision: 3.14 $";
d113 1
d117 1
d127 1
a127 1

d149 1
d151 40
d198 12
a209 2
int  ToQI;      /* write to this to tell the nameserver stuff */
int  FromQI;      /* read nameserver responses from here */
d211 4
a214 2
FILE   *ToQI;       /* write to this to tell the nameserver stuff */
FILE   *FromQI;     /* read nameserver responses from here */
d216 12
a227 5
char  MyAlias[40];      /* currently logged-in alias */
int   TestVersion = 0;    /* is this the test version of ph? */
char   *Me;           /* the name of this program */
char *MyPassword=NULL;      /* password read from .netrc (if any) */

d231 1
a231 1
main(argc, argv)
d235 2
a236 1
  int theCode;
d255 4
a258 1
  TestVersion = !strcmp(Me, "th");
d274 1
a274 16
#ifdef MACC_ECHO
	margc = argc;

  if (argc >= 1)
 if (!strcmp(argv[1],"-e"))
 {
   maccecho = 1;
   margc=1;
 }

#endif
#ifdef MACC_ECHO
  if (margc == 1)
#else
  if (argc == 1)
#endif
d282 1
a282 1
    for (argc--, argv++; argc; argc--, argv++)
d291 1
a291 1
    for (argc--, argv++; argc; argc--, argv++)
d302 1
a302 1
    theCode = PrintQResponse();
d314 1
a314 1
ContactQI()
d317 3
a319 3
  struct sockaddr_in QI;    /* the address of the nameserver */
  struct servent *theNs;    /* nameserver service entry */
  struct hostent *theHost;  /* host entry for nameserver */
d328 3
a330 1
  if (theNs = getservbyname(TestVersion ? "nstest" : NSSERVICE, "tcp"))
d341 1
a341 1
  if (theHost = gethostbyname(HOST))
d355 1
a355 1
    return (NULL);
d366 1
a366 1
    return (NULL);
d373 1
a373 1
    return (NULL);
d376 2
d385 1
a385 1
DoId()
d387 2
a388 2
  fprintf(ToQI,"id %d\n",getuid());
  fflush(ToQI);
d400 1
a400 1
PrintResponse(doPaging)
d404 1
a404 2
  int   code;         /* the reply code */
  char   *thePager;
d407 1
a407 14
  if ((thePager = getenv("PAGER")) == NULL)
#ifdef hpux
    thePager = "/usr/bin/more";
#else
    thePager = "/usr/ucb/more";
#endif
  
#ifdef VMS
  theOutput = stdout;     /* simpler to skip paging for right now */
#else
  if (doPaging!=1 || (theOutput = popen(thePager, "w")) == NULL)
    theOutput = stdout;
#endif

d427 1
a427 1
GetGood(theString, maxChars, theFile)
d474 1
a474 1
ComplainAboutService()
d485 1
a485 1
ComplainAboutHost()
d487 2
a488 1
  fprintf(stderr, "Warning--unable to find address for ``%s''.\n", HOST);
a501 1
  char   *cHelp;        /* help string for the command */
a503 3
int DoHelp(), DoQuery(), DoLogin(), DoQuit(), DoEdit(), DoPassword();
int DoLogout(), DoMe(), DoOther(), DoOtherWPage(), DoFields();

d506 3
a508 3
 "help", 0, DoHelp, "\tprint this message.",
 "?", 0, DoHelp, "\tprint this message.",
 "query", 0, DoQuery, "\tquery the database.",
d510 7
a516 7
 "ph", 0, DoQuery, "\tsynonym for query.",
 "me", 1, DoMe, "\tprint entry for current user.",
 "edit", 1, DoEdit, "\tedit (add, delete, or change) a field from your entry.",
 "password", 1, DoPassword, "change your nameserver password.",
 "passwd", 1, DoPassword, "\tsynonym for password.",
 "login", 0, DoLogin, "\tlogin to the nameserver.",
 "logout", 1, DoLogout, "\tlog out of the nameserver.",
d519 1
a519 1
"fields", 0, DoFields, "\tlist nameserver database fields.",
d521 2
a522 1
 "fields", 0, DoOther, "\tlist nameserver database fields.",
d525 3
a527 3
 "add", 1, DoOther, "\tadd people to the nameserver database (privileged).",
 "delete", 1, DoOther, "\tdelete people from the nameserver database (privileged).",
 "set", 0, DoOther, "\tset nameserver options.",
d529 4
a532 4
 "quit", 0, DoQuit, "\texit ph.",
 "bye", 0, DoQuit, "\tsynonym for quit.",
 "exit", 0, DoQuit, "\tsynonym for quit.",
 0, 0, 0, 0
d539 1
a539 1
Interactive()
d546 1
a546 1
  printf("Send mail to %s to get your password.\n",PASSW);
d562 1
a562 1
  DoAutoLogin();
d566 1
a566 1

d569 1
d593 1
a593 1
DoCommand(inputLine, helpOnly)
a594 1
int   helpOnly;         /* 1 if we should just print help */
d626 1
a626 2
    if (!helpOnly)
      sprintf(inputLine, "%s %s\n", doMe->cName, theToken ? theToken : "");
d632 1
a632 1
      return((*doMe->cFunc) (inputLine, helpOnly));
d642 1
a642 1
DoOtherWPage(inputLine, helpOnly)
a643 1
int   helpOnly;
d645 2
a646 12
  if (helpOnly)
  {
    puts("\tNo further help available.");
    return(LR_ERROR);
  }

#ifdef VMS
  netwrite(ToQI, inputLine, strlen(inputLine));
#else
  fputs(inputLine, ToQI);   /* send command */
  fflush(ToQI);
#endif
d653 1
a653 1
DoOther(inputLine, helpOnly)
a654 1
int   helpOnly;
d656 2
a657 12
  if (helpOnly)
  {
    puts("\tNo further help available.");
    return(LR_ERROR);
  }

#ifdef VMS
  netwrite(ToQI, inputLine, strlen(inputLine));
#else
  fputs(inputLine, ToQI);   /* send command */
  fflush(ToQI);
#endif
d662 1
a662 1
DoFields(inputLine, helpOnly)
a663 1
int   helpOnly;
a682 70
/***********************************************************************
* give the user help
***********************************************************************/
DoHelp(inputLine, helpOnly)
char   *inputLine;
int   helpOnly;
{
printf("********************************************************************************\n");
printf("*                               Lookup Help                                    *\n");
printf("*           mail any questions, problems, or comments to: emds@@wisc.edu        *\n");
printf("********************************************************************************\n");
printf("*     query \"name\" [field=\"string\"] [return field(s)]                          *\n");
printf("*                                                                              *\n");
printf("*     where:    \"field\" is an argument that helps narrow the search (optional) *\n");
printf("*               \"return\" selects fields to print (optional)                    *\n");
printf("*                                                                              *\n");
printf("*     Examples:  ( * is a wildcard character)                                  *\n");
printf("*                query john doe  (or   query doe)                              *\n");
printf("*                query john doe department=\"engineering\"                       *\n");
printf("*                query john doe title=\"professor\"                              *\n");
printf("*                query john doe return phone email department                  *\n");
printf("*                query j* doe email=doe* return name email                     *\n");
printf("*                query jo* doe building=\"computer science*\"                    *\n");
printf("********************************************************************************\n");
printf("* cmds:  (The Lookup User Guide is available at the MACC Lobby Desk)           *\n");
printf("*       query  - see above                                                     *\n");
printf("*      fields  - lists the field names in the database                         *\n");
printf("*   ? or help  - prints this message                                           *\n");
printf("*        exit  - exits emds (quit or bye work also)                            *\n");
printf("********************************************************************************\n");
  return(LR_OK);
}
#else

/***********************************************************************
* give the user help
***********************************************************************/
DoHelp(inputLine, helpOnly)
char   *inputLine;
int   helpOnly;
{
  char   *theToken;
  Command *theCommand;

  if (helpOnly)
  {
    puts("\tUsage: help [command...]");
    puts("");
    puts("\tSaying just ``help'' will print a list of commands.");
    puts("\tSaying ``help command'' will print help for that command.");
    return(LR_OK);
  }

  inputLine[strlen(inputLine) + 1] = '\0';  /* extra terminator */
  strtok(inputLine, DELIM);   /* skip command name */

  if (theToken = strtok((char *) 0, DELIM))
    do            /* help something */
    {
      puts(theToken);   /* print command name */
      if (!DoCommand(theToken, 1))
	puts("\tNo help--command unknown to ph.");
      inputLine = theToken + strlen(theToken) + 1;    /* next token */
    }
    while (theToken = strtok(inputLine, DELIM));
  else            /* just plain help */
  for (theCommand = CommandTable; theCommand->cName; theCommand++)
    printf("%s\t%s\n", theCommand->cName, theCommand->cHelp);
  return(LR_OK);
}
d688 1
a688 1
DoQuery(inputLine, helpOnly)
a689 1
int   helpOnly;
d691 3
a693 29
  if (helpOnly)
  {
    puts("\tUsage: query [field=]value... [return field...]");
    puts("");
    puts("\tQuery does nameserver lookups.  Entries that match the");
    puts("\tspecifications are printed.  If ``return'' is specified,");
    puts("\tonly the fields named after the ``return'' will be printed.");
    puts("\tIf the ``field='' is omitted in the query portion,");
    puts("\t``name='' will be assumed.  To be selected, an entry");
    puts("\tmust match all the specifications.  Standard metacharacters");
    puts("\tmay be used.  Since no shell is interpreting the input, there");
    puts("\tis no need to escape metacharacters.");
    puts("\t");
    puts("\tA list of candidates for ``field'' may be obtained by using the");
    puts("\t``fields'' command.  Any field marked with ``Lookup'' may be");
    puts("\tused in a query.  At least one field marked with ``Indexed''");
    puts("\tMUST be included in each query.  Any field marked ``Public''");
    puts("\tmay be requested after a ``return''.");

    return(LR_OK);
  }

#ifdef VMS
  netwrite(ToQI, inputLine, strlen(inputLine));
#else
  fputs(inputLine, ToQI);
  fflush(ToQI);
#endif
  return (PrintQResponse());
d699 1
a699 1
DoLogin(inputLine, helpOnly)
a700 1
int   helpOnly;
a704 1
  char   *getpass();
d706 1
a706 4
#ifdef VMS
  char temps[MAXSTR];     /* space for temp strings */
  int len;
#endif
d708 3
a710 1
  if (helpOnly)
d712 4
a715 9
    puts("\tUsage: login your_alias");
    puts("");
    puts("\tUse login to identify yourself to the nameserver.");
    puts("\tSay ``login your_alias'', where your_alias is your nameserver alias.");
    puts("\tTo find your alias, say ``query your_name return alias''.");
    puts("\tYou will be prompted for your password.  If you do not know it,");
    printf("\tsend mail to %s.  Include your full",PASSW);
    puts("\tname in your message.");
    return(LR_OK);
d718 2
a719 6
#ifdef VMS
  netwrite(ToQI, inputLine, strlen(inputLine));     /* send the login request */
#else
  fputs(inputLine, ToQI);   /* send the login request */
  fflush(ToQI);
#endif
d747 2
a748 7
#ifdef VMS
    len = sprintf(temps, "answer %s\n", encrypted);
    netwrite(ToQI, temps, len);
#else
    fprintf(ToQI, "answer %s\n", encrypted);
    fflush(ToQI);
#endif
a769 1
    return(code);
a771 1
  {
d773 1
a773 2
    return(0);
  }
d779 1
a779 1
DoQuit(inputLine, helpOnly)
a780 1
int   helpOnly;
d782 1
a782 1
  DoOther("quit\n", helpOnly);
d784 1
a784 2
  if (!helpOnly)
    exit(SS$_NORMAL);
d786 1
a786 3
  if (!helpOnly)
    exit(LastCode<LR_OK || LastCode >=LR_MORE ? LastCode/100 : 0);
  return(LR_OK);
d793 1
a793 1
DoEdit(inputLine, helpOnly)
a794 1
int   helpOnly;
a800 15
  if (helpOnly)
  {
    puts("\tUsage: edit field [alias]");
    puts("");
    puts("\tEdit will retrieve the named field from the entry with the");
    puts("\tnamed alias (or the currently logged in user, if no alias");
    puts("\tis specified.)  It will then allow the value to be editted,");
    puts("\tand update the value in the database.");
    puts("\tIf the field does not exist in the selected entry,");
    puts("\tthe field will be created.  If all the contents of the");
    puts("\tfield are removed, the field will be removed from the entry.");
    puts("\tYou must be logged in (see ``login'') to use this command.");
    return(LR_OK);
  }

d821 1
a821 2
char   *
GetValue(theAlias, theField)
a828 3
#ifdef VMS
  int len;
#endif
d837 2
a838 7
#ifdef VMS
  len = sprintf(scratch,"query alias=%s return %s\n",theAlias,theField);
  netwrite(ToQI,scratch,len);
#else
  fprintf(ToQI, "query alias=%s return %s\n", theAlias, theField);
  fflush(ToQI);
#endif
d868 1
a868 1
EditValue(theValue)
d1033 1
a1033 1
UpdateValue(theAlias, theField, theValue)
d1038 2
a1039 3
#ifdef VMS
char temps[MAXSTR];           /* space for temp strings */
int len;
a1040 7
  len = sprintf(temps,"change alias=%s make %s=\"%s\"\n",theAlias,theField,theValue);
  netwrite(ToQI,temps,len);
#else
  fprintf(ToQI, "change alias=%s make %s=\"%s\"\n", theAlias, theField, theValue);
  fflush(ToQI);
#endif

a1042 1
#ifndef MACC
d1044 1
a1044 1
* print list of nameserver fields
d1047 1
a1047 1
DoFields(inputLine, helpOnly)
a1048 1
int   helpOnly;
d1050 1
a1050 6
  char  scratch[MAXSTR];
#ifdef VMS
  int len;
#endif

  if (helpOnly)
d1052 1
a1052 17
    puts("\tUsage: fields");
    puts("\tThis command lets you see the fields defined in the Nameserver");
    puts("\tdatabase.  Each field will produce two lines of output, similar");
    puts("\tto the following:");
    puts("\t    -200:2:email:max 128 Indexed Lookup Public Default Change");
    puts("\t    -200:2:email:Preferred electronic mail address.");
    puts("\tThis field is called ``email,'' and can be 128 characters long.");
    puts("\t``Indexed'' means the field is in the nameserver index (at least");
    puts("\tone Indexed field MUST appear in each query).");
    puts("\t``Lookup'' means the field can be used in a query.");
    puts("\t``Public'' means the field can be viewed by anyone.");
    puts("\t``Default'' means the field is printed on queries that do not");
    puts("\tspecify which fields should be printed.");
    puts("\t``Change'' means the field can be changed by the owner of the entry.");
    puts("\tThe second line is a short description of the field.");

    return(LR_OK);
d1055 4
a1058 1
  return(DoOtherWPage(inputLine,helpOnly));
a1060 1
#endif
d1062 1
a1062 1
* print info on current user
d1064 1
a1064 2
/*ARGSUSED*/
DoMe(inputLine, helpOnly)
a1065 1
int   helpOnly;
d1067 2
a1068 6
  char  scratch[MAXSTR];
#ifdef VMS
  int len;
#endif

  if (helpOnly || !*MyAlias)
d1070 16
a1085 5
    puts("\tUsage: me");
    puts("\tThis command prints the nameserver entry for the currently");
    puts("\tlogged in user.  Naturally, you must be logged in to use it;");
    puts("\tsee ``login.''");
    return(LR_OK);
d1087 1
a1087 11

#ifdef VMS
  len = sprintf(scratch,"query alias=%s\n",MyAlias);
  netwrite(ToQI,scratch,len);
#else
  sprintf(scratch, "query alias=%s return all\n", MyAlias);
  fputs(scratch, ToQI);
  fflush(ToQI);
#endif

  return(PrintQResponse());
d1093 1
a1093 1
DoPassword(inputLine, helpOnly)
a1094 1
int   helpOnly;
a1099 5
#ifdef VMS
  char *getpass();
  char temps[MAXSTR];     /* space for temp strings */
  int len;
#endif
d1101 1
a1101 1
  if (helpOnly || !*MyAlias)
d1103 1
a1103 7
    puts("\tUsage: password [alias]");
    puts("");
    puts("\tPassword will prompt you for a password (twice), and change");
    puts("\tyour (or the named user's, if you are privileged)");
    puts("\tnameserver password to what you type.  Use this command often.");
    puts("\tYou must be logged into the nameserver; see ``login''.");
    return(LR_OK);
d1113 1
a1113 1
  if (!*password) return;
d1124 2
a1125 7
#ifdef VMS
  len = sprintf(temps,"change alias=%s make password=%s\n",theAlias,password);
  netwrite(ToQI,temps,len);
#else
  fprintf(ToQI, "change alias=%s make password=%s\n", theAlias, password);
  fflush(ToQI);
#endif
d1136 1
a1136 1
DoLogout(inputLine, helpOnly)
a1137 1
int   helpOnly;
a1138 7
  if (helpOnly)
  {
    puts("\tUsage: logout");
    puts("");
    puts("\tLogs you out of the nameserver.  Does not quit ph.");
    return(LR_OK);
  }
d1140 1
a1140 1
  return(DoOther(inputLine, helpOnly));
d1146 1
a1146 1
VetPassword(thePassword)
d1157 1
a1157 1
AllDigits(theString)
d1170 2
a1171 1
PrintQResponse()
d1177 1
a1177 2
  char   *thePager;
  char   *strptr;
d1179 2
d1182 1
a1182 3
  /* always use a paging program */
  if ((thePager = getenv("PAGER")) == NULL)
    thePager = "/usr/ucb/more";
d1184 2
a1185 7
#ifdef VMS
  theOutput = stdout;
#else  
  if ((theOutput = popen(thePager,"w")) == NULL)
    theOutput = stdout;
#endif

d1193 3
a1195 3
	strptr = strchr(theLine,':');
	if ( strptr != 0)
	fprintf(theOutput,"\n%s\n",strptr+1); /* strchr returns pointer to : then add one */
d1206 8
d1217 15
d1239 8
d1248 1
d1264 1
d1304 1
d1384 1
a1384 1
DoAutoLogin()
d1453 1
a1453 1
SkipMacdef(netrc)
d1465 1
a1465 1
TryLogin(alias,password)
d1497 184
@


3.14
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 89/07/20 15:08:00 $$Revision: 3.13 $";
d906 1
a906 1
  int theCode;
@


3.13
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 89/07/20 10:39:28 $$Revision: 3.12 $";
d645 1
a670 1
#ifdef MACC
@


3.12
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Date: 89/07/19 09:52:38 $$Revision: 3.11 $";
d698 1
d1182 1
a1182 1
#ifdef MACC
@


3.11
log
@No help here.
@
text
@d93 2
a94 2
static char *rcsid = "$Date: 89/05/08 22:56:28 $$Revision: 3.10 $";
static char *srcid = "$Source: /nameserv/src/ph/RCS/ph.c,v $";
d534 1
a534 1
    printf("%s %d> ",Me,LastCode);
@


3.10
log
@No help here.
@
text
@d93 2
a94 2
static char *rcsid = "$Date: 89/05/08 22:43:56 $$Revision: 3.9 $";
static char *srcid = "$Source:$";
d151 3
d173 4
d208 2
d211 11
d223 1
d251 1
a251 1
    (void) PrintQResponse();
d256 1
a256 1
  exit(0);
d334 1
a334 1
  (void) PrintResponse(-1);
d471 1
d479 7
a485 1
 "fields", 0, DoFields, "\tlist nameserver database fields.",
d489 1
d499 1
d505 1
d509 4
d517 1
a517 1
  DoOther("status\n",0);
d522 1
d524 2
d530 2
d533 3
d540 4
d545 2
a546 2
    if (!DoCommand(inputLine, 0))   /* is it a command we know? */
      DoOther(inputLine, 0);    /* unrecognized command */
d567 1
a567 1
    return (1);       /* blank line */
d578 1
a578 1
	return (1);
d594 2
a595 2
      (*doMe->cFunc) (inputLine, helpOnly);
    return (1);
d611 1
a611 1
    return;
d620 1
a620 1
  (void) PrintResponse(1);  /* get response */
d633 1
a633 1
    return;
d642 1
a642 1
  (void) PrintResponse(0);  /* get response */
d645 22
d670 1
d675 33
d717 1
a717 1
    return;
d735 1
d737 1
d765 1
a765 1
    return;
d774 1
a774 1
  (void) PrintQResponse();
d804 1
a804 1
    return(0);
d868 1
a868 1
    return(1);
d890 2
a891 1
    exit(0);
d905 1
d919 1
a919 1
    return;
d926 1
a926 1
    return;
d933 1
a933 1
    if (UpdateValue(theAlias, theField, theValue)<300 &&
d936 1
d1181 1
a1181 1

d1213 1
a1213 1
    return;
d1216 1
a1216 1
  DoOtherWPage(inputLine,helpOnly);
d1219 1
d1239 1
a1239 1
    return;
d1251 1
a1251 1
  PrintQResponse();
d1264 1
d1279 1
a1279 1
    return;
d1294 1
a1294 1
    return;
d1309 1
a1309 1
  if (PrintResponse(0) == LR_OK && !strcmp(theAlias,MyAlias))
d1311 1
d1326 1
a1326 1
    return;
d1329 1
a1329 1
  DoOther(inputLine, helpOnly);
d1362 1
a1362 1
  int   theCode;
d1366 1
d1384 9
d1422 2
@


3.9
log
@No help here.
@
text
@d93 2
a94 1
static char *rcsid = "$Source: /nameserv/src/ph/RCS/ph.c,v $$Date: 89/04/13 19:26:39 $$Revision: 3.8 $";
d697 1
a697 1
    puts("\tsend mail to nameserv@@uiuc.edu.  Include your full");
@


3.8
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Source: /nameserv/src/ph/RCS/ph.c,v $$Date: 89/04/10 16:53:57 $$Revision: 3.7 $";
d696 1
a696 1
    puts("\tsend mail to nameserv@@uxg.cso.uiuc.edu.  Include your full");
@


3.7
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Source: /nameserv/src/ph/RCS/ph.c,v $$Date: 89/03/21 14:33:09 $$Revision: 3.6 $";
d1271 2
a1272 1
    if (theCode == -LR_OK || theCode == -LR_AINFO || theCode == -LR_ABSENT)
@


3.6
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Source: /nameserv/src/ph/RCS/ph.c,v $$Date: 89/02/07 10:55:44 $$Revision: 3.5 $";
d1424 1
a1424 1
  char line[80];    /* line from the .netrc file */
d1451 1
a1451 1
  while (fgets(line,sizeof(line),netrc))
d1453 1
a1453 2
    if ((token=strtok(line," \t\n")) && !strcmp(token,"machine") &&
      (token=strtok((char *)0," \t\n")) && !strcmp(token,"ph"))
d1458 3
a1460 2
      while (fgets(line,sizeof(line),netrc))
	if (token=strtok(line," \t\n"))
a1461 2
	  if (!strcmp(token,"machine"))     /* new machine */
	  {
d1465 6
a1470 11
	  }
	  else if (!strcmp(token,"login"))
	  {
	    if (token=strtok((char *)0," \t\n"))
	      alias=strcpy(malloc((unsigned)strlen(token)+1),token);
	  }
	  else if (!strcmp(token,"password"))
	  {
	    if (token=strtok((char *)0," \t\n"))
	      pw=strcpy(malloc((unsigned)strlen(token)+1),token);
	  }
d1472 3
a1474 3
	  if (alias && pw && TryLogin(alias,pw))
	    goto done;
	}
d1476 1
d1483 12
@


3.5
log
@No help here.
@
text
@d93 1
a93 1
static char *rcsid = "$Source: /nameserv/src/ph/RCS/ph.c,v $$Date: 88/12/08 13:08:44 $$Revision: 3.4 $";
d1198 1
a1198 1
  if (PrintResponse(0) == LR_OK && theAlias == MyAlias)
@


3.4
log
@cleanup version.
@
text
@d1 9
a10 6
* This software is Copyright (C) 1988 by Steven Dorner and the University
* of Illinois Board of Trustees.  No warranties expressed or implied, no
* support provided.  Please do not redistribute it in its present form.
* Contact me for details (dorner@@garcon.cso.uiuc.edu).
***********************************************************************/
/***********************************************************************
d93 1
a93 1
static char *rcsid = "$Source: /nameserv/src/ph/RCS/ph.c,v $$Date: 88/12/08 12:48:28 $$Revision: 3.4 $";
d319 3
d441 2
a442 4
int 
DoHelp(), DoQuery(), DoOther(), DoLogin(), DoQuit(), DoEdit(), DoPassword();
int 
DoLogout(), DoMe();
d451 1
a451 1
 "edit", 1, DoEdit, "\tedit a field from the database.",
d456 3
a458 3
 "fields", 0, DoOther, "\tlist nameserver database fields.",
 "add", 1, DoOther, "\tadd entries to the nameserver database.",
 "delete", 1, DoOther, "\tdelete entries from the nameserver database.",
d554 1
a554 1
* execute a command for which we do nothing special
d556 1
a556 1
DoOther(inputLine, helpOnly)
d576 22
d807 3
d1074 37
d1198 1
a1198 1
  if (PrintResponse(1) == LR_OK && theAlias == MyAlias)
@


3.3
log
@No help here.
@
text
@d90 1
a90 1
static char *rcsid = "$Header: /nameserv/src/ph/RCS/ph.c,v 3.2 88/11/15 13:35:50 dorner Exp Locker: dorner $";
d103 7
d111 1
a117 6
#define CONTACT     "registrar@@uxg.cso.uiuc.edu"
#define HOST      "garcon.cso.uiuc.edu"
#define NSSERVICE     "ns"
#define FALLBACKADDR  0x80ae053a    /* garcon, 128.174.5.58 */
#define FALLBACKPORT  105

d143 1
a143 1
void exit(), free(), bcopy(), perror();
a167 2
#else
  char *rindex();
d326 3
d330 1
d471 2
a472 2
  puts("Send mail to nameserv@@uxg.cso.uiuc.edu to get your password.");
  puts("Mail other questions or comments to dorner@@garcon.cso.uiuc.edu.");
d928 3
d932 1
@


3.2
log
@No help here.
@
text
@d14 1
a14 1
* 128.174.5.58	garcon.cso.uiuc.edu garcon
d17 1
a17 1
* ns		105/tcp		ns		# CSO nameserver
d21 1
a21 1
			P H   for   V A X / V M S
d29 1
a29 1
    1) VAXCRTL does not supply the following routines used by PH:
d31 6
a36 6
	a) fork: SYS$CREPRC or LIB$SPAWN should be used instead.
	b) execlp: VAXCRTL does provide execl, but it is too limited.
	c) popen/pclose: VAXCRTL does provide "pipe" instead.
	d) index/rindex: VAXCRTL "strchr/strrchr" functions are equivalent.
	e) getpass: implemented in this file.
	f) unlink: VAXCRTL does provide "delete" function.
d38 1
a38 1
    2) VAX/VMS does not provide the following utilities used by PH:
d40 2
a41 2
	a) /usr/ucb/more: TYPE/PAGE should be used instead.
	b) /usr/ucb/vi: (callable) EDT should be used instead.
d43 2
a44 2
    3) The VAXCRTL "getenv" function does not recognize the following
       environment names. SYS$TRNLNM could be used instead, if need be:
d46 2
a47 2
	a) PAGER: specifies "pager" other than the default (TYPE/PAGE).
	b) EDITOR: specifies editor other than the default (EDT).
d49 5
a53 5
    4) The SOCKET INTERFACE implemented by Wollongong WIN/TCP 3.1 returns
       a channel number rather than a standard file descriptor, and thus
       is not compatible with the UNIX-style i/o functions such as fdopen,
       read and write. Instead WIN/TCP provides special versions of read/
       write called netread/netwrite for network i/o.
d55 4
a58 4
    5) The VMS VAXC include files are used wherever possible, with several
       exceptions as noted in the WIN/TCP Programmer's Guide. The following
       include files do not exist under VMS VAXC 2.2 nor under WIN/TCP 3.1,
       and were simply copied over from uxc (4.3 bsd):
d60 2
a61 2
	a) #include <sgtty.h>
	b) #include <syslog.h>
d65 2
a66 2
  05-May-1988	12:09	MTS	Initial port of ph.c,v 2.15 to vms_ph.c.
				Initial port of cryptit.c to vms_cryptit.c.
d83 5
a87 5
#include descrip	/* VMS descriptor structures defs */
#include iodef		/* VMS I/O function definitions */
#include ssdef		/* VMS System Status definitions */
#include ttdef		/* VMS terminal characteristics */
#include "termdefs.h"	/* VMS defs for setterm() function */
d90 1
a90 1
static char *rcsid = "$Header: ph.c,v 3.1 88/10/06 11:21:46 dorner Locked $";
d95 1
d110 5
a114 5
#define CONTACT 	"registrar@@uxg.cso.uiuc.edu"
#define HOST		"garcon.cso.uiuc.edu"
#define NSSERVICE	"ns"
#define FALLBACKADDR	0x80ae053a	/* garcon, 128.174.5.58 */
#define FALLBACKPORT	105
d116 3
a118 3
#define MAXSTR		2048	/* max string length */
#define MAXVAL		14000	/* max value length */
#define DELIM		" ,\t\n"/* command delimiters */
d127 2
a128 2
char *strchr();				/* VMS equivalent of "index" */
char *strrchr();			/* VMS equivalent of "rindex" */
d132 2
a133 2
#define GetQValue(aLine)	\
	    (strchr(strchr(aLine,':')+1,':')+1)
d137 2
a138 2
#define GetQValue(aLine)	\
	    (index(index(aLine,':')+1,':')+1)
d140 2
d146 2
a147 2
int    ToQI;		/* write to this to tell the nameserver stuff */
int    FromQI;		/* read nameserver responses from here */
d149 2
a150 2
FILE   *ToQI;		/* write to this to tell the nameserver stuff */
FILE   *FromQI;		/* read nameserver responses from here */
d152 4
a155 4
char    MyAlias[40];		/* currently logged-in alias */
int     TestVersion = 0;	/* is this the test version of ph? */
char   *Me;			/* the name of this program */
char *MyPassword=NULL;		/* password read from .netrc (if any) */
d161 1
a161 1
int     argc;
d165 1
a165 1
char *temps;			/* temp strings */
d167 1
a167 1
    char *rindex();
d169 3
a171 3
    /*
     * figure out what this program is called
     */
d173 1
a173 1
    Me = " ph";
d175 1
a175 1
    Me = rindex(*argv,'/');
d177 5
a181 5
    if (Me)
	Me++;
    else
	Me = *argv;
    TestVersion = !strcmp(Me, "th");
d183 3
a185 3
    if (!ContactQI())
    {
	fputs("Sorry--phone book not available now.\n", stderr);
d187 1
a187 1
	exit(SS$_CONNECFAIL);
d189 1
a189 1
	exit(1);
d191 1
a191 1
    }
d193 4
a196 4
    /*
     * identify ourselves
     */
    DoId();
d198 9
a206 3
    if (argc == 1)
	Interactive();		/* no arguments--interactive mode */
    else
d208 5
a212 11
	/* make a query out of the arguments */
#ifdef VMS
	temps = "query ";
	netwrite(ToQI,temps,strlen(temps));
	for (argc--, argv++; argc; argc--, argv++)
	{
	    netwrite(ToQI,*argv,strlen(*argv));
	    if (argc>1) netwrite(ToQI," ",1);
	}
	temps = "\nquit\n";
	netwrite(ToQI,temps,strlen(temps));
d214 9
a222 9
	fputs("query ", ToQI);
	for (argc--, argv++; argc; argc--, argv++)
	{
	    fputs(*argv, ToQI);
	    if (argc > 1)
		putc(' ', ToQI);
	}
	fputs("\nquit\n", ToQI);
	fflush(ToQI);
d225 3
a227 3
	/* print what the nameserver says */
	(void) PrintQResponse();
    }
d229 1
a229 1
    exit(SS$_NORMAL);
d231 1
a231 1
    exit(0);
d240 4
a243 4
    int     sock;		/* our socket */
    struct sockaddr_in QI;	/* the address of the nameserver */
    struct servent *theNs;	/* nameserver service entry */
    struct hostent *theHost;	/* host entry for nameserver */
d245 5
a249 5
    /* create the socket */
    sock = socket(PF_INET, SOCK_STREAM, 0);
    if (sock < 0)
	return (0);
    QI.sin_family = AF_INET;
d251 10
a260 10
    /* find the proper port */
    if (theNs = getservbyname(TestVersion ? "nstest" : NSSERVICE, "tcp"))
    {
	QI.sin_port = theNs->s_port;
    }
    else
    {
	ComplainAboutService();
	QI.sin_port = htons(FALLBACKPORT);
    }
d262 10
a271 10
    /* find the proper host */
    if (theHost = gethostbyname(HOST))
    {
	bcopy(theHost->h_addr, (char *) &QI.sin_addr.s_addr, 4);
    }
    else
    {
	ComplainAboutHost();
	QI.sin_addr.s_addr = htonl(FALLBACKADDR);
    }
d273 6
a278 6
    /* connect to the nameserver */
    if (connect(sock, &QI, sizeof(QI)) < 0)
    {
	perror("connect");
	return (NULL);
    }
d280 1
a280 1
    /* open path to nameserver */
d282 2
a283 2
    ToQI = sock;		/* copy socket channel for netwrite calls */
    FromQI = sock;			/* ditto for netread calls */
d285 5
a289 5
    if ((ToQI = fdopen(sock, "w")) == NULL)
    {
	perror("to qi");
	return (NULL);
    }
d291 6
a296 6
    /* open path from nameserver */
    if ((FromQI = fdopen(sock, "r")) == NULL)
    {
	perror("from qi");
	return (NULL);
    }
d298 2
a299 2
    
    return (1);
d307 3
a309 5
    char response[MAXSTR];

    fprintf(ToQI,"id %d\n",getuid());
    fflush(ToQI);
    PrintResponse(-1);
d318 1
a318 1
int doPaging;		/* use the pager? */
d320 4
a323 4
    char    scratch[MAXSTR];	/* some space */
    int     code;		/* the reply code */
    char   *thePager;
    FILE   *theOutput;
d325 3
a327 3
    if ((thePager = getenv("PAGER")) == NULL)
	thePager = "/usr/ucb/more";
    
d329 1
a329 1
    theOutput = stdout;		/* simpler to skip paging for right now */
d331 2
a332 2
    if (doPaging!=1 || (theOutput = popen(thePager, "w")) == NULL)
	theOutput = stdout;
d335 6
a340 6
    while (GetGood(scratch, MAXSTR, FromQI))	/* read it */
    {
	if (doPaging!= -1) fputs(scratch, theOutput);	/* echo it */
	if ((code = atoi(scratch)) >= LR_OK)
	    break;
    }
d343 2
a344 2
    if (theOutput != stdout)
	pclose(theOutput);
d347 1
a347 1
    return (code);		/* all done.  return final code */
d355 2
a356 2
char   *theString;		/* space to put the chars */
int     maxChars;		/* max # of chars we want */
d358 1
a358 1
int     theFile;		/* stream to read them from */
d364 3
a366 1
    for (;;)
d368 5
a372 7
	if (pos >= len)
	{
	    len = netread(theFile,Qbuf,maxChars);
	    if (len <= 0) return (0);
	    Qbuf [len] = '\0';
	    pos = 0;
	}
d374 5
a378 5
	linp = index(Qbuf+pos, '\n');	/* find next newline char */
	if (linp == NULL)
	    end = len;			/* no newline chars left */
	else
	    end = linp - Qbuf;		/* convert pointer to index */
d380 5
a384 5
	strncpy(theString, Qbuf+pos, end-pos+1);
	*(theString+end-pos+1) = '\0';
	pos = end + 1;			/* save new position for next time */
#else	
FILE    *theFile;			/* stream to read them from */
d386 3
a388 3
    for (;;)
    {
	(void) fgets(theString, maxChars, theFile);
d390 6
a395 6
	if (*theString != '#')
	    return (1);		/* not a comment; success! */
	else
	if (!*theString)
	    return (0);		/* empty string==end of stream */
    }
d403 4
a406 4
    fprintf(stderr, "Warning--there is no entry for ``%s'' in /etc/services;\n",
	    NSSERVICE);
    fputs("please have your systems administrator add one.\n", stderr);
    fprintf(stderr, "I'm going to use port %d in the meantime.\n", FALLBACKPORT);
d414 3
a416 3
    fprintf(stderr, "Warning--unable to find address for ``%s''.\n", HOST);
    fprintf(stderr, "I'm going to use address 0x%x in the meantime.\n",
	    FALLBACKADDR);
d425 4
a428 4
    char   *cName;		/* the name of the command */
    int     cLog;		/* must be logged in to use? */
    int     (*cFunc) ();	/* function to call for command */
    char   *cHelp;		/* help string for the command */
d453 2
d463 1
a463 1
    char    inputLine[MAXSTR];	/* space for an input line */
d465 4
a468 3
    *MyAlias = 0;		/* nobody logged in yet... */
    puts(rcsid);
    puts("Please mail questions or comments to dorner@@uxg.cso.uiuc.edu.");
d470 4
a473 4
    /*
     * print database status
     */
    DoOther("status\n",0);
d475 5
a479 5
    /*
     * autologin if possible
     */
    DoAutoLogin();
    puts("");
d481 4
a484 4
    while (1)
    {
	printf("%s> ",Me);
	(void) fflush(stdout);	/* prompt */
d486 2
a487 2
	if (!fgets(inputLine, MAXSTR, stdin))
	    break;		/* read line */
d489 3
a491 3
	if (!DoCommand(inputLine, 0))	/* is it a command we know? */
	    DoOther(inputLine, 0);	/* unrecognized command */
    }
d498 2
a499 2
char   *inputLine;		/* the input line */
int     helpOnly;		/* 1 if we should just print help */
d501 5
a505 5
    char    scratch[MAXSTR];	/* some space */
    char   *theToken;		/* a token from the command line */
    Command *theCommand;	/* the command name */
    Command *doMe;
    int     len;
d507 2
a508 2
    /* make a safe copy of the input line, so we can play with it */
    strcpy(scratch, inputLine);
d510 2
a511 2
    if (!(theToken = strtok(scratch, DELIM)))
	return (1);		/* blank line */
d513 5
a517 15
    /* search command table linearly */
    doMe = NULL;
    len = strlen(theToken);
    for (theCommand = CommandTable; theCommand->cName; theCommand++)
	if (!strncmp(theCommand->cName, theToken, len))
	{
	    if (doMe)		/* we found 2 commands that match (bad) */
	    {
		printf("%s is ambiguous.\n", theToken);
		return (1);
	    }
	    doMe = theCommand;	/* we found a command that matches */
	}

    if (doMe)			/* found one and only one command */
d519 3
a521 10
	/* expand command name */
	theToken = strtok(0, "\n");
	if (!helpOnly)
	    sprintf(inputLine, "%s %s\n", doMe->cName, theToken ? theToken : "");

	/* execute command */
	if (doMe->cLog && !*MyAlias)
	    printf("You must be logged in to use %s.\n",doMe->cName);
	else
	    (*doMe->cFunc) (inputLine, helpOnly);
d523 2
d527 16
a542 1
    return (0);			/* didn't find it */
d550 1
a550 1
int     helpOnly;
d552 5
a556 5
    if (helpOnly)
    {
	puts("\tNo further help available.");
	return;
    }
d559 1
a559 1
    netwrite(ToQI, inputLine, strlen(inputLine));
d561 2
a562 2
    fputs(inputLine, ToQI);	/* send command */
    fflush(ToQI);
d564 1
a564 1
    (void) PrintResponse(1);	/* get response */
d572 1
a572 1
int     helpOnly;
d574 2
a575 2
    char   *theToken;
    Command *theCommand;
d577 14
a590 1
    if (helpOnly)
d592 4
a595 5
	puts("\tUsage: help [command...]");
	puts("");
	puts("\tSaying just ``help'' will print a list of commands.");
	puts("\tSaying ``help command'' will print help for that command.");
	return;
d597 4
a600 16

    inputLine[strlen(inputLine) + 1] = '\0';	/* extra terminator */
    strtok(inputLine, DELIM);	/* skip command name */

    if (theToken = strtok((char *) 0, DELIM))
	do			/* help something */
	{
	    puts(theToken);	/* print command name */
	    if (!DoCommand(theToken, 1))
		puts("\tNo help--command unknown to ph.");
	    inputLine = theToken + strlen(theToken) + 1;	/* next token */
	}
	while (theToken = strtok(inputLine, DELIM));
    else			/* just plain help */
    for (theCommand = CommandTable; theCommand->cName; theCommand++)
	printf("%s\t%s\n", theCommand->cName, theCommand->cHelp);
d608 1
a608 1
int     helpOnly;
d610 18
a627 18
    if (helpOnly)
    {
	puts("\tUsage: query [field=]value... [return field...]");
	puts("");
	puts("\tQuery does nameserver lookups.  Entries that match the");
	puts("\tspecifications are printed.  If ``return'' is specified,");
	puts("\tonly the fields named after the ``return'' will be printed.");
	puts("\tIf the ``field='' is omitted in the query portion,");
	puts("\t``name='' will be assumed.  To be selected, an entry");
	puts("\tmust match all the specifications.  Standard metacharacters");
	puts("\tmay be used.  Since no shell is interpreting the input, there");
	puts("\tis no need to escape metacharacters.");
	puts("\t");
	puts("\tA list of candidates for ``field'' may be obtained by using the");
	puts("\t``fields'' command.  Any field marked with ``Lookup'' may be");
	puts("\tused in a query.  At least one field marked with ``Indexed''");
	puts("\tMUST be included in each query.  Any field marked ``Public''");
	puts("\tmay be requested after a ``return''.");
d629 2
a630 2
	return;
    }
d633 1
a633 1
    netwrite(ToQI, inputLine, strlen(inputLine));
d635 2
a636 2
    fputs(inputLine, ToQI);
    fflush(ToQI);
d638 1
a638 1
    (void) PrintQResponse();
d646 1
a646 1
int     helpOnly;
d648 5
a652 5
    char    encryptMe[MAXSTR];	/* string from nameserver */
    char    encrypted[MAXSTR];	/* string from ns, encrypted */
    char   *password;		/* user's nameserver password */
    char   *getpass();
    int     code;
d654 2
a655 2
    char temps[MAXSTR];		/* space for temp strings */
    int len;
d658 12
a669 12
    if (helpOnly)
    {
	puts("\tUsage: login your_alias");
	puts("");
	puts("\tUse login to identify yourself to the nameserver.");
	puts("\tSay ``login your_alias'', where your_alias is your nameserver alias.");
	puts("\tTo find your alias, say ``query your_name return alias''.");
	puts("\tYou will be prompted for your password.  If you do not know it,");
	puts("\tsend mail to nameserv@@uxg.cso.uiuc.edu.  Include your full");
	puts("\tname in your message.");
	return(0);
    }
d672 1
a672 1
    netwrite(ToQI, inputLine, strlen(inputLine));	/* send the login request */
d674 2
a675 2
    fputs(inputLine, ToQI);	/* send the login request */
    fflush(ToQI);
d678 3
a680 1
    for (;;)			/* read the response */
d682 2
a683 10
	if (!GetGood(encryptMe, MAXSTR, FromQI))
	{
	    fprintf(stderr, "Whoops--the nameserver died.\n");
	    exit(1);
	}
	code = atoi(encryptMe);
	if (code != LR_LOGIN)	/* intermediate or strange response */
	    fputs(encryptMe, stdout);
	if (code >= LR_OK)	/* final response */
	    break;
d685 6
d692 6
a697 6
    if (code == LR_LOGIN)
    {
	/* the nameserver has issued a challenge */
	password = MyPassword ? MyPassword :
				    getpass("Enter nameserver password: ");
	crypt_start(password);
d699 3
a701 3
	/* encrypt the challenge with the password */
	encryptMe[strlen(encryptMe) - 1] = '\0';	/* strip linefeed */
	encrypted[encryptit(encrypted, index(encryptMe, ':') + 1)] = '\0';
d703 1
a703 1
	/* send the encrypted text to qi */
d705 2
a706 2
	len = sprintf(temps, "answer %s\n", encrypted);
	netwrite(ToQI, temps, len);
d708 2
a709 2
	fprintf(ToQI, "answer %s\n", encrypted);
	fflush(ToQI);
d712 12
a723 13
	/* get the final response */
	for (;;)
	{
	    if (!GetGood(encryptMe, MAXSTR, FromQI))
	    {
		fprintf(stderr, "Whoops--the nameserver died.\n");
		exit(1);
	    }
	    code = atoi(encryptMe);
	    fputs(encryptMe, stdout);
	    if (code >= LR_OK)	/* final response */
		break;
	}
d725 1
d727 12
a738 12
    if (code == LR_OK)		/* logged in */
    {
	strcpy(MyAlias, index(encryptMe, ':') + 1);
	*index(MyAlias, ':') = '\0';
	VetPassword(password);	/* make sure password is reasonable */
	return(1);
    }
    else
    {
	*MyAlias = '\0';
	return(0);
    }
d746 1
a746 1
int     helpOnly;
d748 1
a748 1
    DoOther(inputLine, helpOnly);
d750 2
a751 2
    if (!helpOnly)
	exit(SS$_NORMAL);
d753 2
a754 2
    if (!helpOnly)
	exit(0);
d763 1
a763 1
int     helpOnly;
d765 3
a767 3
    char   *theField;
    char   *theAlias;
    char   *theValue;
d769 11
a779 11
    if (helpOnly)
    {
	puts("\tUsage: edit field [alias]");
	puts("");
	puts("\tEdit will retrieve the named field from the entry with the");
	puts("\tnamed alias (or the currently logged in user, if no alias");
	puts("\tis specified.)  It will then allow the value to be editted,");
	puts("\tand update the value in the database.");
	puts("\tYou must be logged in (see ``login'') to use this command.");
	return;
    }
d781 6
a786 6
    (void) strtok(inputLine, DELIM);	/* skip ``edit'' */
    if (!(theField = strtok((char *) 0, DELIM)))
    {
	DoEdit(inputLine, 1);
	return;
    }
d788 2
a789 2
    if (!(theAlias = strtok((char *) 0, DELIM)))
	theAlias = MyAlias;
d791 4
a794 4
    if ((theValue = GetValue(theAlias, theField)) && EditValue(theValue))
	if (UpdateValue(theAlias, theField, theValue)<300 &&
	    !strcmp(theField,"alias"))
	    strcpy(MyAlias,theValue);
d805 4
a808 4
    static char theValue[MAXVAL];	/* will hold the value */
    char   *vSpot;
    char    scratch[MAXSTR];
    int     code;
d810 1
a810 1
    int	len;
d813 5
a817 5
    if (!strcmp(theField, "password"))
    {
	puts("Use the ``password'' command, not edit.");
	return (NULL);
    }
d819 1
a819 1
    /* do the query */
d821 2
a822 2
    len = sprintf(scratch,"query alias=%s return %s\n",theAlias,theField);
    netwrite(ToQI,scratch,len);
d824 2
a825 2
    fprintf(ToQI, "query alias=%s return %s\n", theAlias, theField);
    fflush(ToQI);
d828 1
a828 1
    *theValue = '\0';
d830 4
a833 2
    /* read qi response lines, concatenating the responses into one value */
    for (vSpot = theValue;; vSpot += strlen(vSpot))
d835 2
a836 12
	if (!GetGood(scratch, MAXSTR, FromQI))
	{
	    fprintf(stderr, "Ding-dong the server's dead!\n");
	    exit(0);
	}
	if ((code = atoi(scratch)) == -LR_OK)
	    strcpy(vSpot, index(GetQValue(scratch), ':') + 2);	/* part of value */
	else
	if (code >= LR_OK)
	    break;		/* final response */
	else
	    fputs(scratch, stdout);	/* ??? */
d838 8
d847 2
a848 2
    if (code != LR_OK)		/* error */
	fputs(scratch, stdout);
d850 1
a850 1
    return (code == LR_OK ? theValue : NULL);
d857 1
a857 1
char   *theValue;		/* the value to edit */
d859 2
a860 2
    char   *theFileName;	/* name of temp file to use */
    char   *mktemp();
d862 3
a864 3
    struct dsc$descriptor_s cli_input;
    char    template[28], f1[28], f2[28], edit_command[64];
    int     istat;
d866 1
a866 1
    char    template[20];
d868 7
a874 7
    int     fd;			/* file descriptor for temp file */
    static char newValue[MAXVAL];	/* new value */
    char   *editor;			/* editor program to use */
    int     bytes;			/* numnber of bytes in file */
    register char *from, *to;
    int     badChar;			/* did we find a bad character? */
    int     junk;
d876 1
a876 1
    /* put the value into a temp file */
d878 7
a884 7
    strcpy(template, "SYS$SCRATCH:PHXXXXXX.TMP");
    theFileName = mktemp(template);
    strcpy (f1, theFileName);
    strcpy (f2, theFileName);
    strcat (f1, ";1");		/* versions needed for delete function */
    strcat (f2, ";2");
    if ((fd = creat(theFileName, 0)) < 0)
d886 3
a888 3
    strcpy(template, "/tmp/phXXXXXX");
    theFileName = mktemp(template);
    if ((fd = open(theFileName, O_RDWR | O_CREAT, 0777)) < 0)
d890 4
a893 4
    {
	perror(theFileName);
	return (0);
    }
d895 3
a897 7
    if (write(fd, theValue, strlen(theValue)) < 0)
    {
	perror(theFileName);
	(void) close(fd);
	return (0);
    }

d899 2
d902 3
a904 1
    /* run an editor on the temp file */
d906 2
a907 2
    if (!(editor = getenv("EDITOR")))
	editor = "EDIT/EDT";
d909 7
a915 7
    strcpy(edit_command, editor);
    strcat(edit_command, " ");
    strcat(edit_command, theFileName);
    cli_input.dsc$w_length = strlen(edit_command);  /* descriptor for spawn */
    cli_input.dsc$a_pointer = edit_command;
    cli_input.dsc$b_class = DSC$K_CLASS_S;
    cli_input.dsc$b_dtype = DSC$K_DTYPE_T;
d917 5
a921 5
    if( (istat = LIB$SPAWN(&cli_input)) != SS$_NORMAL )
    {
	(void) delete (f1);
	exit(istat);
    }
d923 2
a924 2
    if (!(editor = getenv("EDITOR")))
	editor = "/usr/ucb/vi";
d926 8
a933 4
    if (fork())
	(void) wait(&junk);
    else
	execlp(editor, editor, theFileName, NULL);
d936 4
a939 4
    /* read the value back out */
    if ((fd = open(theFileName, 0)) < 0)
    {
	perror(theFileName);
d942 1
a942 1
	(void) unlink(theFileName);
d944 2
a945 2
	return (0);
    }
d949 1
a949 1
    (void) unlink(theFileName);
d952 4
a955 4
    if ((bytes = read(fd, newValue, MAXSTR - 1)) < 0)
    {
	perror(theFileName);
	(void) close(fd);
d957 2
a958 2
	(void) delete (f1);	/* delete 1st temp file */
	(void) delete (f2);	/* delete 2nd temp file */
d960 3
a962 3
	return (0);
    }
    (void) close(fd);
d964 2
a965 2
    (void) delete (f1); 	/* delete 1st temp file */
    (void) delete (f2); 	/* delete 2nd temp file */
d967 1
a967 1
    newValue[bytes] = 0;
d969 3
a971 3
    /* did the value change? */
    if (!strcmp(newValue, theValue))
	return (0);
d973 4
a976 32
    /* copy new value into old, stripping bad characters */
    badChar = 0;
    for (to = theValue, from = newValue; *from; from++)
	if (*from == '"')
	{
	    *to++ = '\\';
	    *to++ = '"';
	}
	else
	if (*from >= ' ' && *from <= '~')
	    *to++ = *from;
	else
	if (*from == '\t')
	{
	    *to++ = '\\';
	    *to++ = 't';
	}
	else
	if (*from == '\n')
	{
	    if (*(from + 1))	/* skip terminating newline from vi */
	    {
		*to++ = '\\';
		*to++ = 'n';
	    }
	}
	else
	    badChar = 1;

    *to = 0;

    if (badChar)		/* complain if we found bad characters */
d978 2
a979 3
	fputs("Illegal characters were found in your value.\n", stderr);
	fputs("Please use only printable characters, newlines, and tabs.\n", stderr);
	fputs("The offending characters were removed.\n", stderr);
d981 20
d1002 10
a1011 1
    return (1);
d1023 1
a1023 1
char temps[MAXSTR];			/* space for temp strings */
d1026 2
a1027 2
    len = sprintf(temps,"change alias=%s make %s=\"%s\"\n",theAlias,theField,theValue);
    netwrite(ToQI,temps,len);
d1029 2
a1030 2
    fprintf(ToQI, "change alias=%s make %s=\"%s\"\n", theAlias, theField, theValue);
    fflush(ToQI);
d1033 1
a1033 1
    return(PrintResponse(0));
d1039 1
d1042 1
a1042 1
int     helpOnly;
d1044 1
a1044 1
    char    scratch[MAXSTR];
d1046 1
a1046 1
    int len;
d1049 8
a1056 8
    if (helpOnly || !*MyAlias)
    {
	puts("\tUsage: me");
	puts("\tThis command prints the nameserver entry for the currently");
	puts("\tlogged in user.  Naturally, you must be logged in to use it;");
	puts("\tsee ``login.''");
	return;
    }
d1059 2
a1060 2
    len = sprintf(scratch,"query alias=%s\n",MyAlias);
    netwrite(ToQI,scratch,len);
d1062 3
a1064 3
    sprintf(scratch, "query alias=%s return all\n", MyAlias);
    fputs(scratch, ToQI);
    fflush(ToQI);
d1067 1
a1067 1
    PrintQResponse();
d1075 1
a1075 1
int     helpOnly;
d1077 3
a1079 3
    char    password[80];
    char   *confirm;
    char   *theAlias;
d1081 3
a1083 3
    char *getpass();
    char temps[MAXSTR];		/* space for temp strings */
    int len;
d1086 10
a1095 10
    if (helpOnly || !*MyAlias)
    {
	puts("\tUsage: password [alias]");
	puts("");
	puts("\tPassword will prompt you for a password (twice), and change");
	puts("\tyour (or the named user's, if you are privileged)");
	puts("\tnameserver password to what you type.  Use this command often.");
	puts("\tYou must be logged into the nameserver; see ``login''.");
	return;
    }
d1097 4
a1100 4
    /* which alias to use? */
    (void) strtok(inputLine, DELIM);
    if (!(theAlias = strtok((char *) 0, DELIM)))
	theAlias = MyAlias;
d1102 10
a1111 10
    /* get the password */
    strcpy(password, getpass("Enter new password: "));
    if (!*password) return;
    confirm = getpass("Type it again: ");
    if (strcmp(confirm, password))
    {
	fprintf(stderr, "Sorry--passwords didn't match.\n");
	return;
    }
    VetPassword(confirm);	/* complain if we don't like the password */
d1113 2
a1114 2
    /* encrypt and send the password */
    password[encryptit(password, confirm)] = '\0';
d1116 2
a1117 2
    len = sprintf(temps,"change alias=%s make password=%s\n",theAlias,password);
    netwrite(ToQI,temps,len);
d1119 2
a1120 2
    fprintf(ToQI, "change alias=%s make password=%s\n", theAlias, password);
    fflush(ToQI);
d1123 3
a1125 3
    /* see what the nameserver says */
    if (PrintResponse(1) == LR_OK && theAlias == MyAlias)
	crypt_start(confirm);
d1133 1
a1133 1
int     helpOnly;
d1135 9
a1143 9
    if (helpOnly)
    {
	puts("\tUsage: logout");
	puts("");
	puts("\tLogs you out of the nameserver.  Does not quit ph.");
	return;
    }
    *MyAlias = '\0';
    DoOther(inputLine, helpOnly);
d1152 3
a1154 3
    if (strlen(thePassword) < 5 ||	/* too short */
	AllDigits(thePassword))	/* digits only */
	fputs("That is an insecure password; please change it.\n", stderr);
d1163 4
a1166 4
    for (; *theString; theString++)
	if (!isdigit(*theString))
	    return (0);
    return (1);
d1175 6
a1180 6
    char    theLine[MAXSTR];
    int     theCode;
    int     currentPerson = 0;
    int     thePerson;
    char   *thePager;
    FILE   *theOutput;
d1182 3
a1184 3
    /* always use a paging program */
    if ((thePager = getenv("PAGER")) == NULL)
	thePager = "/usr/ucb/more";
d1187 3
a1190 3
#else    
    if ((theOutput = popen(thePager,"w")) == NULL)
	theOutput = stdout;
d1193 5
a1197 2
    /* get the response */
    while (GetGood(theLine, MAXSTR, FromQI))
d1199 9
a1207 18
	theCode = atoi(theLine);
	if (theCode == -LR_OK || theCode == -LR_AINFO || theCode == -LR_ABSENT)
	{
	    thePerson = atoi(index(theLine, ':') + 1);
	    /* output a delimiter */
	    if (thePerson != currentPerson)
	    {
		fputs("----------------------------------------\n", theOutput);
		currentPerson = thePerson;
	    }
	    /* output the line */
	    fputs(GetQValue(theLine), theOutput);
	}
	else if (theCode != LR_OK)
	    fputs(theLine, theOutput);	/* error */

	if (theCode >= LR_OK)
	    break;
d1209 2
d1212 8
a1219 4
    /* final "delimiter" */
    if (currentPerson)
	fputs("----------------------------------------\n", theOutput);
    
d1222 2
a1223 2
    if (theOutput != stdout)
	(void) pclose(theOutput);
d1232 1
a1232 1
 * function:   strtok purpose:    to break a string into tokens parameters:
d1234 1
a1234 1
 * returns:    pointer to first token.  Puts a null after the token. returns
d1241 2
a1242 2
    static char *old = 0;
    char   *p1, *p2;
d1244 11
a1254 6
    if (!(s1 || old))
	return (NULL);
    p1 = (s1 ? s1 : old);
    while (*p1 && (index(s2, *p1) != NULL))
	p1++;
    if (*p1)
d1256 2
a1257 11
	p2 = p1;
	while (*p2 && (index(s2, *p2) == NULL))
	    p2++;
	if (*p2)
	{
	    *p2 = '\0';
	    old = ++p2;
	}
	else
	    old = 0;
	return (p1);
d1260 5
a1264 1
	return (NULL);
d1267 1
a1267 1
/*		setterm.c
d1269 1
a1269 1
 *	module in termlib
d1271 1
a1271 1
 *	contains routines to set terminal mode
d1273 1
a1273 1
 *	V1.0 19-jul-84	P. Schleifer	Initial draft
d1277 1
a1277 1
long	*characteristic, *state;
d1279 7
a1285 7
    int		status;
    long	efn;
    long	new_state;
    short	term_chan;
    struct char_buff	mode;
    struct mode_iosb	term_iosb;
    $DESCRIPTOR(term_desc, "TT:");
d1287 3
a1289 3
    /* get event flag */
    status = lib$get_ef(&efn);
    if ( status != SS$_NORMAL ) return (status);
d1291 3
a1293 3
    /* get channel to terminal */
    status = sys$assign(&term_desc, &term_chan, 0, 0);
    if (status != SS$_NORMAL) return (status);
d1295 5
a1299 5
    /* if characteristic is BROADCAST, ECHO, or TYPEAHEAD, state must be toggled */
    if (*characteristic == BROADCAST || *characteristic == ECHO || *characteristic == TYPEAHEAD)
	new_state = !(*state);
    else
	new_state = *state;
d1301 3
a1303 3
    /* get current mode */
    status = sys$qiow(efn, term_chan, IO$_SENSEMODE, &term_iosb, 0, 0, &mode, 12, 0, 0, 0, 0);
    if (status != SS$_NORMAL || term_iosb.stat != SS$_NORMAL) { sys$dassgn(term_chan); return (status); }
d1305 5
a1309 5
    /* change characteristics buffer */
    if (new_state == ON)
	mode.basic_char |= *characteristic;
    else
	mode.basic_char &= ~(*characteristic);
d1311 2
a1312 2
    /* $ SET TERM/...  and then deassign channel */
    status = sys$qiow(efn, term_chan, IO$_SETMODE, &term_iosb, 0, 0, &mode, 12, 0, 0, 0, 0);
d1314 2
a1315 2
    sys$dassgn(term_chan);
    lib$free_ef(&efn);
d1317 2
a1318 2
    if (status != SS$_NORMAL) return (status);
    else return (term_iosb.stat);
d1333 6
a1338 6
    printf(prompt); (void) fflush(stdout);		/* prompt */
    setterm(&echo, &off);
    gets(line);
    setterm(&echo, &on);
    puts("");
    return(line);
d1347 7
a1353 7
    FILE *netrc;	/* the .netrc file */
    char pathName[1024];/* pathname of .netrc file */
    struct stat theStat;/* permissions, etc. of .netrc file */
    char line[80];	/* line from the .netrc file */
    char *token;	/* token (word) from the line from the .netrc file */
    char *alias=NULL;	/* the user's alias */
    char *pw=NULL;	/* the user's password */
d1355 4
a1358 4
    /*
     * manufacture the pathname of the user's .netrc file
     */
    sprintf(pathName,"%s/.netrc",getenv("HOME"));
d1360 7
a1366 7
    /*
     * make sure its permissions are ok
     */
    if (stat(pathName,&theStat)<0)
	return;
    if (theStat.st_mode & 077)
	return;				/* refuse insecure files */
d1368 5
a1372 5
    /*
     * try to open it
     */
    if (!(netrc=fopen(pathName,"r")))
	return;
d1374 7
a1380 4
    /*
     * look for a ``machine'' named ``ph''
     */
    while (fgets(line,sizeof(line),netrc))
d1382 5
a1386 2
	if ((token=strtok(line," \t\n")) && !strcmp(token,"machine") &&
	    (token=strtok(0," \t\n")) && !strcmp(token,"ph"))
d1388 16
a1403 22
	    /*
	     * found an entry for ph.  look now for other items
	     */
	    while (fgets(line,sizeof(line),netrc))
		if (token=strtok(line," \t\n"))
		{
		    if (!strcmp(token,"machine"))	/* new machine */
		    {
			if (alias) {free(alias);alias=NULL;}
			if (pw) {free(pw);pw=NULL;}
			break;
		    }
		    else if (!strcmp(token,"login"))
		    {
			if (token=strtok(0," \t\n"))
			    alias=strcpy(malloc(strlen(token)+1),token);
		    }
		    else if (!strcmp(token,"password"))
		    {
			if (token=strtok(0," \t\n"))
			    pw=strcpy(malloc(strlen(token)+1),token);
		    }
d1405 2
a1406 3
		    if (alias && pw && TryLogin(alias,pw))
			goto done;
		}
d1409 1
d1412 3
a1414 3
    if (alias) free(alias);
    if (pw) free(pw);
    return;
d1424 2
a1425 2
    char loginLine[80];
    int success;
d1427 4
a1430 4
    /*
     * construct a login line
     */
    sprintf(loginLine,"login %s\n",alias);
d1432 4
a1435 4
    /*
     * set our password
     */
    MyPassword=password;
d1437 4
a1440 4
    /*
     * try the login
     */
    success = DoLogin(loginLine,0);
d1442 5
a1446 5
    /*
     * reset our password
     */
    MyPassword = NULL;
    while (*password) *password++ = 'x';
d1448 4
a1451 4
    /*
     * return our success (or failure)
     */
    return(success);
@


3.1
log
@No longer allows user to change his password to nothing.
@
text
@d2 6
d90 1
a90 1
static char *rcsid = "$Header: ph.c,v 3.0 88/09/07 12:30:26 dorner Exp $";
@


3.0
log
@>> Added reading of .netrc.
>> Notices change of alias.
>> Changed PrintResponse to take an argument, meaning:
>>      1       use a pager
>>      0       don't use a pager
>>      -1      don't print the response
>> Added extra field in command table, and code in DoCommand, all to refuse
>> immediately commands that require login if the user isn't logged in.
>> (Reading of .netrc required some diddling with DoLogin...)
@
text
@d84 1
a84 1
static char *rcsid = "$Header: ph.c,v 2.21 88/07/28 16:38:14 dorner Locked $";
d1089 1
@


2.21
log
@Strip off -LR_AINFO and -LR_ABSENT reply codes in midst of query responses.
@
text
@d84 1
a84 1
static char *rcsid = "$Header: ph.c,v 2.20 88/07/27 13:55:53 dorner Locked $";
d91 1
d137 2
a138 2
int    ToQI;			/* write to this to tell the nameserver stuff */
int    FromQI;			/* read nameserver responses from here */
d140 2
a141 2
FILE   *ToQI;			/* write to this to tell the nameserver stuff */
FILE   *FromQI;	/* read nameserver responses from here */
d146 1
d302 1
a302 2
    while (GetGood(response,MAXSTR,FromQI))
	if (atoi(response)>=LR_OK) return;
d310 2
a311 1
PrintResponse()
d324 1
a324 1
    if ((theOutput = popen(thePager, "w")) == NULL)
d330 1
a330 1
	fputs(scratch, theOutput);	/* echo it */
d419 1
d431 16
a446 16
 "help", DoHelp, "\tprint this message.",
 "?", DoHelp, "\tprint this message.",
 "query", DoQuery, "\tquery the database.",
 "ph", DoQuery, "\tsynonym for query.",
 "me", DoMe, "\tprint entry for current user.",
 "edit", DoEdit, "\tedit a field from the database.",
 "password", DoPassword, "change your nameserver password.",
 "passwd", DoPassword, "\tsynonym for password.",
 "login", DoLogin, "\tlogin to the nameserver.",
 "logout", DoLogout, "\tlog out of the nameserver.",
 "fields", DoOther, "\tlist nameserver database fields.",
 "add", DoOther, "\tadd entries to the nameserver database.",
 "delete", DoOther, "\tdelete entries from the nameserver database.",
 "set", DoOther, "\tset nameserver options.",
 "quit", DoQuit, "\texit ph.",
 0, 0, 0
d464 5
d525 4
a528 1
	(*doMe->cFunc) (inputLine, helpOnly);
d554 1
a554 1
    (void) PrintResponse();	/* get response */
d658 1
a658 1
	return;
d685 2
a686 1
	password = getpass("Enter nameserver password: ");
d722 1
d725 1
d727 2
d782 3
a784 1
	UpdateValue(theAlias, theField, theValue);
d1019 1
a1019 1
    (void) PrintResponse();
d1108 1
a1108 1
    if (PrintResponse() == LR_OK && theAlias == MyAlias)
d1325 112
@


2.20
log
@Added ``all'' parameter to ``me'' command.
@
text
@d84 1
a84 1
static char *rcsid = "$Header: ph.c,v 2.19 88/07/25 13:59:48 dorner Locked $";
d1163 1
a1163 1
	if (theCode == -LR_OK)
@


2.19
log
@Added status and id commands.
@
text
@d84 1
a84 1
static char *rcsid = "$Header: ph.c,v 2.18 88/07/20 11:40:50 dorner Locked $";
d1029 1
a1029 1
    sprintf(scratch, "query alias=%s\n", MyAlias);
@


2.18
log
@Added Id and Status commands
@
text
@d84 1
a84 1
static char *rcsid = "$Header: ph.c,v 2.17 88/07/18 15:31:09 dorner Locked $";
d298 2
a299 1
    fprintf(ToQI,"id %d",getuid());
d301 1
a301 1
	if (atoi(response)>LR_OK) return;
a455 1
    puts("");
d460 2
a461 1
    DoOther("status",0);
@


2.17
log
@Changed host from uxg to garcon.

@
text
@d84 1
a84 1
static char *rcsid = "$Header: ph.c,v 2.16 88/07/06 20:48:36 dorner Locked $";
d181 7
a187 1
    else if (argc == 1)
d292 12
d456 6
d1174 1
a1174 2
	else
	if (theCode != LR_OK)
@


2.16
log
@incorporated Mark Sandrock's VMS changes.
@
text
@d3 1
a3 1
* the nameserver running on uxg.cso.uiuc.edu, and query it about
d8 1
a8 1
* 128.174.5.53	ripple.cso.uiuc.edu ripple uxg uxg.cso.uiuc.edu
d84 1
a84 1
static char *rcsid = "$Header: ph.c,v 2.15 88/04/29 10:07:20 dorner Locked $";
d105 1
a105 1
#define FALLBACKADDR	0x80ae0535	/* uxg, 128.174.5.53 */
d382 1
a382 1
* complain that there isn't an entry for uxg in /etc/hosts
@


2.15
log
@Diddled help texts.
@
text
@d12 4
a15 2
***********************************************************************/
static char *rcsid = "$Header: ph.c,v 2.14 88/04/29 09:58:54 dorner Locked $";
d17 69
d95 2
d103 1
a103 1
#define HOST		"uxg.cso.uiuc.edu"
d118 9
d131 1
a131 1

d135 4
d140 2
a141 1
FILE   *FromQI;			/* read nameserver responses from here */
d153 3
d157 1
a157 1

d161 3
d165 1
d175 3
d179 1
d186 11
d206 1
d211 3
d215 1
d264 4
d280 2
a281 1

d299 4
a302 1

d305 1
a306 1

d313 2
d317 1
d329 2
a330 1
FILE   *theFile;		/* stream to read them from */
d332 4
d338 22
d361 1
d512 3
d517 1
d586 3
d591 1
d607 4
d625 3
d630 1
d657 4
d663 1
d698 1
d700 3
d704 1
d756 3
d767 4
d773 1
d808 5
d814 1
d817 2
a818 2
    char   *editor;		/* editor program to use */
    int     bytes;		/* numnber of bytes in file */
d820 1
a820 1
    int     badChar;		/* did we find a bad character? */
d824 9
d836 1
d852 1
d854 17
d877 1
d883 2
d886 1
d890 2
d893 1
d899 4
d906 4
d965 7
d974 2
d987 3
d1000 4
d1007 2
d1022 5
d1056 4
d1062 1
d1127 4
a1130 1
    if ((theOutput = popen(thePager, "w")) == NULL)
d1132 1
d1161 3
a1163 1

d1166 1
d1208 75
@


2.14
log
@Fixes bug that left garbage at the end of encrypted strings (failed
to null-terminate them).
Added ``passwd'' as synonym for ``password''
Made prompt reflect name of program.
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.13 88/04/28 16:41:05 dorner Locked $";
d263 1
a263 1
 "passwd", DoPassword, "synonym for password.",
d774 2
a775 2
	puts("\tyour (or the named user's) nameserver password to what you");
	puts("\ttype.  Use this command often.");
@


2.13
log
@Indent.
Fixed non-null terminating bug.
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.12 88/03/10 12:49:11 dorner Locked $";
d57 1
d66 12
a77 1
    TestVersion = !strcmp(*argv, "th");
d83 1
a83 2
    else
    if (argc == 1)
d263 1
d287 1
a287 1
	printf("ph> ");
@


2.12
log
@changed eof handling
@
text
@d13 2
a14 1
static char *rcsid = "$Header: ph.c,v 2.11 88/03/10 12:23:34 dorner Locked $";
d35 3
a37 3
#define MAXSTR		2048		/* max string length */
#define MAXVAL		14000		/* max value length */
#define DELIM		" ,\t\n"	/* command delimiters */
d42 5
a46 4
char *GetValue();
char *strtok();
char *getenv();
FILE *popen();
d53 4
a56 4
FILE *ToQI;		/* write to this to tell the nameserver stuff */
FILE *FromQI;		/* read nameserver responses from here */
char MyAlias[40];	/* currently logged-in alias */
int TestVersion=0;	/* is this the test version of ph? */
d61 3
a63 3
main(argc,argv)
int argc;
char **argv;
d65 1
a65 1
    TestVersion = !strcmp(*argv,"th");
d68 1
a68 1
	fputs("Sorry--phone book not available now.\n",stderr);
d71 2
a72 1
    else if (argc == 1)
d77 2
a78 2
	fputs("query ",ToQI);
	for (argc--,argv++;argc;argc--,argv++)
d80 3
a82 2
	    fputs(*argv,ToQI);
	    if (argc>1) putc(' ',ToQI);
d84 1
a84 1
	fputs("\nquit\n",ToQI);
d98 1
a98 1
    int sock;			/* our socket */
d104 3
a106 3
    sock = socket(PF_INET,SOCK_STREAM,0);
    if (sock<0)
	return(0);
d110 1
a110 1
    if (theNs=getservbyname(TestVersion ? "nstest" : NSSERVICE,"tcp"))
d121 1
a121 1
    if (theHost=gethostbyname(HOST))
d123 1
a123 1
	bcopy(theHost->h_addr,(char *)&QI.sin_addr.s_addr,4);
d132 1
a132 1
    if (connect(sock,&QI,sizeof(QI))<0)
d135 1
a135 1
	return(NULL);
d139 1
a139 1
    if ((ToQI = fdopen(sock,"w"))==NULL)
d142 1
a142 1
	return(NULL);
d146 1
a146 1
    if ((FromQI = fdopen(sock,"r"))==NULL)
d149 1
a149 1
	return(NULL);
d151 2
a152 2
    
    return(1);
d154 1
d162 4
a165 4
    char scratch[MAXSTR];	/* some space */
    int code;			/* the reply code */
    char *thePager;
    FILE *theOutput;
d167 1
a167 1
    if ((thePager=getenv("PAGER"))==NULL)
a168 3
    
    if ((theOutput=popen(thePager,"w"))==NULL)
	theOutput=stdout;
d170 2
d173 2
a174 1
    while (GetGood(scratch,MAXSTR,FromQI))	/* read it */
d176 3
a178 2
	fputs(scratch,theOutput);			/* echo it */
	if ((code=atoi(scratch))>=LR_OK) break;
d180 1
a180 1
    if (theOutput!=stdout)
d183 1
a183 1
    return(code);		/* all done.  return final code */
d190 4
a193 4
GetGood(theString,maxChars,theFile)
char *theString;		/* space to put the chars */
int maxChars;			/* max # of chars we want */
FILE *theFile;			/* stream to read them from */
d197 1
a197 1
	(void) fgets(theString,maxChars,theFile);
d199 4
a202 3
	    return(1);		/* not a comment; success! */
	else if (!*theString)
	    return(0);		/* empty string==end of stream */
d205 1
d211 4
a214 4
    fprintf(stderr,"Warning--there is no entry for ``%s'' in /etc/services;\n",
	NSSERVICE);
    fputs("please have your systems administrator add one.\n",stderr);
    fprintf(stderr,"I'm going to use port %d in the meantime.\n",FALLBACKPORT);
d216 1
d222 3
a224 3
    fprintf(stderr,"Warning--unable to find address for ``%s''.\n",HOST);
    fprintf(stderr,"I'm going to use address 0x%x in the meantime.\n",
	FALLBACKADDR);
d233 3
a235 3
    char *cName;		/* the name of the command */
    int (*cFunc)();		/* function to call for command */
    char *cHelp;		/* help string for the command */
d238 4
a241 2
int DoHelp(), DoQuery(), DoOther(), DoLogin(), DoQuit(), DoEdit(), DoPassword();
int DoLogout(), DoMe();
d243 1
a243 1
Command CommandTable[]=
d245 15
a259 15
    "help",	DoHelp,		"\tprint this message.",
    "?",	DoHelp,		"\tprint this message.",
    "query",	DoQuery,	"\tquery the database.",
    "ph",	DoQuery,	"\tsynonym for query.",
    "me",	DoMe,		"\tprint entry for current user.",
    "edit",	DoEdit,		"\tedit a field from the database.",
    "password",	DoPassword,	"change your nameserver password.",
    "login",	DoLogin,	"\tlogin to the nameserver.",
    "logout",	DoLogout,	"\tlog out of the nameserver.",
    "fields",	DoOther,	"\tlist nameserver database fields.",
    "add",	DoOther,	"\tadd entries to the nameserver database.",
    "delete",	DoOther,	"\tdelete entries from the nameserver database.",
    "set",	DoOther,	"\tset nameserver options.",
    "quit",	DoQuit,		"\texit ph.",
    0,0,0
d267 1
a267 1
    char inputLine[MAXSTR];		/* space for an input line */
d269 1
a269 1
    *MyAlias=0;				/* nobody logged in yet... */
d275 2
a276 1
	printf("ph> "); (void) fflush(stdout);		/* prompt */
d278 2
a279 1
	if (!fgets(inputLine,MAXSTR,stdin)) break;	/* read line */
d281 2
a282 2
	if (!DoCommand(inputLine,0))	/* is it a command we know? */
	    DoOther(inputLine,0);	/* unrecognized command */
d289 3
a291 3
DoCommand(inputLine,helpOnly)
char *inputLine;		/* the input line */
int helpOnly;			/* 1 if we should just print help */
d293 2
a294 2
    char scratch[MAXSTR];	/* some space */
    char *theToken;		/* a token from the command line */
d297 1
a297 1
    int len;
d300 1
a300 1
    strcpy(scratch,inputLine);
d302 2
a303 2
    if (!(theToken=strtok(scratch,DELIM)))
	return(1);		/* blank line */
d308 2
a309 2
    for (theCommand=CommandTable;theCommand->cName;theCommand++)
	if (!strncmp(theCommand->cName,theToken,len))
d313 2
a314 2
		printf("%s is ambiguous.\n",theToken);
		return(1);
d322 1
a322 1
	theToken=strtok(0,"\n");
d324 1
a324 1
	    sprintf(inputLine,"%s %s\n",doMe->cName,theToken?theToken:"");
d327 2
a328 2
	(*doMe->cFunc)(inputLine,helpOnly);
	return(1);
d331 1
a331 1
    return(0);		/* didn't find it */
d337 3
a339 3
DoOther(inputLine,helpOnly)
char *inputLine;
int helpOnly;
d347 1
a347 1
    fputs(inputLine,ToQI);	/* send command */
d355 3
a357 3
DoHelp(inputLine,helpOnly)
char *inputLine;
int helpOnly;
d359 1
a359 1
    char *theToken;
d371 2
a372 2
    inputLine[strlen(inputLine)+1]='\0';	/* extra terminator */
    strtok(inputLine,DELIM);			/* skip command name */
d374 2
a375 2
    if (theToken=strtok((char *)0,DELIM))
	do				/* help something */
d377 2
a378 2
	    puts(theToken);			/* print command name */
	    if (!DoCommand(theToken,1))
d380 1
a380 1
	    inputLine = theToken + strlen(theToken) + 1; /* next token */
d382 4
a385 4
	while (theToken=strtok(inputLine,DELIM));
    else				/* just plain help */
	for (theCommand=CommandTable;theCommand->cName;theCommand++)
	    printf("%s\t%s\n",theCommand->cName,theCommand->cHelp);
d391 3
a393 3
DoQuery(inputLine,helpOnly)
char *inputLine;
int helpOnly;
d417 1
a417 1
    fputs(inputLine,ToQI);
d425 3
a427 3
DoLogin(inputLine,helpOnly)
char *inputLine;
int helpOnly;
d429 5
a433 5
    char encryptMe[MAXSTR];	/* string from nameserver */
    char encrypted[MAXSTR];	/* string from ns, encrypted */
    char *password;		/* user's nameserver password */
    char *getpass();
    int code;
d448 1
a448 1
    fputs(inputLine,ToQI);	/* send the login request */
d453 1
a453 1
	if (!GetGood(encryptMe,MAXSTR,FromQI))
d455 1
a455 1
	    fprintf(stderr,"Whoops--the nameserver died.\n");
d458 4
a461 4
	code=atoi(encryptMe);
	if (code!=LR_LOGIN)		/* intermediate or strange response */
	    fputs(encryptMe,stdout);
	if (code>=LR_OK)		/* final response */
d465 1
a465 1
    if (code==LR_LOGIN)
d468 1
a468 1
	password=getpass("Enter nameserver password: ");
d472 2
a473 2
	encryptMe[strlen(encryptMe)-1] = '\0';	/* strip linefeed */
	encryptit(encrypted,index(encryptMe,':')+1);
d476 1
a476 1
	fprintf(ToQI,"answer %s\n",encrypted);
d482 1
a482 1
	    if (!GetGood(encryptMe,MAXSTR,FromQI))
d484 1
a484 1
		fprintf(stderr,"Whoops--the nameserver died.\n");
d487 3
a489 3
	    code=atoi(encryptMe);
	    fputs(encryptMe,stdout);
	    if (code>=LR_OK)		/* final response */
d494 1
a494 1
    if (code==LR_OK)			/* logged in */
d496 3
a498 3
	strcpy(MyAlias,index(encryptMe,':')+1);
	*index(MyAlias,':') = '\0';
	VetPassword(password);		/* make sure password is reasonable */
d507 3
a509 3
DoQuit(inputLine,helpOnly)
char *inputLine;
int helpOnly;
d511 3
a513 2
    DoOther(inputLine,helpOnly);
    if (!helpOnly) exit(0);
d519 3
a521 3
DoEdit(inputLine,helpOnly)
char *inputLine;
int helpOnly;
d523 3
a525 3
    char *theField;
    char *theAlias;
    char *theValue;
d539 2
a540 2
    (void)strtok(inputLine,DELIM);		/* skip ``edit'' */
    if (!(theField=strtok((char *)0,DELIM)))
d542 1
a542 1
	DoEdit(inputLine,1);
d546 2
a547 2
    if (!(theAlias=strtok((char *)0,DELIM)))
	theAlias=MyAlias;
d549 2
a550 2
    if ((theValue=GetValue(theAlias,theField)) && EditValue(theValue))
	UpdateValue(theAlias,theField,theValue);
d556 4
a559 3
char *GetValue(theAlias,theField)
char *theAlias;
char *theField;
d562 3
a564 3
    char *vSpot;
    char scratch[MAXSTR];
    int code;
d566 1
a566 1
    if (!strcmp(theField,"password"))
d569 1
a569 1
	return(NULL);
d573 1
a573 1
    fprintf(ToQI,"query alias=%s return %s\n",theAlias,theField);
d576 1
a576 1
    *theValue='\0';
d579 1
a579 1
    for (vSpot=theValue;;vSpot+=strlen(vSpot))
d581 1
a581 1
	if (!GetGood(scratch,MAXSTR,FromQI))
d583 1
a583 1
	    fprintf(stderr,"Ding-dong the server's dead!\n");
d586 2
a587 4
	if ((code=atoi(scratch))==-LR_OK)
	    strcpy(vSpot,index(GetQValue(scratch),':')+2);	/* part of value */
	else if (code>=LR_OK)
	    break;				/* final response */
d589 4
a592 1
	    fputs(scratch,stdout);		/* ??? */
d595 2
a596 2
    if (code!=LR_OK)				/* error */
	fputs(scratch,stdout);
d598 1
a598 1
    return(code==LR_OK ? theValue : NULL);
d605 1
a605 1
char *theValue;		/* the value to edit */
d607 4
a610 4
    char *theFileName;			/* name of temp file to use */
    char *mktemp();
    char template[20];
    int fd;				/* file descriptor for temp file */
d612 2
a613 2
    char *editor;			/* editor program to use */
    int bytes;				/* numnber of bytes in file */
d615 2
a616 2
    int badChar;			/* did we find a bad character? */
    int junk;
d619 1
a619 1
    strcpy(template,"/tmp/phXXXXXX");
d621 1
a621 1
    if ((fd=open(theFileName,O_RDWR | O_CREAT,0777))<0)
d624 1
a624 1
	return(0);
d627 1
a627 1
    if (write(fd,theValue,strlen(theValue))<0)
d631 1
a631 1
	return(0);
d637 2
a638 2
    if (!(editor=getenv("EDITOR")))
	editor="/usr/ucb/vi";
d643 1
a643 1
	execlp(editor,editor,theFileName,NULL);
d646 1
a646 1
    if ((fd=open(theFileName,0))<0)
d650 1
a650 1
	return(0);
d655 1
a655 1
    if ((bytes=read(fd,newValue,MAXSTR-1))<0)
d659 1
a659 1
	return(0);
d665 2
a666 2
    if (!strcmp(newValue,theValue))
	return(0);
d670 2
a671 2
    for (to=theValue,from=newValue;*from;from++)
	if (*from=='"')
d676 2
a677 1
	else if (*from >= ' ' && *from <='~')
d679 2
a680 1
	else if (*from=='\t')
d685 2
a686 1
	else if (*from=='\n')
d688 1
a688 1
	    if (*(from+1))	/* skip terminating newline from vi */
d695 1
a695 1
	    badChar=1;
d701 3
a703 3
	fputs("Illegal characters were found in your value.\n",stderr);
	fputs("Please use only printable characters, newlines, and tabs.\n",stderr);
	fputs("The offending characters were removed.\n",stderr);
d706 1
a706 1
    return(1);
d712 4
a715 4
UpdateValue(theAlias,theField,theValue)
char *theAlias;
char *theField;
char *theValue;
d717 1
a717 1
    fprintf(ToQI,"change alias=%s make %s=\"%s\"\n",theAlias,theField,theValue);
d725 3
a727 3
DoMe(inputLine,helpOnly)
char *inputLine;
int helpOnly;
d729 1
a729 1
    char scratch[MAXSTR];
d731 1
a731 1
    if (helpOnly || ! *MyAlias)
d740 2
a741 2
    sprintf(scratch,"query alias=%s\n",MyAlias);
    fputs(scratch,ToQI);
d749 3
a751 3
DoPassword(inputLine,helpOnly)
char *inputLine;
int helpOnly;
d753 3
a755 3
    char password[80];
    char *confirm;
    char *theAlias;
d769 3
a771 3
    (void)strtok(inputLine,DELIM);
    if (!(theAlias=strtok((char *)0,DELIM)))
	theAlias=MyAlias;
d774 3
a776 3
    strcpy(password,getpass("Enter new password: "));
    confirm=getpass("Type it again: ");
    if (strcmp(confirm,password))
d778 1
a778 1
	fprintf(stderr,"Sorry--passwords didn't match.\n");
d781 1
a781 1
    VetPassword(confirm); /* complain if we don't like the password */
d784 2
a785 2
    encryptit(password,confirm);
    fprintf(ToQI,"change alias=%s make password=%s\n",theAlias,password);
d789 1
a789 1
    if (PrintResponse()==LR_OK && theAlias==MyAlias)
d796 3
a798 3
DoLogout(inputLine,helpOnly)
char *inputLine;
int helpOnly;
d808 1
a808 1
    DoOther(inputLine,helpOnly);
d815 1
a815 1
char *thePassword;
d817 3
a819 3
    if (strlen(thePassword)<5 ||	/* too short */
	AllDigits(thePassword))		/* digits only */
	fputs("That is an insecure password; please change it.\n",stderr);
d828 1
a828 1
    for (;*theString;theString++)
d830 2
a831 2
	    return(0);
    return(1);
d840 6
a845 6
    char theLine[MAXSTR];
    int theCode;
    int currentPerson=0;
    int thePerson;
    char *thePager;
    FILE *theOutput;
d848 1
a848 1
    if ((thePager=getenv("PAGER"))==NULL)
a849 3
    
    if ((theOutput=popen(thePager,"w"))==NULL)
	theOutput=stdout;
d851 3
d855 1
a855 1
    while (GetGood(theLine,MAXSTR,FromQI))
d857 1
a857 1
	theCode=atoi(theLine);
d860 1
a860 1
	    thePerson=atoi(index(theLine,':')+1);
d862 1
a862 1
	    if (thePerson!=currentPerson)
d864 2
a865 2
		fputs("----------------------------------------\n",theOutput);
		currentPerson=thePerson;
d868 1
a868 1
	    fputs(GetQValue(theLine),theOutput);
d870 3
a872 2
	else if (theCode != LR_OK)
	    fputs(theLine,theOutput);	/* error */
d880 3
a882 3
	    fputs("----------------------------------------\n",theOutput);
    
    if (theOutput!=stdout)
d891 8
a898 9
   function:   strtok
   purpose:    to break a string into tokens
   parameters: s1 string to be tokenized or 0 (which will use last string)
	       s2 delimiters
   returns:    pointer to first token.  Puts a null after the token.
	       returns NULL if no tokens remain.
*/
char *strtok(s1,s2)
char *s1,*s2;
d900 2
a901 2
	static char *old = 0;
	char *p1,*p2;
d903 11
a913 4
	if (!(s1 || old)) return(NULL);
	p1 = (s1 ? s1:old);
	while (*p1 && (index(s2,*p1)!=NULL)) p1++;
	if (*p1)
d915 2
a916 9
		p2 = p1;
		while (*p2 && (index(s2,*p2)==NULL)) p2++;
		if (*p2)
		{
			*p2 = '\0';
			old = ++p2;
		}
		else old=0;
		return (p1);
d918 6
a923 1
	else return(NULL);
@


2.11
log
@Changed DoCommand to not expand command names if the command is being
executed help only.

Added check for error on stdin to accommodate Pyramids and ^D.
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.10 88/03/09 09:59:32 dorner Locked $";
d266 1
a266 2
	if (!*fgets(inputLine,MAXSTR,stdin)) break;	/* read line */
	if (ferror(stdin)) break;
@


2.10
log
@Changed help texts, added test version
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.9 88/03/01 10:29:48 dorner Locked $";
d267 1
d311 2
a312 1
	sprintf(inputLine,"%s %s\n",doMe->cName,theToken?theToken:"");
@


2.9
log
@fixed field name in GetValue bug.
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.8 88/03/01 10:20:58 dorner Locked $";
d54 1
d63 1
d106 1
a106 1
    if (theNs=getservbyname(NSSERVICE,"tcp"))
a520 2
	puts("\tThis is capacity is under CSO staff test, and is not");
	puts("\tfunctional for non-CSO users.");
d592 1
d602 2
a603 1
    theFileName = mktemp("/tmp/phXXXXXX");
a744 2
	puts("\tThis is capacity is under CSO staff test, and is not");
	puts("\tfunctional for non-CSO users.");
@


2.8
log
@declared popen for the benighted 4.2 systems...
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.7 88/03/01 10:09:07 dorner Locked $";
d571 1
a571 1
	    strcpy(vSpot,GetQValue(scratch));	/* part of value */
@


2.7
log
@fixed a trivial bug
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.6 88/03/01 10:02:35 dorner Locked $";
d44 1
@


2.6
log
@added ``me'' command
prettified code
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.5 88/02/24 17:01:56 dorner Locked $";
d708 1
a708 1
    if (helpOnly || !MyAlias)
@


2.5
log
@fixed strtok bug in DoCommand.
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.4 88/02/17 14:06:48 dorner Locked $";
d36 1
a36 1
#define DELIM		" ,\t\n"
d45 1
a45 1
	    (index(index(index(aLine,':')+1,':')+1,':')+2)
d150 1
a150 1
 * command
d210 1
a210 3
    fprintf(stderr,"Warning--there is no entry for ``%s'' in /etc/hosts;\n",
	HOST);
    fputs("please have your systems administrator add one.\n",stderr);
d227 1
a227 1
int DoLogout();
d235 1
d257 1
a257 2
    puts("This is a test version of ph.  Please mail questions or comments");
    puts("to dorner@@uxg.cso.uiuc.edu.");
d295 1
a295 1
	    if (doMe)
d300 1
a300 1
	    doMe = theCommand;
d303 1
a303 1
    if (doMe)
d305 1
d308 3
a310 1
	(*doMe->cFunc)(inputLine,helpOnly);	/* found it */
d412 3
a414 3
    char encryptMe[MAXSTR];
    char encrypted[MAXSTR];
    char *password;
d425 3
a427 5
	/*puts("\tYou will be prompted for your password.  If you do not know it,");*/
	/*puts("\tcontact CSO at 3-3339.");*/
	puts("\tThis is capacity is under CSO staff test.  CSO staff ONLY may find");
	puts("\ttheir passwords by sending mail to dorner@@uxg.  If all goes well,");
	puts("\tit will be allowed for all users in a few weeks.");
d442 1
a442 1
	if (code!=LR_LOGIN)
d444 1
a444 1
	if (code>=LR_OK)
d450 1
a450 1
	/* the nameserver wants a password */
d453 2
d457 2
d472 1
a472 1
	    if (code>=LR_OK)
d477 1
a477 1
    if (code==LR_OK)
d481 1
a481 1
	PassComplain(password);
d538 1
a538 1
* get a value from the nameserver
d544 1
a544 1
    static char theValue[MAXVAL];
d560 2
d570 1
a570 1
	    strcpy(vSpot,GetQValue(scratch));
d572 1
a572 1
	    break;
d574 1
a574 1
	    fputs(scratch,stdout);
d577 1
a577 1
    if (code!=LR_OK)
d587 1
a587 1
char *theValue;
d589 1
a589 1
    char *theFileName;
d591 4
a594 4
    int fd;
    static char newValue[MAXVAL];
    char *editor;
    int bytes;
d596 1
a596 1
    int badChar;
d599 1
d616 1
d625 1
d644 1
d648 1
d676 1
a676 1
    if (badChar)
d687 1
a687 1
* update a nameserver field
d700 24
d747 1
d752 1
d760 3
a762 1
    PassComplain(confirm);
d766 2
d793 1
a793 1
PassComplain(thePassword)
d815 1
d826 1
d833 1
d840 1
d846 1
d850 1
a850 1
	    fputs(theLine,theOutput);
d856 1
d863 5
@


2.4
log
@Improved the on-line help texts.
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.3 88/02/17 08:33:01 dorner Locked $";
d307 2
a308 1
	sprintf(inputLine,"%s %s\n",doMe->cName,strtok(0,"\n"));
@


2.3
log
@Improved error handline in PrintQResponse.
Installed pager in PrintResponse.
Fixed miscellaneous cosmetics.
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.2 88/02/15 15:13:53 dorner Locked $";
d345 2
d378 17
a394 1
	DoOther(inputLine,helpOnly);
d418 2
d422 1
a422 1
	puts("\tTo find out your alias, say ``query your_name return alias''.");
d507 2
a508 1
	puts("\tUsage:  edit field [alias]");
d702 1
d740 2
@


2.2
log
@Added explicit flushes to keep uxe happy (sigh).
Fixed mishandling of open on temp file (because uxe doesn't have mkstemp).
Changed strchr to index in strtok (uxe doesn't have strtok or strchr).
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.1 88/02/15 14:31:58 dorner Locked $";
d43 1
d78 1
d156 2
d159 7
d168 1
a168 1
	fputs(scratch,stdout);			/* echo it */
d171 3
d234 1
d282 2
d292 2
d295 1
a295 1
	if (!strcmp(theCommand->cName,theToken))
d297 6
a302 2
	    (*theCommand->cFunc)(inputLine,helpOnly);	/* found it */
	    return(1);
d304 8
a311 1
    
d329 1
d381 1
d412 1
d436 1
a436 1
    }
d438 2
a439 4
    /* get the final response */
    for (;;)
    {
	if (!GetGood(encryptMe,MAXSTR,FromQI))
d441 9
a449 2
	    fprintf(stderr,"Whoops--the nameserver died.\n");
	    exit(1);
a450 4
	code=atoi(encryptMe);
	fputs(encryptMe,stdout);
	if (code>=LR_OK)
	    break;
d532 1
d534 1
a566 1
    char *getenv();
d663 1
d680 1
d682 2
a683 1
	puts("\tyour nameserver password to what you type.  Use this command often.");
d704 1
d769 1
a769 1
	if (theCode== -LR_OK)
d779 4
a782 1
	else if (theCode==LR_OK)
a783 2
	else
	    fputs(theLine,theOutput);
@


2.1
log
@Added strtok() for those systems without.
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 2.0 88/02/15 13:57:23 dorner Locked $";
d18 1
a134 1
    setlinebuf(ToQI);	/* so we don't have to flush all the time */
d526 2
a527 1
    char theFileName[80];
d537 2
a538 3
    strcpy(theFileName,"/tmp/phXXXXXX");
    (void) mktemp(theFileName);
    if ((fd=open(theFileName,0))<0)
d540 1
a540 1
	fputs("Temp file error.\n",stderr);
d546 1
a546 1
	fputs("Temp file error.\n",stderr);
d563 1
a563 1
	fputs("Temp file error.\n",stderr);
d572 1
a572 1
	fputs("Temp file error.\n",stderr);
@


2.0
log
@Initial test version of user-editable nameserver client.
@
text
@d13 1
a13 1
static char *rcsid = "$Header: ph.c,v 1.2 87/10/26 14:24:59 dorner Locked $";
d537 2
a538 1
    if ((fd=mkstemp(theFileName))<0)
d751 31
@


1.2
log
@*** empty log message ***
@
text
@d2 9
a10 7
* This is a simple nameserver client.  It attempts to contact the nameserver
* running on uxg.cso.uiuc.edu, and query it about entries.  The following
* entries in /etc/hosts (if you're using one) and /etc/services will help
* matters:
* hosts:
* 128.174.5.53	ripple.cso.uiuc.edu ripple-uiuc-cso-dclnet ripple uxg uxg.cso.uiuc.edu
* services:
d21 2
d24 3
d29 2
a30 2
#define NSSERVICE	"nstest"
#define FALLBACKADDR	0x80ae0535         	/* uxg, 128.174.5.53 */
d33 3
a35 2
#define MAXSTR 180		/* max string length */
#define MIN_LETTERS 1		/* min # of letters to use with '*' */
d37 18
d59 5
a63 5
    FILE *toQI;
    FILE *fromQI;

    if (!ContactQI(&toQI,&fromQI))
	fprintf(stderr,"Sorry--phone book not available now.\n");
d65 1
a65 1
	Interactive(toQI,fromQI);
d68 2
a69 1
	fputs("query ",toQI);
d72 2
a73 2
	    fputs(*argv,toQI);
	    if (argc>1) putc(' ',toQI);
d75 1
a75 3
	putc('\n',toQI);
	fputs("end\n",toQI);
	fflush(toQI);
d77 2
a78 5
	PrintResponse(fromQI);

	CloseUpShop(toQI,fromQI);

	exit(0);
d80 1
a80 1
    exit(1);
a83 31
 * send the appropriate magic incantations to nameserver
 ***********************************************************************/
MagicIncantations(toQI)
FILE *toQI;
{
    fputs("interactive\n",toQI);
    fputs("csnet\n",toQI);
    fputs("version\n\t3.0\n",toQI);
    fputs("whois\n",toQI);
    fputs("exact\n",toQI);
    putc('\t',toQI);
}
/***********************************************************************
 * print a short usage message
 ***********************************************************************/
Usage(Program)
char *Program;
{
    fprintf(stderr,"Usage: %s name\n",Program);
    fprintf(stderr,"\nTo have your email address entered into the database,\n");
    fprintf(stderr,"send mail to %s in the following format:\n",CONTACT);
    fprintf(stderr,"\te-mail_address phone_number your_name\n");
    fprintf(stderr,"for example:\n");
    fprintf(stderr,"\tjoey@@uxc.cso.uiuc.edu 3-9999 joseph kangaroo\n");
    fprintf(stderr,"Please give your name as it appears in the phone book.\n");
    fprintf(stderr,"Note:\n");
    fprintf(stderr,"\tWe cannot at this time accept changes to your\n");
    fprintf(stderr,"\tphone number or address;  such changes should\n");
    fprintf(stderr,"\tbe made through normal University channels.\n");
}
/***********************************************************************
d86 1
a86 3
ContactQI(to,from)
FILE **to;
FILE **from;
d88 4
a91 5
    int sock;
    int addr;
    struct sockaddr_in QI;
    struct servent *theNs;
    struct hostent *theHost;
d93 1
d99 1
d110 1
d121 1
d128 2
a129 1
    if ((*to = fdopen(sock,"w"))==NULL)
d134 4
a137 1
    if ((*from = fdopen(sock,"r"))==NULL)
d146 3
a148 1
 * print what the QI says
d150 1
a150 2
PrintResponse(QI)
FILE *QI;
d152 2
a153 3
    char scratch[MAXSTR];
    int code;
    int num;
d155 1
a155 1
    while (GetGood(scratch,MAXSTR,QI))
d157 2
a158 2
	fputs(scratch,stdout);
	if (atoi(scratch)>=200) break;
d160 1
d165 1
d168 3
a170 3
char *theString;
int maxChars;
FILE *theFile;
d174 1
a174 1
	fgets(theString,maxChars,theFile);
d176 1
a176 1
	    return(1);
d178 1
a178 1
	    return(0);
a181 17
 * Be done
 ***********************************************************************/
CloseUpShop(to,from)
FILE *to;
FILE *from;
{
    int exit();

    signal(SIGALRM,exit);
    alarm(10);

    fputs("quit\n",to);

    fclose(to);
    fclose(from);
}
/***********************************************************************
d206 31
d239 511
@
